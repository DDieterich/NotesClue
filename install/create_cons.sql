
select '=== CLUE create_cons ===' as SCRIPT_NAME from dual;

-- Script File "create_cons"
--    Create Constraints

   -- Application: Clue Notes For Oracle
   -- Generated by DTGen (http://dmstex.com/services/dtgen)
   -- December  16, 2013  11:32:29 AM

   --
   --
   -- © Duane.Dieterich@DMSTEX.com 2013
   --
   -- All Rights Reserved
   --
   -- No part of this software may be reproduced, copied, modified or adapted,
   -- without the prior written consent of the author, unless otherwise
   -- indicated for stand-alone materials.
   --
   -- You may quote extracts from this software with attribution to
   -- Duane.Dieterich@DMSTEX.com
   --
   -- For any other mode of sharing, please contact Duane.Dieterich@DMSTEX.com.
   --
   -- Commercial use and distribution of this software is not allowed without
   -- express and prior written consent of the author.
   --
   -- THE SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
   -- INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY
   -- AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL
   -- THE COPYRIGHT HOLDER OR DMSTEX BUSINESS SOLUTIONS LLC, ITS MEMBERS,
   -- MANAGERS, OR EMPLOYEES BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
   -- SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
   -- TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
   -- PROFITS; CORRUPTION OF DATA, OR BUSINESS INTERRUPTION) HOWEVER CAUSED
   -- AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
   -- OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF
   -- THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH
   -- DAMAGE.
   --
   --




create package users_tab
is

   -- Package Users_Tab
   --    Table functions
   --    (DML and integrity checks)
   --

   -- Application: Clue Notes For Oracle
   -- Generated by DTGen (http://dmstex.com/services/dtgen)
   -- December  16, 2013  11:32:29 AM

   --
   --
   -- © Duane.Dieterich@DMSTEX.com 2013
   --
   -- All Rights Reserved
   --
   -- No part of this software may be reproduced, copied, modified or adapted,
   -- without the prior written consent of the author, unless otherwise
   -- indicated for stand-alone materials.
   --
   -- You may quote extracts from this software with attribution to
   -- Duane.Dieterich@DMSTEX.com
   --
   -- For any other mode of sharing, please contact Duane.Dieterich@DMSTEX.com.
   --
   -- Commercial use and distribution of this software is not allowed without
   -- express and prior written consent of the author.
   --
   -- THE SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
   -- INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY
   -- AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL
   -- THE COPYRIGHT HOLDER OR DMSTEX BUSINESS SOLUTIONS LLC, ITS MEMBERS,
   -- MANAGERS, OR EMPLOYEES BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
   -- SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
   -- TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
   -- PROFITS; CORRUPTION OF DATA, OR BUSINESS INTERRUPTION) HOWEVER CAUSED
   -- AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
   -- OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF
   -- THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH
   -- DAMAGE.
   --
   --


   -- Indicates the BI/BU/BD Trigger needs to run the TAB Package DML
   -- NOTE: This package must be local to its table.  If this package
   --   makes a remote SQL call to its table, the following variable
   --   will not be set corectly in the remote session
   run_tab  boolean  := TRUE;

   -- Check Constraints for a users Record
   function rec_status
      (id_in  in  NUMBER
      )  return varchar2;

   function get_id
      (users_nk1  in  VARCHAR2  -- name
      ) return NUMBER;
   function get_nk
      (id_in  in  NUMBER
      ) return varchar2;

   -- Should be called exclusively by the BI Trigger
   procedure ins_bi_trigger
      (n_id  in out nocopy  NUMBER
      ,n_name  in out nocopy  VARCHAR2
      );
   -- Can be called from anywhere, except the BI Trigger
   procedure ins
      (n_rec  in out nocopy  users%ROWTYPE
      );

   -- Should be called exclusively by the BU Trigger
   --   or the "upd" procedure below
   -- Note: the OLD values must be provided to check ignore_no_change
   -- Note2:  Select for Update Lock is assumed on old values row
   procedure upd_bu_trigger
      (o_id  in  NUMBER
      ,o_name  in  VARCHAR2
      ,n_name  in out nocopy  VARCHAR2
      ,run_update  out  boolean
      );
   -- Can be called from anywhere, except the BU Trigger
   -- Note: the OLD values must be provided to check ignore_no_change
   procedure upd
      (o_rec  in             users%ROWTYPE
      ,n_rec  in out nocopy  users%ROWTYPE
      );
   -- Can be called from anywhere, except the BU Trigger
   -- Note: the OLD values must be provided to check ignore_no_change
   procedure upd
      (n_rec  in out nocopy  users%ROWTYPE
      );

   -- There is no delete trigger for this table
   procedure del
      (o_id  in  NUMBER
      );

end users_tab;
/
select 'USERS_TAB' as "Package:"
 from  user_errors
 where name  = 'USERS_TAB'
  and  type  = 'PACKAGE'
  and  rownum = 1
/
select '('||line||'/'||position||') '||text as error
 from  user_errors
 where name = 'USERS_TAB'
  and  type = 'PACKAGE'
 order by sequence
/


create package card_types_tab
is

   -- Package Card_Types_Tab
   --    Table functions
   --    (DML and integrity checks)
   --

   -- Application: Clue Notes For Oracle
   -- Generated by DTGen (http://dmstex.com/services/dtgen)
   -- December  16, 2013  11:32:29 AM

   --
   --
   -- © Duane.Dieterich@DMSTEX.com 2013
   --
   -- All Rights Reserved
   --
   -- No part of this software may be reproduced, copied, modified or adapted,
   -- without the prior written consent of the author, unless otherwise
   -- indicated for stand-alone materials.
   --
   -- You may quote extracts from this software with attribution to
   -- Duane.Dieterich@DMSTEX.com
   --
   -- For any other mode of sharing, please contact Duane.Dieterich@DMSTEX.com.
   --
   -- Commercial use and distribution of this software is not allowed without
   -- express and prior written consent of the author.
   --
   -- THE SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
   -- INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY
   -- AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL
   -- THE COPYRIGHT HOLDER OR DMSTEX BUSINESS SOLUTIONS LLC, ITS MEMBERS,
   -- MANAGERS, OR EMPLOYEES BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
   -- SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
   -- TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
   -- PROFITS; CORRUPTION OF DATA, OR BUSINESS INTERRUPTION) HOWEVER CAUSED
   -- AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
   -- OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF
   -- THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH
   -- DAMAGE.
   --
   --


   -- Indicates the BI/BU/BD Trigger needs to run the TAB Package DML
   -- NOTE: This package must be local to its table.  If this package
   --   makes a remote SQL call to its table, the following variable
   --   will not be set corectly in the remote session
   run_tab  boolean  := TRUE;

   -- Check Constraints for a card_types Record
   function rec_status
      (id_in  in  NUMBER
      )  return varchar2;

   function get_id
      (card_types_nk1  in  VARCHAR2  -- users_nk1
      ,card_types_nk2  in  VARCHAR2  -- name
      ) return NUMBER;
   function get_nk
      (id_in  in  NUMBER
      ) return varchar2;

   -- Should be called exclusively by the BI Trigger
   procedure ins_bi_trigger
      (n_id  in out nocopy  NUMBER
      ,n_user_id  in out nocopy  NUMBER
      ,n_name  in out nocopy  VARCHAR2
      ,n_sort_ord  in out nocopy  NUMBER
      );
   -- Can be called from anywhere, except the BI Trigger
   procedure ins
      (n_rec  in out nocopy  card_types%ROWTYPE
      );

   -- Should be called exclusively by the BU Trigger
   --   or the "upd" procedure below
   -- Note: the OLD values must be provided to check ignore_no_change
   -- Note2:  Select for Update Lock is assumed on old values row
   procedure upd_bu_trigger
      (o_id  in  NUMBER
      ,o_user_id  in  NUMBER
      ,n_user_id  in out nocopy  NUMBER
      ,o_name  in  VARCHAR2
      ,n_name  in out nocopy  VARCHAR2
      ,o_sort_ord  in  NUMBER
      ,n_sort_ord  in out nocopy  NUMBER
      ,run_update  out  boolean
      );
   -- Can be called from anywhere, except the BU Trigger
   -- Note: the OLD values must be provided to check ignore_no_change
   procedure upd
      (o_rec  in             card_types%ROWTYPE
      ,n_rec  in out nocopy  card_types%ROWTYPE
      );
   -- Can be called from anywhere, except the BU Trigger
   -- Note: the OLD values must be provided to check ignore_no_change
   procedure upd
      (n_rec  in out nocopy  card_types%ROWTYPE
      );

   -- There is no delete trigger for this table
   procedure del
      (o_id  in  NUMBER
      );

end card_types_tab;
/
select 'CARD_TYPES_TAB' as "Package:"
 from  user_errors
 where name  = 'CARD_TYPES_TAB'
  and  type  = 'PACKAGE'
  and  rownum = 1
/
select '('||line||'/'||position||') '||text as error
 from  user_errors
 where name = 'CARD_TYPES_TAB'
  and  type = 'PACKAGE'
 order by sequence
/


create package games_tab
is

   -- Package Games_Tab
   --    Table functions
   --    (DML and integrity checks)
   --

   -- Application: Clue Notes For Oracle
   -- Generated by DTGen (http://dmstex.com/services/dtgen)
   -- December  16, 2013  11:32:29 AM

   --
   --
   -- © Duane.Dieterich@DMSTEX.com 2013
   --
   -- All Rights Reserved
   --
   -- No part of this software may be reproduced, copied, modified or adapted,
   -- without the prior written consent of the author, unless otherwise
   -- indicated for stand-alone materials.
   --
   -- You may quote extracts from this software with attribution to
   -- Duane.Dieterich@DMSTEX.com
   --
   -- For any other mode of sharing, please contact Duane.Dieterich@DMSTEX.com.
   --
   -- Commercial use and distribution of this software is not allowed without
   -- express and prior written consent of the author.
   --
   -- THE SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
   -- INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY
   -- AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL
   -- THE COPYRIGHT HOLDER OR DMSTEX BUSINESS SOLUTIONS LLC, ITS MEMBERS,
   -- MANAGERS, OR EMPLOYEES BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
   -- SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
   -- TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
   -- PROFITS; CORRUPTION OF DATA, OR BUSINESS INTERRUPTION) HOWEVER CAUSED
   -- AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
   -- OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF
   -- THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH
   -- DAMAGE.
   --
   --


   -- Indicates the BI/BU/BD Trigger needs to run the TAB Package DML
   -- NOTE: This package must be local to its table.  If this package
   --   makes a remote SQL call to its table, the following variable
   --   will not be set corectly in the remote session
   run_tab  boolean  := TRUE;

   -- Check Constraints for a games Record
   function rec_status
      (id_in  in  NUMBER
      )  return varchar2;

   function get_id
      (games_nk1  in  VARCHAR2  -- users_nk1
      ,games_nk2  in  VARCHAR2  -- name
      ) return NUMBER;
   function get_nk
      (id_in  in  NUMBER
      ) return varchar2;

   -- Should be called exclusively by the BI Trigger
   procedure ins_bi_trigger
      (n_id  in out nocopy  NUMBER
      ,n_user_id  in out nocopy  NUMBER
      ,n_name  in out nocopy  VARCHAR2
      ,n_last_act_num  in out nocopy  NUMBER
      ,n_completed  in out nocopy  VARCHAR2
      ,n_hide_undo  in out nocopy  VARCHAR2
      ,n_hide_accuse  in out nocopy  VARCHAR2
      ,n_hide_missing  in out nocopy  VARCHAR2
      ,n_hide_my_sugg  in out nocopy  VARCHAR2
      ,n_hide_pcards  in out nocopy  VARCHAR2
      ,n_hide_sugg_hist  in out nocopy  VARCHAR2
      );
   -- Can be called from anywhere, except the BI Trigger
   procedure ins
      (n_rec  in out nocopy  games%ROWTYPE
      );

   -- Should be called exclusively by the BU Trigger
   --   or the "upd" procedure below
   -- Note: the OLD values must be provided to check ignore_no_change
   -- Note2:  Select for Update Lock is assumed on old values row
   procedure upd_bu_trigger
      (o_id  in  NUMBER
      ,o_user_id  in  NUMBER
      ,n_user_id  in out nocopy  NUMBER
      ,o_name  in  VARCHAR2
      ,n_name  in out nocopy  VARCHAR2
      ,o_last_act_num  in  NUMBER
      ,n_last_act_num  in out nocopy  NUMBER
      ,o_completed  in  VARCHAR2
      ,n_completed  in out nocopy  VARCHAR2
      ,o_hide_undo  in  VARCHAR2
      ,n_hide_undo  in out nocopy  VARCHAR2
      ,o_hide_accuse  in  VARCHAR2
      ,n_hide_accuse  in out nocopy  VARCHAR2
      ,o_hide_missing  in  VARCHAR2
      ,n_hide_missing  in out nocopy  VARCHAR2
      ,o_hide_my_sugg  in  VARCHAR2
      ,n_hide_my_sugg  in out nocopy  VARCHAR2
      ,o_hide_pcards  in  VARCHAR2
      ,n_hide_pcards  in out nocopy  VARCHAR2
      ,o_hide_sugg_hist  in  VARCHAR2
      ,n_hide_sugg_hist  in out nocopy  VARCHAR2
      ,run_update  out  boolean
      );
   -- Can be called from anywhere, except the BU Trigger
   -- Note: the OLD values must be provided to check ignore_no_change
   procedure upd
      (o_rec  in             games%ROWTYPE
      ,n_rec  in out nocopy  games%ROWTYPE
      );
   -- Can be called from anywhere, except the BU Trigger
   -- Note: the OLD values must be provided to check ignore_no_change
   procedure upd
      (n_rec  in out nocopy  games%ROWTYPE
      );

   -- There is no delete trigger for this table
   procedure del
      (o_id  in  NUMBER
      );

end games_tab;
/
select 'GAMES_TAB' as "Package:"
 from  user_errors
 where name  = 'GAMES_TAB'
  and  type  = 'PACKAGE'
  and  rownum = 1
/
select '('||line||'/'||position||') '||text as error
 from  user_errors
 where name = 'GAMES_TAB'
  and  type = 'PACKAGE'
 order by sequence
/


create package players_tab
is

   -- Package Players_Tab
   --    Table functions
   --    (DML and integrity checks)
   --

   -- Application: Clue Notes For Oracle
   -- Generated by DTGen (http://dmstex.com/services/dtgen)
   -- December  16, 2013  11:32:29 AM

   --
   --
   -- © Duane.Dieterich@DMSTEX.com 2013
   --
   -- All Rights Reserved
   --
   -- No part of this software may be reproduced, copied, modified or adapted,
   -- without the prior written consent of the author, unless otherwise
   -- indicated for stand-alone materials.
   --
   -- You may quote extracts from this software with attribution to
   -- Duane.Dieterich@DMSTEX.com
   --
   -- For any other mode of sharing, please contact Duane.Dieterich@DMSTEX.com.
   --
   -- Commercial use and distribution of this software is not allowed without
   -- express and prior written consent of the author.
   --
   -- THE SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
   -- INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY
   -- AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL
   -- THE COPYRIGHT HOLDER OR DMSTEX BUSINESS SOLUTIONS LLC, ITS MEMBERS,
   -- MANAGERS, OR EMPLOYEES BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
   -- SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
   -- TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
   -- PROFITS; CORRUPTION OF DATA, OR BUSINESS INTERRUPTION) HOWEVER CAUSED
   -- AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
   -- OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF
   -- THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH
   -- DAMAGE.
   --
   --


   -- Indicates the BI/BU/BD Trigger needs to run the TAB Package DML
   -- NOTE: This package must be local to its table.  If this package
   --   makes a remote SQL call to its table, the following variable
   --   will not be set corectly in the remote session
   run_tab  boolean  := TRUE;

   -- Check Constraints for a players Record
   function rec_status
      (id_in  in  NUMBER
      )  return varchar2;

   function get_id
      (players_nk1  in  VARCHAR2  -- games_nk1
      ,players_nk2  in  VARCHAR2  -- games_nk2
      ,players_nk3  in  VARCHAR2  -- name
      ) return NUMBER;
   function get_nk
      (id_in  in  NUMBER
      ) return varchar2;

   -- Should be called exclusively by the BI Trigger
   procedure ins_bi_trigger
      (n_id  in out nocopy  NUMBER
      ,n_game_id  in out nocopy  NUMBER
      ,n_name  in out nocopy  VARCHAR2
      ,n_seq  in out nocopy  NUMBER
      ,n_total_cards  in out nocopy  NUMBER
      );
   -- Can be called from anywhere, except the BI Trigger
   procedure ins
      (n_rec  in out nocopy  players%ROWTYPE
      );

   -- Should be called exclusively by the BU Trigger
   --   or the "upd" procedure below
   -- Note: the OLD values must be provided to check ignore_no_change
   -- Note2:  Select for Update Lock is assumed on old values row
   procedure upd_bu_trigger
      (o_id  in  NUMBER
      ,o_game_id  in  NUMBER
      ,n_game_id  in out nocopy  NUMBER
      ,o_name  in  VARCHAR2
      ,n_name  in out nocopy  VARCHAR2
      ,o_seq  in  NUMBER
      ,n_seq  in out nocopy  NUMBER
      ,o_total_cards  in  NUMBER
      ,n_total_cards  in out nocopy  NUMBER
      ,run_update  out  boolean
      );
   -- Can be called from anywhere, except the BU Trigger
   -- Note: the OLD values must be provided to check ignore_no_change
   procedure upd
      (o_rec  in             players%ROWTYPE
      ,n_rec  in out nocopy  players%ROWTYPE
      );
   -- Can be called from anywhere, except the BU Trigger
   -- Note: the OLD values must be provided to check ignore_no_change
   procedure upd
      (n_rec  in out nocopy  players%ROWTYPE
      );

   -- There is no delete trigger for this table
   procedure del
      (o_id  in  NUMBER
      );

end players_tab;
/
select 'PLAYERS_TAB' as "Package:"
 from  user_errors
 where name  = 'PLAYERS_TAB'
  and  type  = 'PACKAGE'
  and  rownum = 1
/
select '('||line||'/'||position||') '||text as error
 from  user_errors
 where name = 'PLAYERS_TAB'
  and  type = 'PACKAGE'
 order by sequence
/


create package cards_tab
is

   -- Package Cards_Tab
   --    Table functions
   --    (DML and integrity checks)
   --

   -- Application: Clue Notes For Oracle
   -- Generated by DTGen (http://dmstex.com/services/dtgen)
   -- December  16, 2013  11:32:29 AM

   --
   --
   -- © Duane.Dieterich@DMSTEX.com 2013
   --
   -- All Rights Reserved
   --
   -- No part of this software may be reproduced, copied, modified or adapted,
   -- without the prior written consent of the author, unless otherwise
   -- indicated for stand-alone materials.
   --
   -- You may quote extracts from this software with attribution to
   -- Duane.Dieterich@DMSTEX.com
   --
   -- For any other mode of sharing, please contact Duane.Dieterich@DMSTEX.com.
   --
   -- Commercial use and distribution of this software is not allowed without
   -- express and prior written consent of the author.
   --
   -- THE SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
   -- INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY
   -- AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL
   -- THE COPYRIGHT HOLDER OR DMSTEX BUSINESS SOLUTIONS LLC, ITS MEMBERS,
   -- MANAGERS, OR EMPLOYEES BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
   -- SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
   -- TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
   -- PROFITS; CORRUPTION OF DATA, OR BUSINESS INTERRUPTION) HOWEVER CAUSED
   -- AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
   -- OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF
   -- THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH
   -- DAMAGE.
   --
   --


   -- Indicates the BI/BU/BD Trigger needs to run the TAB Package DML
   -- NOTE: This package must be local to its table.  If this package
   --   makes a remote SQL call to its table, the following variable
   --   will not be set corectly in the remote session
   run_tab  boolean  := TRUE;

   -- Check Constraints for a cards Record
   function rec_status
      (id_in  in  NUMBER
      )  return varchar2;

   function get_id
      (cards_nk1  in  VARCHAR2  -- games_nk1
      ,cards_nk2  in  VARCHAR2  -- games_nk2
      ,cards_nk3  in  VARCHAR2  -- name
      ) return NUMBER;
   function get_nk
      (id_in  in  NUMBER
      ) return varchar2;

   -- Should be called exclusively by the BI Trigger
   procedure ins_bi_trigger
      (n_id  in out nocopy  NUMBER
      ,n_game_id  in out nocopy  NUMBER
      ,n_name  in out nocopy  VARCHAR2
      ,n_ctype_id  in out nocopy  NUMBER
      );
   -- Can be called from anywhere, except the BI Trigger
   procedure ins
      (n_rec  in out nocopy  cards%ROWTYPE
      );

   -- Should be called exclusively by the BU Trigger
   --   or the "upd" procedure below
   -- Note: the OLD values must be provided to check ignore_no_change
   -- Note2:  Select for Update Lock is assumed on old values row
   procedure upd_bu_trigger
      (o_id  in  NUMBER
      ,o_game_id  in  NUMBER
      ,n_game_id  in out nocopy  NUMBER
      ,o_name  in  VARCHAR2
      ,n_name  in out nocopy  VARCHAR2
      ,o_ctype_id  in  NUMBER
      ,n_ctype_id  in out nocopy  NUMBER
      ,run_update  out  boolean
      );
   -- Can be called from anywhere, except the BU Trigger
   -- Note: the OLD values must be provided to check ignore_no_change
   procedure upd
      (o_rec  in             cards%ROWTYPE
      ,n_rec  in out nocopy  cards%ROWTYPE
      );
   -- Can be called from anywhere, except the BU Trigger
   -- Note: the OLD values must be provided to check ignore_no_change
   procedure upd
      (n_rec  in out nocopy  cards%ROWTYPE
      );

   -- There is no delete trigger for this table
   procedure del
      (o_id  in  NUMBER
      );

end cards_tab;
/
select 'CARDS_TAB' as "Package:"
 from  user_errors
 where name  = 'CARDS_TAB'
  and  type  = 'PACKAGE'
  and  rownum = 1
/
select '('||line||'/'||position||') '||text as error
 from  user_errors
 where name = 'CARDS_TAB'
  and  type = 'PACKAGE'
 order by sequence
/


create package actions_tab
is

   -- Package Actions_Tab
   --    Table functions
   --    (DML and integrity checks)
   --

   -- Application: Clue Notes For Oracle
   -- Generated by DTGen (http://dmstex.com/services/dtgen)
   -- December  16, 2013  11:32:29 AM

   --
   --
   -- © Duane.Dieterich@DMSTEX.com 2013
   --
   -- All Rights Reserved
   --
   -- No part of this software may be reproduced, copied, modified or adapted,
   -- without the prior written consent of the author, unless otherwise
   -- indicated for stand-alone materials.
   --
   -- You may quote extracts from this software with attribution to
   -- Duane.Dieterich@DMSTEX.com
   --
   -- For any other mode of sharing, please contact Duane.Dieterich@DMSTEX.com.
   --
   -- Commercial use and distribution of this software is not allowed without
   -- express and prior written consent of the author.
   --
   -- THE SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
   -- INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY
   -- AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL
   -- THE COPYRIGHT HOLDER OR DMSTEX BUSINESS SOLUTIONS LLC, ITS MEMBERS,
   -- MANAGERS, OR EMPLOYEES BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
   -- SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
   -- TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
   -- PROFITS; CORRUPTION OF DATA, OR BUSINESS INTERRUPTION) HOWEVER CAUSED
   -- AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
   -- OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF
   -- THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH
   -- DAMAGE.
   --
   --


   -- Indicates the BI/BU/BD Trigger needs to run the TAB Package DML
   -- NOTE: This package must be local to its table.  If this package
   --   makes a remote SQL call to its table, the following variable
   --   will not be set corectly in the remote session
   run_tab  boolean  := TRUE;

   -- WARNING! NEXT_SEQ does not have exclusive access to max(seq).
   --     A race between 2 transactions can return the same NEXT_SEQ
   function next_seq
      (player_id_in  in  NUMBER
      ) return number;

   -- Check Constraints for a actions Record
   function rec_status
      (id_in  in  NUMBER
      )  return varchar2;

   function get_id
      (actions_nk1  in  VARCHAR2  -- players_nk1
      ,actions_nk2  in  VARCHAR2  -- players_nk2
      ,actions_nk3  in  VARCHAR2  -- players_nk3
      ,actions_nk4  in  NUMBER  -- seq
      ) return NUMBER;
   function get_nk
      (id_in  in  NUMBER
      ) return varchar2;

   function get_res_id_path
      (id_in  in  NUMBER
      ) return VARCHAR2;
   function get_res_nk_path
      (id_in  in  NUMBER
      ) return CLOB;
   function get_res_id_by_id_path
      (id_path_in  in  VARCHAR2
      ) return NUMBER;

   -- Should be called exclusively by the BI Trigger
   procedure ins_bi_trigger
      (n_id  in out nocopy  NUMBER
      ,n_actions_sub_type  in out nocopy  VARCHAR2
      ,n_player_id  in out nocopy  NUMBER
      ,n_seq  in out nocopy  NUMBER
      ,n_resolved  in out nocopy  VARCHAR2
      ,n_res_action_id  in out nocopy  NUMBER
      ,n_rev_player_id  in out nocopy  NUMBER
      );
   -- Can be called from anywhere, except the BI Trigger
   procedure ins
      (n_rec  in out nocopy  actions%ROWTYPE
      );

   -- Should be called exclusively by the BU Trigger
   --   or the "upd" procedure below
   -- Note: the OLD values must be provided to check ignore_no_change
   -- Note2:  Select for Update Lock is assumed on old values row
   procedure upd_bu_trigger
      (o_id  in  NUMBER
      ,o_actions_sub_type  in  VARCHAR2
      ,n_actions_sub_type  in out nocopy  VARCHAR2
      ,o_player_id  in  NUMBER
      ,n_player_id  in out nocopy  NUMBER
      ,o_seq  in  NUMBER
      ,n_seq  in out nocopy  NUMBER
      ,o_resolved  in  VARCHAR2
      ,n_resolved  in out nocopy  VARCHAR2
      ,o_res_action_id  in  NUMBER
      ,n_res_action_id  in out nocopy  NUMBER
      ,o_rev_player_id  in  NUMBER
      ,n_rev_player_id  in out nocopy  NUMBER
      ,run_update  out  boolean
      );
   -- Can be called from anywhere, except the BU Trigger
   -- Note: the OLD values must be provided to check ignore_no_change
   procedure upd
      (o_rec  in             actions%ROWTYPE
      ,n_rec  in out nocopy  actions%ROWTYPE
      );
   -- Can be called from anywhere, except the BU Trigger
   -- Note: the OLD values must be provided to check ignore_no_change
   procedure upd
      (n_rec  in out nocopy  actions%ROWTYPE
      );

   -- There is no delete trigger for this table
   procedure del
      (o_id  in  NUMBER
      );

end actions_tab;
/
select 'ACTIONS_TAB' as "Package:"
 from  user_errors
 where name  = 'ACTIONS_TAB'
  and  type  = 'PACKAGE'
  and  rownum = 1
/
select '('||line||'/'||position||') '||text as error
 from  user_errors
 where name = 'ACTIONS_TAB'
  and  type = 'PACKAGE'
 order by sequence
/


create package action_cards_tab
is

   -- Package Action_Cards_Tab
   --    Table functions
   --    (DML and integrity checks)
   --

   -- Application: Clue Notes For Oracle
   -- Generated by DTGen (http://dmstex.com/services/dtgen)
   -- December  16, 2013  11:32:29 AM

   --
   --
   -- © Duane.Dieterich@DMSTEX.com 2013
   --
   -- All Rights Reserved
   --
   -- No part of this software may be reproduced, copied, modified or adapted,
   -- without the prior written consent of the author, unless otherwise
   -- indicated for stand-alone materials.
   --
   -- You may quote extracts from this software with attribution to
   -- Duane.Dieterich@DMSTEX.com
   --
   -- For any other mode of sharing, please contact Duane.Dieterich@DMSTEX.com.
   --
   -- Commercial use and distribution of this software is not allowed without
   -- express and prior written consent of the author.
   --
   -- THE SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
   -- INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY
   -- AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL
   -- THE COPYRIGHT HOLDER OR DMSTEX BUSINESS SOLUTIONS LLC, ITS MEMBERS,
   -- MANAGERS, OR EMPLOYEES BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
   -- SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
   -- TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
   -- PROFITS; CORRUPTION OF DATA, OR BUSINESS INTERRUPTION) HOWEVER CAUSED
   -- AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
   -- OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF
   -- THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH
   -- DAMAGE.
   --
   --


   -- Indicates the BI/BU/BD Trigger needs to run the TAB Package DML
   -- NOTE: This package must be local to its table.  If this package
   --   makes a remote SQL call to its table, the following variable
   --   will not be set corectly in the remote session
   run_tab  boolean  := TRUE;

   -- Check Constraints for a action_cards Record
   function rec_status
      (id_in  in  NUMBER
      )  return varchar2;

   function get_id
      (action_cards_nk1  in  VARCHAR2  -- actions_nk1
      ,action_cards_nk2  in  VARCHAR2  -- actions_nk2
      ,action_cards_nk3  in  VARCHAR2  -- actions_nk3
      ,action_cards_nk4  in  NUMBER  -- actions_nk4
      ,action_cards_nk5  in  VARCHAR2  -- cards_nk1
      ,action_cards_nk6  in  VARCHAR2  -- cards_nk2
      ,action_cards_nk7  in  VARCHAR2  -- cards_nk3
      ) return NUMBER;
   function get_nk
      (id_in  in  NUMBER
      ) return varchar2;

   -- Should be called exclusively by the BI Trigger
   procedure ins_bi_trigger
      (n_id  in out nocopy  NUMBER
      ,n_action_id  in out nocopy  NUMBER
      ,n_card_id  in out nocopy  NUMBER
      );
   -- Can be called from anywhere, except the BI Trigger
   procedure ins
      (n_rec  in out nocopy  action_cards%ROWTYPE
      );

   -- Should be called exclusively by the BU Trigger
   --   or the "upd" procedure below
   -- Note: the OLD values must be provided to check ignore_no_change
   -- Note2:  Select for Update Lock is assumed on old values row
   procedure upd_bu_trigger
      (o_id  in  NUMBER
      ,o_action_id  in  NUMBER
      ,n_action_id  in out nocopy  NUMBER
      ,o_card_id  in  NUMBER
      ,n_card_id  in out nocopy  NUMBER
      ,run_update  out  boolean
      );
   -- Can be called from anywhere, except the BU Trigger
   -- Note: the OLD values must be provided to check ignore_no_change
   procedure upd
      (o_rec  in             action_cards%ROWTYPE
      ,n_rec  in out nocopy  action_cards%ROWTYPE
      );
   -- Can be called from anywhere, except the BU Trigger
   -- Note: the OLD values must be provided to check ignore_no_change
   procedure upd
      (n_rec  in out nocopy  action_cards%ROWTYPE
      );

   -- There is no delete trigger for this table
   procedure del
      (o_id  in  NUMBER
      );

end action_cards_tab;
/
select 'ACTION_CARDS_TAB' as "Package:"
 from  user_errors
 where name  = 'ACTION_CARDS_TAB'
  and  type  = 'PACKAGE'
  and  rownum = 1
/
select '('||line||'/'||position||') '||text as error
 from  user_errors
 where name = 'ACTION_CARDS_TAB'
  and  type = 'PACKAGE'
 order by sequence
/


create package pcard_actions_tab
is

   -- Package Pcard_Actions_Tab
   --    Table functions
   --    (DML and integrity checks)
   --

   -- Application: Clue Notes For Oracle
   -- Generated by DTGen (http://dmstex.com/services/dtgen)
   -- December  16, 2013  11:32:29 AM

   --
   --
   -- © Duane.Dieterich@DMSTEX.com 2013
   --
   -- All Rights Reserved
   --
   -- No part of this software may be reproduced, copied, modified or adapted,
   -- without the prior written consent of the author, unless otherwise
   -- indicated for stand-alone materials.
   --
   -- You may quote extracts from this software with attribution to
   -- Duane.Dieterich@DMSTEX.com
   --
   -- For any other mode of sharing, please contact Duane.Dieterich@DMSTEX.com.
   --
   -- Commercial use and distribution of this software is not allowed without
   -- express and prior written consent of the author.
   --
   -- THE SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
   -- INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY
   -- AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL
   -- THE COPYRIGHT HOLDER OR DMSTEX BUSINESS SOLUTIONS LLC, ITS MEMBERS,
   -- MANAGERS, OR EMPLOYEES BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
   -- SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
   -- TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
   -- PROFITS; CORRUPTION OF DATA, OR BUSINESS INTERRUPTION) HOWEVER CAUSED
   -- AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
   -- OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF
   -- THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH
   -- DAMAGE.
   --
   --


   -- Indicates the BI/BU/BD Trigger needs to run the TAB Package DML
   -- NOTE: This package must be local to its table.  If this package
   --   makes a remote SQL call to its table, the following variable
   --   will not be set corectly in the remote session
   run_tab  boolean  := TRUE;

   -- Check Constraints for a pcard_actions Record
   function rec_status
      (id_in  in  NUMBER
      )  return varchar2;

   function get_id
      (pcard_actions_nk1  in  VARCHAR2  -- cards_nk1
      ,pcard_actions_nk2  in  VARCHAR2  -- cards_nk2
      ,pcard_actions_nk3  in  VARCHAR2  -- cards_nk3
      ,pcard_actions_nk4  in  VARCHAR2  -- disposition
      ,pcard_actions_nk5  in  VARCHAR2  -- players_nk1
      ,pcard_actions_nk6  in  VARCHAR2  -- players_nk2
      ,pcard_actions_nk7  in  VARCHAR2  -- players_nk3
      ,pcard_actions_nk8  in  VARCHAR2  -- actions_nk1
      ,pcard_actions_nk9  in  VARCHAR2  -- actions_nk2
      ,pcard_actions_nk10  in  VARCHAR2  -- actions_nk3
      ,pcard_actions_nk11  in  NUMBER  -- actions_nk4
      ) return NUMBER;
   function get_nk
      (id_in  in  NUMBER
      ) return varchar2;

   -- Should be called exclusively by the BI Trigger
   procedure ins_bi_trigger
      (n_id  in out nocopy  NUMBER
      ,n_card_id  in out nocopy  NUMBER
      ,n_disposition  in out nocopy  VARCHAR2
      ,n_player_id  in out nocopy  NUMBER
      ,n_action_id  in out nocopy  NUMBER
      );
   -- Can be called from anywhere, except the BI Trigger
   procedure ins
      (n_rec  in out nocopy  pcard_actions%ROWTYPE
      );

   -- Should be called exclusively by the BU Trigger
   --   or the "upd" procedure below
   -- Note: the OLD values must be provided to check ignore_no_change
   -- Note2:  Select for Update Lock is assumed on old values row
   procedure upd_bu_trigger
      (o_id  in  NUMBER
      ,o_card_id  in  NUMBER
      ,n_card_id  in out nocopy  NUMBER
      ,o_disposition  in  VARCHAR2
      ,n_disposition  in out nocopy  VARCHAR2
      ,o_player_id  in  NUMBER
      ,n_player_id  in out nocopy  NUMBER
      ,o_action_id  in  NUMBER
      ,n_action_id  in out nocopy  NUMBER
      ,run_update  out  boolean
      );
   -- Can be called from anywhere, except the BU Trigger
   -- Note: the OLD values must be provided to check ignore_no_change
   procedure upd
      (o_rec  in             pcard_actions%ROWTYPE
      ,n_rec  in out nocopy  pcard_actions%ROWTYPE
      );
   -- Can be called from anywhere, except the BU Trigger
   -- Note: the OLD values must be provided to check ignore_no_change
   procedure upd
      (n_rec  in out nocopy  pcard_actions%ROWTYPE
      );

   -- There is no delete trigger for this table
   procedure del
      (o_id  in  NUMBER
      );

end pcard_actions_tab;
/
select 'PCARD_ACTIONS_TAB' as "Package:"
 from  user_errors
 where name  = 'PCARD_ACTIONS_TAB'
  and  type  = 'PACKAGE'
  and  rownum = 1
/
select '('||line||'/'||position||') '||text as error
 from  user_errors
 where name = 'PCARD_ACTIONS_TAB'
  and  type = 'PACKAGE'
 order by sequence
/


create package body users_tab
is

-- Package Body Users_Tab
--    Table functions and integrity checks)

   -- Application: Clue Notes For Oracle
   -- Generated by DTGen (http://dmstex.com/services/dtgen)
   -- December  16, 2013  11:32:29 AM

   --
   --
   -- © Duane.Dieterich@DMSTEX.com 2013
   --
   -- All Rights Reserved
   --
   -- No part of this software may be reproduced, copied, modified or adapted,
   -- without the prior written consent of the author, unless otherwise
   -- indicated for stand-alone materials.
   --
   -- You may quote extracts from this software with attribution to
   -- Duane.Dieterich@DMSTEX.com
   --
   -- For any other mode of sharing, please contact Duane.Dieterich@DMSTEX.com.
   --
   -- Commercial use and distribution of this software is not allowed without
   -- express and prior written consent of the author.
   --
   -- THE SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
   -- INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY
   -- AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL
   -- THE COPYRIGHT HOLDER OR DMSTEX BUSINESS SOLUTIONS LLC, ITS MEMBERS,
   -- MANAGERS, OR EMPLOYEES BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
   -- SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
   -- TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
   -- PROFITS; CORRUPTION OF DATA, OR BUSINESS INTERRUPTION) HOWEVER CAUSED
   -- AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
   -- OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF
   -- THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH
   -- DAMAGE.
   --
   --


----------------------------------------
procedure check_rec
      (id  in  NUMBER
      ,name  in out nocopy  VARCHAR2
      )
is
begin
   -- 1) Set Default Values as Needed
   -- 2) Check for NOT NULL
   if name is null then
      raise_application_error(-20004, 'users_tab.check_rec(): name cannot be null.');
   end if;
   -- 3) Sub-type NULL checks
   -- 4) Compress Spaces, as needed
   -- 5) Custom Data Handling
   -- 6) Fold the case, as needed
   if util.get_fold_strings then
      name := initcap(name);
   else
      if name is not null
      then
         if name != initcap(name) then
            raise_application_error(-20003, 'users_tab.check_rec(): name must be initial case.');
         end if;
      end if;
   end if;
   -- 7) Check for Domain Values
   -- 8) Custom Constraint Checks
   -- These constraints must be written to account for sub-types
   -- 9) Set eff_beg_dtm, if needed
   -- 10) Set aud_beg_usr and aud_beg_dtm
end check_rec;
----------------------------------------
-- Check Constraints for a users Record
function rec_status
      (id_in  in NUMBER
      )  return varchar2
is
   fs_save    boolean  := util.get_fold_strings;
   ud_save    boolean  := util.get_use_defaults;
   old_tab  users%ROWTYPE;
   new_tab  users%ROWTYPE;
begin
   select * into old_tab from users where id = id_in;
   new_tab := old_tab;
   util.set_fold_strings(FALSE);
   util.set_use_defaults(FALSE);
   check_rec (id  =>  new_tab.id
             ,name  =>  new_tab.name
             );
   if not util.is_equal(old_tab.id, new_tab.id) then
      return 'Data Storage Error on id';
   end if;
   if not util.is_equal(old_tab.name, new_tab.name) then
      return 'Data Storage Error on name';
   end if;
   util.set_use_defaults(ud_save);
   util.set_fold_strings(fs_save);
   return 'OK';
exception
   when others then
      util.set_use_defaults(ud_save);
      util.set_fold_strings(fs_save);
      return sqlerrm;
end rec_status;
----------------------------------------
function get_id
      (users_nk1  in  VARCHAR2
      ) return NUMBER
   -- For all the Natural Key Columns, Return an ID
is
   retid  NUMBER(38);
begin
   select id
    into  retid
    from  users  USR
    where USR.name = users_nk1
    ;
   return retid;
exception when no_data_found then return null;
end get_id;
----------------------------------------
function get_nk
      (id_in  in  NUMBER)
   return VARCHAR2
   -- For an ID, return a delimited list of Natural Key Values
is
   rtxt  VARCHAR2(4000);
begin
   select substr(   USR.name
                         ,1 ,4000)
    into  rtxt
    from  users USR
    where USR.id = id_in;
   return rtxt;
exception when no_data_found then return null;
end get_nk;
----------------------------------------
-- Should be called exclusively by the BI Trigger
--   or the "ins" procedure below
procedure ins_bi_trigger
      (n_id  in out nocopy  NUMBER
      ,n_name  in out nocopy  VARCHAR2
      )
is
begin
   -- BI Trigger will have run_tab = TRUE, otherwise FALSE
   -- Set n_id, if needed
   if n_id is null then
      select users_seq.nextval
       into  n_id from dual;
   elsif n_id = 0 then
      raise_application_error(-20019, 'ID of zero is not allowed');
   end if;
   check_rec (id  =>  n_id
             ,name  =>  n_name
             );
end ins_bi_trigger;
----------------------------------------
-- Can be called from anywhere, except the BI Trigger
procedure ins
      (n_rec  in out nocopy  users%ROWTYPE
      )
is
begin
   run_tab := FALSE;
   ins_bi_trigger (n_id  =>  n_rec.id
       ,n_name  =>  n_rec.name
       );
   insert into users
         (id
         ,name
         )
   values
         (n_rec.id
         ,n_rec.name
         );
   run_tab := TRUE;
exception
   when others then
      run_tab := TRUE;
      raise;
end ins;
----------------------------------------
-- Should be called exclusively by the BU Trigger
--   or the "upd" procedure below
-- Note: the OLD values must be provided to check ignore_no_change
-- Note2:  Select for Update Lock is assumed on old values row
procedure upd_bu_trigger
      (o_id  in  NUMBER
      ,o_name  in  VARCHAR2
      ,n_name  in out nocopy  VARCHAR2
      ,run_update  out  boolean
      )
is
begin
   run_update := TRUE;
   -- BU Trigger will have run_tab = TRUE, otherwise FALSE
   if     o_name = n_name
   then
      if util.get_ignore_no_change then
         run_update := FALSE;
         return;
      end if;
      raise_application_error(-20008, 'users_tab.upd(): Must update one of'
            || ' name'
            || '.');
   end if;
   check_rec (id  =>  o_id
             ,name  =>  n_name
             );
end upd_bu_trigger;
----------------------------------------
-- Can be called from anywhere, except the BU Trigger
-- Note: the OLD values must be provided to set new_rec values
procedure upd
      (o_rec  in             users%ROWTYPE
      ,n_rec  in out nocopy  users%ROWTYPE
      )
is
   c_rec    users%ROWTYPE;  -- Current Row Data
   run_upd  boolean;
begin
   if o_rec.id is null then return; end if;
   run_tab := FALSE;
   select * into c_rec from users t1
    where t1.id = o_rec.id FOR UPDATE;
   -- If old and new match, then replace new with current
   --   because there was no original intent to change new
   if o_rec.name = n_rec.name then
      n_rec.name := c_rec.name;
   end if;
   -- Update the new data based on the current data
   upd_bu_trigger (o_id  =>  c_rec.id
      ,o_name  =>  c_rec.name
      ,n_name  =>  n_rec.name
      ,run_update  =>  run_upd
      );
   if run_upd then
      update users
        set  name = n_rec.name
       where id = o_rec.id;
   end if;
   run_tab := TRUE;
exception
   when others then
      run_tab := TRUE;
      raise;
end upd;
----------------------------------------
-- Can be called from anywhere, except the BU Trigger
-- Note: the OLD values must be provided to check ignore_no_change
procedure upd
      (n_rec  in out nocopy  users%ROWTYPE
      )
is
   c_rec    users%ROWTYPE;  -- Current Row Data
   run_upd  boolean;
begin
   if n_rec.id is null then return; end if;
   run_tab := FALSE;
   select * into c_rec from users t1
    where t1.id = n_rec.id FOR UPDATE;
   upd_bu_trigger (o_id  =>  c_rec.id
      ,o_name  =>  c_rec.name
      ,n_name  =>  n_rec.name
      ,run_update  =>  run_upd
      );
   if run_upd then
      update users
        set  name = n_rec.name
       where id = c_rec.id;
   end if;
   run_tab := TRUE;
exception
   when others then
      run_tab := TRUE;
      raise;
end upd;
----------------------------------------
-- There is no delete trigger for this table
----------------------------------------
-- Can be called from anywhere, except the BD Trigger
procedure del
      (o_id  in  NUMBER
      )
is
begin
   -- NOTE: there is no delete trigger for this table
   if o_id is null then return; end if;
   run_tab := FALSE;
   delete from users USR
    where USR.id = o_id;
   run_tab := TRUE;
end del;
----------------------------------------
end users_tab;
/
select 'USERS_TAB' as "Package Body:"
 from  user_errors
 where name  = 'USERS_TAB'
  and  type  = 'PACKAGE BODY'
  and  rownum = 1
/
select '('||line||'/'||position||') '||text as error
 from  user_errors
 where name = 'USERS_TAB'
  and  type = 'PACKAGE BODY'
 order by sequence
/


create package body card_types_tab
is

-- Package Body Card_Types_Tab
--    Table functions and integrity checks)

   -- Application: Clue Notes For Oracle
   -- Generated by DTGen (http://dmstex.com/services/dtgen)
   -- December  16, 2013  11:32:29 AM

   --
   --
   -- © Duane.Dieterich@DMSTEX.com 2013
   --
   -- All Rights Reserved
   --
   -- No part of this software may be reproduced, copied, modified or adapted,
   -- without the prior written consent of the author, unless otherwise
   -- indicated for stand-alone materials.
   --
   -- You may quote extracts from this software with attribution to
   -- Duane.Dieterich@DMSTEX.com
   --
   -- For any other mode of sharing, please contact Duane.Dieterich@DMSTEX.com.
   --
   -- Commercial use and distribution of this software is not allowed without
   -- express and prior written consent of the author.
   --
   -- THE SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
   -- INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY
   -- AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL
   -- THE COPYRIGHT HOLDER OR DMSTEX BUSINESS SOLUTIONS LLC, ITS MEMBERS,
   -- MANAGERS, OR EMPLOYEES BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
   -- SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
   -- TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
   -- PROFITS; CORRUPTION OF DATA, OR BUSINESS INTERRUPTION) HOWEVER CAUSED
   -- AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
   -- OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF
   -- THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH
   -- DAMAGE.
   --
   --


----------------------------------------
procedure check_rec
      (id  in  NUMBER
      ,user_id  in out nocopy  NUMBER
      ,name  in out nocopy  VARCHAR2
      ,sort_ord  in out nocopy  NUMBER
      )
is
begin
   -- 1) Set Default Values as Needed
   -- 2) Check for NOT NULL
   if user_id is null then
      raise_application_error(-20004, 'card_types_tab.check_rec(): user_id cannot be null.');
   end if;
   if name is null then
      raise_application_error(-20004, 'card_types_tab.check_rec(): name cannot be null.');
   end if;
   -- 3) Sub-type NULL checks
   -- 4) Compress Spaces, as needed
   -- 5) Custom Data Handling
   -- 6) Fold the case, as needed
   if util.get_fold_strings then
      name := upper(name);
   else
      if name is not null
      then
         if name != upper(name) then
            raise_application_error(-20003, 'card_types_tab.check_rec(): name must be upper case.');
         end if;
      end if;
   end if;
   -- 7) Check for Domain Values
   -- 8) Custom Constraint Checks
   -- These constraints must be written to account for sub-types
   -- 9) Set eff_beg_dtm, if needed
   -- 10) Set aud_beg_usr and aud_beg_dtm
end check_rec;
----------------------------------------
-- Check Constraints for a card_types Record
function rec_status
      (id_in  in NUMBER
      )  return varchar2
is
   fs_save    boolean  := util.get_fold_strings;
   ud_save    boolean  := util.get_use_defaults;
   old_tab  card_types%ROWTYPE;
   new_tab  card_types%ROWTYPE;
begin
   select * into old_tab from card_types where id = id_in;
   new_tab := old_tab;
   util.set_fold_strings(FALSE);
   util.set_use_defaults(FALSE);
   check_rec (id  =>  new_tab.id
             ,user_id  =>  new_tab.user_id
             ,name  =>  new_tab.name
             ,sort_ord  =>  new_tab.sort_ord
             );
   if not util.is_equal(old_tab.id, new_tab.id) then
      return 'Data Storage Error on id';
   end if;
   if not util.is_equal(old_tab.user_id, new_tab.user_id) then
      return 'Data Storage Error on user_id';
   end if;
   if not util.is_equal(old_tab.name, new_tab.name) then
      return 'Data Storage Error on name';
   end if;
   if not util.is_equal(old_tab.sort_ord, new_tab.sort_ord) then
      return 'Data Storage Error on sort_ord';
   end if;
   util.set_use_defaults(ud_save);
   util.set_fold_strings(fs_save);
   return 'OK';
exception
   when others then
      util.set_use_defaults(ud_save);
      util.set_fold_strings(fs_save);
      return sqlerrm;
end rec_status;
----------------------------------------
function get_id
      (card_types_nk1  in  VARCHAR2
      ,card_types_nk2  in  VARCHAR2
      ) return NUMBER
   -- For all the Natural Key Columns, Return an ID
is
   retid  NUMBER(38);
begin
   select id
    into  retid
    from  card_types  CTYPE
    where CTYPE.user_id = users_tab.get_id
             (card_types_nk1
             )
     and  CTYPE.name = card_types_nk2
    ;
   return retid;
exception when no_data_found then return null;
end get_id;
----------------------------------------
function get_nk
      (id_in  in  NUMBER)
   return VARCHAR2
   -- For an ID, return a delimited list of Natural Key Values
is
   rtxt  VARCHAR2(4000);
begin
   select substr(   users_tab.get_nk(CTYPE.user_id)
    || util.nk_sep || CTYPE.name
                         ,1 ,4000)
    into  rtxt
    from  card_types CTYPE
    where CTYPE.id = id_in;
   return rtxt;
exception when no_data_found then return null;
end get_nk;
----------------------------------------
-- Should be called exclusively by the BI Trigger
--   or the "ins" procedure below
procedure ins_bi_trigger
      (n_id  in out nocopy  NUMBER
      ,n_user_id  in out nocopy  NUMBER
      ,n_name  in out nocopy  VARCHAR2
      ,n_sort_ord  in out nocopy  NUMBER
      )
is
begin
   -- BI Trigger will have run_tab = TRUE, otherwise FALSE
   -- Set n_id, if needed
   if n_id is null then
      select card_types_seq.nextval
       into  n_id from dual;
   elsif n_id = 0 then
      raise_application_error(-20019, 'ID of zero is not allowed');
   end if;
   check_rec (id  =>  n_id
             ,user_id  =>  n_user_id
             ,name  =>  n_name
             ,sort_ord  =>  n_sort_ord
             );
end ins_bi_trigger;
----------------------------------------
-- Can be called from anywhere, except the BI Trigger
procedure ins
      (n_rec  in out nocopy  card_types%ROWTYPE
      )
is
begin
   run_tab := FALSE;
   ins_bi_trigger (n_id  =>  n_rec.id
       ,n_user_id  =>  n_rec.user_id
       ,n_name  =>  n_rec.name
       ,n_sort_ord  =>  n_rec.sort_ord
       );
   insert into card_types
         (id
         ,user_id
         ,name
         ,sort_ord
         )
   values
         (n_rec.id
         ,n_rec.user_id
         ,n_rec.name
         ,n_rec.sort_ord
         );
   run_tab := TRUE;
exception
   when others then
      run_tab := TRUE;
      raise;
end ins;
----------------------------------------
-- Should be called exclusively by the BU Trigger
--   or the "upd" procedure below
-- Note: the OLD values must be provided to check ignore_no_change
-- Note2:  Select for Update Lock is assumed on old values row
procedure upd_bu_trigger
      (o_id  in  NUMBER
      ,o_user_id  in  NUMBER
      ,n_user_id  in out nocopy  NUMBER
      ,o_name  in  VARCHAR2
      ,n_name  in out nocopy  VARCHAR2
      ,o_sort_ord  in  NUMBER
      ,n_sort_ord  in out nocopy  NUMBER
      ,run_update  out  boolean
      )
is
begin
   run_update := TRUE;
   -- BU Trigger will have run_tab = TRUE, otherwise FALSE
   if     o_user_id = n_user_id
     and  o_name = n_name
     and  util.is_equal(o_sort_ord, n_sort_ord)
   then
      if util.get_ignore_no_change then
         run_update := FALSE;
         return;
      end if;
      raise_application_error(-20008, 'card_types_tab.upd(): Must update one of'
            || ' user_id'
            || ', name'
            || ', sort_ord'
            || '.');
   end if;
   check_rec (id  =>  o_id
             ,user_id  =>  n_user_id
             ,name  =>  n_name
             ,sort_ord  =>  n_sort_ord
             );
end upd_bu_trigger;
----------------------------------------
-- Can be called from anywhere, except the BU Trigger
-- Note: the OLD values must be provided to set new_rec values
procedure upd
      (o_rec  in             card_types%ROWTYPE
      ,n_rec  in out nocopy  card_types%ROWTYPE
      )
is
   c_rec    card_types%ROWTYPE;  -- Current Row Data
   run_upd  boolean;
begin
   if o_rec.id is null then return; end if;
   run_tab := FALSE;
   select * into c_rec from card_types t1
    where t1.id = o_rec.id FOR UPDATE;
   -- If old and new match, then replace new with current
   --   because there was no original intent to change new
   if o_rec.user_id = n_rec.user_id then
      n_rec.user_id := c_rec.user_id;
   end if;
   if o_rec.name = n_rec.name then
      n_rec.name := c_rec.name;
   end if;
   if util.is_equal(o_rec.sort_ord, n_rec.sort_ord) then
      n_rec.sort_ord := c_rec.sort_ord;
   end if;
   -- Update the new data based on the current data
   upd_bu_trigger (o_id  =>  c_rec.id
      ,o_user_id  =>  c_rec.user_id
      ,n_user_id  =>  n_rec.user_id
      ,o_name  =>  c_rec.name
      ,n_name  =>  n_rec.name
      ,o_sort_ord  =>  c_rec.sort_ord
      ,n_sort_ord  =>  n_rec.sort_ord
      ,run_update  =>  run_upd
      );
   if run_upd then
      update card_types
        set  user_id = n_rec.user_id
            ,name = n_rec.name
            ,sort_ord = n_rec.sort_ord
       where id = o_rec.id;
   end if;
   run_tab := TRUE;
exception
   when others then
      run_tab := TRUE;
      raise;
end upd;
----------------------------------------
-- Can be called from anywhere, except the BU Trigger
-- Note: the OLD values must be provided to check ignore_no_change
procedure upd
      (n_rec  in out nocopy  card_types%ROWTYPE
      )
is
   c_rec    card_types%ROWTYPE;  -- Current Row Data
   run_upd  boolean;
begin
   if n_rec.id is null then return; end if;
   run_tab := FALSE;
   select * into c_rec from card_types t1
    where t1.id = n_rec.id FOR UPDATE;
   upd_bu_trigger (o_id  =>  c_rec.id
      ,o_user_id  =>  c_rec.user_id
      ,n_user_id  =>  n_rec.user_id
      ,o_name  =>  c_rec.name
      ,n_name  =>  n_rec.name
      ,o_sort_ord  =>  c_rec.sort_ord
      ,n_sort_ord  =>  n_rec.sort_ord
      ,run_update  =>  run_upd
      );
   if run_upd then
      update card_types
        set  user_id = n_rec.user_id
            ,name = n_rec.name
            ,sort_ord = n_rec.sort_ord
       where id = c_rec.id;
   end if;
   run_tab := TRUE;
exception
   when others then
      run_tab := TRUE;
      raise;
end upd;
----------------------------------------
-- There is no delete trigger for this table
----------------------------------------
-- Can be called from anywhere, except the BD Trigger
procedure del
      (o_id  in  NUMBER
      )
is
begin
   -- NOTE: there is no delete trigger for this table
   if o_id is null then return; end if;
   run_tab := FALSE;
   delete from card_types CTYPE
    where CTYPE.id = o_id;
   run_tab := TRUE;
end del;
----------------------------------------
end card_types_tab;
/
select 'CARD_TYPES_TAB' as "Package Body:"
 from  user_errors
 where name  = 'CARD_TYPES_TAB'
  and  type  = 'PACKAGE BODY'
  and  rownum = 1
/
select '('||line||'/'||position||') '||text as error
 from  user_errors
 where name = 'CARD_TYPES_TAB'
  and  type = 'PACKAGE BODY'
 order by sequence
/


create package body games_tab
is

-- Package Body Games_Tab
--    Table functions and integrity checks)

   -- Application: Clue Notes For Oracle
   -- Generated by DTGen (http://dmstex.com/services/dtgen)
   -- December  16, 2013  11:32:29 AM

   --
   --
   -- © Duane.Dieterich@DMSTEX.com 2013
   --
   -- All Rights Reserved
   --
   -- No part of this software may be reproduced, copied, modified or adapted,
   -- without the prior written consent of the author, unless otherwise
   -- indicated for stand-alone materials.
   --
   -- You may quote extracts from this software with attribution to
   -- Duane.Dieterich@DMSTEX.com
   --
   -- For any other mode of sharing, please contact Duane.Dieterich@DMSTEX.com.
   --
   -- Commercial use and distribution of this software is not allowed without
   -- express and prior written consent of the author.
   --
   -- THE SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
   -- INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY
   -- AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL
   -- THE COPYRIGHT HOLDER OR DMSTEX BUSINESS SOLUTIONS LLC, ITS MEMBERS,
   -- MANAGERS, OR EMPLOYEES BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
   -- SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
   -- TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
   -- PROFITS; CORRUPTION OF DATA, OR BUSINESS INTERRUPTION) HOWEVER CAUSED
   -- AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
   -- OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF
   -- THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH
   -- DAMAGE.
   --
   --


----------------------------------------
procedure check_rec
      (id  in  NUMBER
      ,user_id  in out nocopy  NUMBER
      ,name  in out nocopy  VARCHAR2
      ,last_act_num  in out nocopy  NUMBER
      ,completed  in out nocopy  VARCHAR2
      ,hide_undo  in out nocopy  VARCHAR2
      ,hide_accuse  in out nocopy  VARCHAR2
      ,hide_missing  in out nocopy  VARCHAR2
      ,hide_my_sugg  in out nocopy  VARCHAR2
      ,hide_pcards  in out nocopy  VARCHAR2
      ,hide_sugg_hist  in out nocopy  VARCHAR2
      )
is
begin
   -- 1) Set Default Values as Needed
   if util.get_use_defaults then
      if last_act_num is null
      then
         last_act_num := 3;
      end if;
   end if;
   -- 2) Check for NOT NULL
   if user_id is null then
      raise_application_error(-20004, 'games_tab.check_rec(): user_id cannot be null.');
   end if;
   if name is null then
      raise_application_error(-20004, 'games_tab.check_rec(): name cannot be null.');
   end if;
   if last_act_num is null then
      raise_application_error(-20004, 'games_tab.check_rec(): last_act_num cannot be null.');
   end if;
   -- 3) Sub-type NULL checks
   -- 4) Compress Spaces, as needed
   -- 5) Custom Data Handling
   -- 6) Fold the case, as needed
   if util.get_fold_strings then
      name := initcap(name);
      completed := upper(completed);
      hide_undo := upper(hide_undo);
      hide_accuse := upper(hide_accuse);
      hide_missing := upper(hide_missing);
      hide_my_sugg := upper(hide_my_sugg);
      hide_pcards := upper(hide_pcards);
      hide_sugg_hist := upper(hide_sugg_hist);
   else
      if name is not null
      then
         if name != initcap(name) then
            raise_application_error(-20003, 'games_tab.check_rec(): name must be initial case.');
         end if;
      end if;
      if completed is not null
      then
         if completed != upper(completed) then
            raise_application_error(-20003, 'games_tab.check_rec(): completed must be upper case.');
         end if;
      end if;
      if hide_undo is not null
      then
         if hide_undo != upper(hide_undo) then
            raise_application_error(-20003, 'games_tab.check_rec(): hide_undo must be upper case.');
         end if;
      end if;
      if hide_accuse is not null
      then
         if hide_accuse != upper(hide_accuse) then
            raise_application_error(-20003, 'games_tab.check_rec(): hide_accuse must be upper case.');
         end if;
      end if;
      if hide_missing is not null
      then
         if hide_missing != upper(hide_missing) then
            raise_application_error(-20003, 'games_tab.check_rec(): hide_missing must be upper case.');
         end if;
      end if;
      if hide_my_sugg is not null
      then
         if hide_my_sugg != upper(hide_my_sugg) then
            raise_application_error(-20003, 'games_tab.check_rec(): hide_my_sugg must be upper case.');
         end if;
      end if;
      if hide_pcards is not null
      then
         if hide_pcards != upper(hide_pcards) then
            raise_application_error(-20003, 'games_tab.check_rec(): hide_pcards must be upper case.');
         end if;
      end if;
      if hide_sugg_hist is not null
      then
         if hide_sugg_hist != upper(hide_sugg_hist) then
            raise_application_error(-20003, 'games_tab.check_rec(): hide_sugg_hist must be upper case.');
         end if;
      end if;
   end if;
   -- 7) Check for Domain Values
   if completed is not null
      and not Flagged_dom.includes(completed)
   then
      raise_application_error(-20005, 'games_tab.check_rec(): completed must be one of ("X").');
   end if;
   if hide_undo is not null
      and not Flagged_dom.includes(hide_undo)
   then
      raise_application_error(-20005, 'games_tab.check_rec(): hide_undo must be one of ("X").');
   end if;
   if hide_accuse is not null
      and not Flagged_dom.includes(hide_accuse)
   then
      raise_application_error(-20005, 'games_tab.check_rec(): hide_accuse must be one of ("X").');
   end if;
   if hide_missing is not null
      and not Flagged_dom.includes(hide_missing)
   then
      raise_application_error(-20005, 'games_tab.check_rec(): hide_missing must be one of ("X").');
   end if;
   if hide_my_sugg is not null
      and not Flagged_dom.includes(hide_my_sugg)
   then
      raise_application_error(-20005, 'games_tab.check_rec(): hide_my_sugg must be one of ("X").');
   end if;
   if hide_pcards is not null
      and not Flagged_dom.includes(hide_pcards)
   then
      raise_application_error(-20005, 'games_tab.check_rec(): hide_pcards must be one of ("X").');
   end if;
   if hide_sugg_hist is not null
      and not Flagged_dom.includes(hide_sugg_hist)
   then
      raise_application_error(-20005, 'games_tab.check_rec(): hide_sugg_hist must be one of ("X").');
   end if;
   -- 8) Custom Constraint Checks
   -- These constraints must be written to account for sub-types
   if not (last_act_num >= 0)
   then
      raise_application_error(-20006, 'games_tab.check_rec(): Number of Last Actions to Display must be greater than or equal to zero');
   end if;
   -- 9) Set eff_beg_dtm, if needed
   -- 10) Set aud_beg_usr and aud_beg_dtm
end check_rec;
----------------------------------------
-- Check Constraints for a games Record
function rec_status
      (id_in  in NUMBER
      )  return varchar2
is
   fs_save    boolean  := util.get_fold_strings;
   ud_save    boolean  := util.get_use_defaults;
   old_tab  games%ROWTYPE;
   new_tab  games%ROWTYPE;
begin
   select * into old_tab from games where id = id_in;
   new_tab := old_tab;
   util.set_fold_strings(FALSE);
   util.set_use_defaults(FALSE);
   check_rec (id  =>  new_tab.id
             ,user_id  =>  new_tab.user_id
             ,name  =>  new_tab.name
             ,last_act_num  =>  new_tab.last_act_num
             ,completed  =>  new_tab.completed
             ,hide_undo  =>  new_tab.hide_undo
             ,hide_accuse  =>  new_tab.hide_accuse
             ,hide_missing  =>  new_tab.hide_missing
             ,hide_my_sugg  =>  new_tab.hide_my_sugg
             ,hide_pcards  =>  new_tab.hide_pcards
             ,hide_sugg_hist  =>  new_tab.hide_sugg_hist
             );
   if not util.is_equal(old_tab.id, new_tab.id) then
      return 'Data Storage Error on id';
   end if;
   if not util.is_equal(old_tab.user_id, new_tab.user_id) then
      return 'Data Storage Error on user_id';
   end if;
   if not util.is_equal(old_tab.name, new_tab.name) then
      return 'Data Storage Error on name';
   end if;
   if not util.is_equal(old_tab.last_act_num, new_tab.last_act_num) then
      return 'Data Storage Error on last_act_num';
   end if;
   if not util.is_equal(old_tab.completed, new_tab.completed) then
      return 'Data Storage Error on completed';
   end if;
   if not util.is_equal(old_tab.hide_undo, new_tab.hide_undo) then
      return 'Data Storage Error on hide_undo';
   end if;
   if not util.is_equal(old_tab.hide_accuse, new_tab.hide_accuse) then
      return 'Data Storage Error on hide_accuse';
   end if;
   if not util.is_equal(old_tab.hide_missing, new_tab.hide_missing) then
      return 'Data Storage Error on hide_missing';
   end if;
   if not util.is_equal(old_tab.hide_my_sugg, new_tab.hide_my_sugg) then
      return 'Data Storage Error on hide_my_sugg';
   end if;
   if not util.is_equal(old_tab.hide_pcards, new_tab.hide_pcards) then
      return 'Data Storage Error on hide_pcards';
   end if;
   if not util.is_equal(old_tab.hide_sugg_hist, new_tab.hide_sugg_hist) then
      return 'Data Storage Error on hide_sugg_hist';
   end if;
   util.set_use_defaults(ud_save);
   util.set_fold_strings(fs_save);
   return 'OK';
exception
   when others then
      util.set_use_defaults(ud_save);
      util.set_fold_strings(fs_save);
      return sqlerrm;
end rec_status;
----------------------------------------
function get_id
      (games_nk1  in  VARCHAR2
      ,games_nk2  in  VARCHAR2
      ) return NUMBER
   -- For all the Natural Key Columns, Return an ID
is
   retid  NUMBER(38);
begin
   select id
    into  retid
    from  games  GAM
    where GAM.user_id = users_tab.get_id
             (games_nk1
             )
     and  GAM.name = games_nk2
    ;
   return retid;
exception when no_data_found then return null;
end get_id;
----------------------------------------
function get_nk
      (id_in  in  NUMBER)
   return VARCHAR2
   -- For an ID, return a delimited list of Natural Key Values
is
   rtxt  VARCHAR2(4000);
begin
   select substr(   users_tab.get_nk(GAM.user_id)
    || util.nk_sep || GAM.name
                         ,1 ,4000)
    into  rtxt
    from  games GAM
    where GAM.id = id_in;
   return rtxt;
exception when no_data_found then return null;
end get_nk;
----------------------------------------
-- Should be called exclusively by the BI Trigger
--   or the "ins" procedure below
procedure ins_bi_trigger
      (n_id  in out nocopy  NUMBER
      ,n_user_id  in out nocopy  NUMBER
      ,n_name  in out nocopy  VARCHAR2
      ,n_last_act_num  in out nocopy  NUMBER
      ,n_completed  in out nocopy  VARCHAR2
      ,n_hide_undo  in out nocopy  VARCHAR2
      ,n_hide_accuse  in out nocopy  VARCHAR2
      ,n_hide_missing  in out nocopy  VARCHAR2
      ,n_hide_my_sugg  in out nocopy  VARCHAR2
      ,n_hide_pcards  in out nocopy  VARCHAR2
      ,n_hide_sugg_hist  in out nocopy  VARCHAR2
      )
is
begin
   -- BI Trigger will have run_tab = TRUE, otherwise FALSE
   -- Set n_id, if needed
   if n_id is null then
      select games_seq.nextval
       into  n_id from dual;
   elsif n_id = 0 then
      raise_application_error(-20019, 'ID of zero is not allowed');
   end if;
   check_rec (id  =>  n_id
             ,user_id  =>  n_user_id
             ,name  =>  n_name
             ,last_act_num  =>  n_last_act_num
             ,completed  =>  n_completed
             ,hide_undo  =>  n_hide_undo
             ,hide_accuse  =>  n_hide_accuse
             ,hide_missing  =>  n_hide_missing
             ,hide_my_sugg  =>  n_hide_my_sugg
             ,hide_pcards  =>  n_hide_pcards
             ,hide_sugg_hist  =>  n_hide_sugg_hist
             );
end ins_bi_trigger;
----------------------------------------
-- Can be called from anywhere, except the BI Trigger
procedure ins
      (n_rec  in out nocopy  games%ROWTYPE
      )
is
begin
   run_tab := FALSE;
   ins_bi_trigger (n_id  =>  n_rec.id
       ,n_user_id  =>  n_rec.user_id
       ,n_name  =>  n_rec.name
       ,n_last_act_num  =>  n_rec.last_act_num
       ,n_completed  =>  n_rec.completed
       ,n_hide_undo  =>  n_rec.hide_undo
       ,n_hide_accuse  =>  n_rec.hide_accuse
       ,n_hide_missing  =>  n_rec.hide_missing
       ,n_hide_my_sugg  =>  n_rec.hide_my_sugg
       ,n_hide_pcards  =>  n_rec.hide_pcards
       ,n_hide_sugg_hist  =>  n_rec.hide_sugg_hist
       );
   insert into games
         (id
         ,user_id
         ,name
         ,last_act_num
         ,completed
         ,hide_undo
         ,hide_accuse
         ,hide_missing
         ,hide_my_sugg
         ,hide_pcards
         ,hide_sugg_hist
         )
   values
         (n_rec.id
         ,n_rec.user_id
         ,n_rec.name
         ,n_rec.last_act_num
         ,n_rec.completed
         ,n_rec.hide_undo
         ,n_rec.hide_accuse
         ,n_rec.hide_missing
         ,n_rec.hide_my_sugg
         ,n_rec.hide_pcards
         ,n_rec.hide_sugg_hist
         );
   run_tab := TRUE;
exception
   when others then
      run_tab := TRUE;
      raise;
end ins;
----------------------------------------
-- Should be called exclusively by the BU Trigger
--   or the "upd" procedure below
-- Note: the OLD values must be provided to check ignore_no_change
-- Note2:  Select for Update Lock is assumed on old values row
procedure upd_bu_trigger
      (o_id  in  NUMBER
      ,o_user_id  in  NUMBER
      ,n_user_id  in out nocopy  NUMBER
      ,o_name  in  VARCHAR2
      ,n_name  in out nocopy  VARCHAR2
      ,o_last_act_num  in  NUMBER
      ,n_last_act_num  in out nocopy  NUMBER
      ,o_completed  in  VARCHAR2
      ,n_completed  in out nocopy  VARCHAR2
      ,o_hide_undo  in  VARCHAR2
      ,n_hide_undo  in out nocopy  VARCHAR2
      ,o_hide_accuse  in  VARCHAR2
      ,n_hide_accuse  in out nocopy  VARCHAR2
      ,o_hide_missing  in  VARCHAR2
      ,n_hide_missing  in out nocopy  VARCHAR2
      ,o_hide_my_sugg  in  VARCHAR2
      ,n_hide_my_sugg  in out nocopy  VARCHAR2
      ,o_hide_pcards  in  VARCHAR2
      ,n_hide_pcards  in out nocopy  VARCHAR2
      ,o_hide_sugg_hist  in  VARCHAR2
      ,n_hide_sugg_hist  in out nocopy  VARCHAR2
      ,run_update  out  boolean
      )
is
begin
   run_update := TRUE;
   -- BU Trigger will have run_tab = TRUE, otherwise FALSE
   if     o_user_id = n_user_id
     and  o_name = n_name
     and  o_last_act_num = n_last_act_num
     and  util.is_equal(o_completed, n_completed)
     and  util.is_equal(o_hide_undo, n_hide_undo)
     and  util.is_equal(o_hide_accuse, n_hide_accuse)
     and  util.is_equal(o_hide_missing, n_hide_missing)
     and  util.is_equal(o_hide_my_sugg, n_hide_my_sugg)
     and  util.is_equal(o_hide_pcards, n_hide_pcards)
     and  util.is_equal(o_hide_sugg_hist, n_hide_sugg_hist)
   then
      if util.get_ignore_no_change then
         run_update := FALSE;
         return;
      end if;
      raise_application_error(-20008, 'games_tab.upd(): Must update one of'
            || ' user_id'
            || ', name'
            || ', last_act_num'
            || ', completed'
            || ', hide_undo'
            || ', hide_accuse'
            || ', hide_missing'
            || ', hide_my_sugg'
            || ', hide_pcards'
            || ', hide_sugg_hist'
            || '.');
   end if;
   check_rec (id  =>  o_id
             ,user_id  =>  n_user_id
             ,name  =>  n_name
             ,last_act_num  =>  n_last_act_num
             ,completed  =>  n_completed
             ,hide_undo  =>  n_hide_undo
             ,hide_accuse  =>  n_hide_accuse
             ,hide_missing  =>  n_hide_missing
             ,hide_my_sugg  =>  n_hide_my_sugg
             ,hide_pcards  =>  n_hide_pcards
             ,hide_sugg_hist  =>  n_hide_sugg_hist
             );
end upd_bu_trigger;
----------------------------------------
-- Can be called from anywhere, except the BU Trigger
-- Note: the OLD values must be provided to set new_rec values
procedure upd
      (o_rec  in             games%ROWTYPE
      ,n_rec  in out nocopy  games%ROWTYPE
      )
is
   c_rec    games%ROWTYPE;  -- Current Row Data
   run_upd  boolean;
begin
   if o_rec.id is null then return; end if;
   run_tab := FALSE;
   select * into c_rec from games t1
    where t1.id = o_rec.id FOR UPDATE;
   -- If old and new match, then replace new with current
   --   because there was no original intent to change new
   if o_rec.user_id = n_rec.user_id then
      n_rec.user_id := c_rec.user_id;
   end if;
   if o_rec.name = n_rec.name then
      n_rec.name := c_rec.name;
   end if;
   if o_rec.last_act_num = n_rec.last_act_num then
      n_rec.last_act_num := c_rec.last_act_num;
   end if;
   if util.is_equal(o_rec.completed, n_rec.completed) then
      n_rec.completed := c_rec.completed;
   end if;
   if util.is_equal(o_rec.hide_undo, n_rec.hide_undo) then
      n_rec.hide_undo := c_rec.hide_undo;
   end if;
   if util.is_equal(o_rec.hide_accuse, n_rec.hide_accuse) then
      n_rec.hide_accuse := c_rec.hide_accuse;
   end if;
   if util.is_equal(o_rec.hide_missing, n_rec.hide_missing) then
      n_rec.hide_missing := c_rec.hide_missing;
   end if;
   if util.is_equal(o_rec.hide_my_sugg, n_rec.hide_my_sugg) then
      n_rec.hide_my_sugg := c_rec.hide_my_sugg;
   end if;
   if util.is_equal(o_rec.hide_pcards, n_rec.hide_pcards) then
      n_rec.hide_pcards := c_rec.hide_pcards;
   end if;
   if util.is_equal(o_rec.hide_sugg_hist, n_rec.hide_sugg_hist) then
      n_rec.hide_sugg_hist := c_rec.hide_sugg_hist;
   end if;
   -- Update the new data based on the current data
   upd_bu_trigger (o_id  =>  c_rec.id
      ,o_user_id  =>  c_rec.user_id
      ,n_user_id  =>  n_rec.user_id
      ,o_name  =>  c_rec.name
      ,n_name  =>  n_rec.name
      ,o_last_act_num  =>  c_rec.last_act_num
      ,n_last_act_num  =>  n_rec.last_act_num
      ,o_completed  =>  c_rec.completed
      ,n_completed  =>  n_rec.completed
      ,o_hide_undo  =>  c_rec.hide_undo
      ,n_hide_undo  =>  n_rec.hide_undo
      ,o_hide_accuse  =>  c_rec.hide_accuse
      ,n_hide_accuse  =>  n_rec.hide_accuse
      ,o_hide_missing  =>  c_rec.hide_missing
      ,n_hide_missing  =>  n_rec.hide_missing
      ,o_hide_my_sugg  =>  c_rec.hide_my_sugg
      ,n_hide_my_sugg  =>  n_rec.hide_my_sugg
      ,o_hide_pcards  =>  c_rec.hide_pcards
      ,n_hide_pcards  =>  n_rec.hide_pcards
      ,o_hide_sugg_hist  =>  c_rec.hide_sugg_hist
      ,n_hide_sugg_hist  =>  n_rec.hide_sugg_hist
      ,run_update  =>  run_upd
      );
   if run_upd then
      update games
        set  user_id = n_rec.user_id
            ,name = n_rec.name
            ,last_act_num = n_rec.last_act_num
            ,completed = n_rec.completed
            ,hide_undo = n_rec.hide_undo
            ,hide_accuse = n_rec.hide_accuse
            ,hide_missing = n_rec.hide_missing
            ,hide_my_sugg = n_rec.hide_my_sugg
            ,hide_pcards = n_rec.hide_pcards
            ,hide_sugg_hist = n_rec.hide_sugg_hist
       where id = o_rec.id;
   end if;
   run_tab := TRUE;
exception
   when others then
      run_tab := TRUE;
      raise;
end upd;
----------------------------------------
-- Can be called from anywhere, except the BU Trigger
-- Note: the OLD values must be provided to check ignore_no_change
procedure upd
      (n_rec  in out nocopy  games%ROWTYPE
      )
is
   c_rec    games%ROWTYPE;  -- Current Row Data
   run_upd  boolean;
begin
   if n_rec.id is null then return; end if;
   run_tab := FALSE;
   select * into c_rec from games t1
    where t1.id = n_rec.id FOR UPDATE;
   upd_bu_trigger (o_id  =>  c_rec.id
      ,o_user_id  =>  c_rec.user_id
      ,n_user_id  =>  n_rec.user_id
      ,o_name  =>  c_rec.name
      ,n_name  =>  n_rec.name
      ,o_last_act_num  =>  c_rec.last_act_num
      ,n_last_act_num  =>  n_rec.last_act_num
      ,o_completed  =>  c_rec.completed
      ,n_completed  =>  n_rec.completed
      ,o_hide_undo  =>  c_rec.hide_undo
      ,n_hide_undo  =>  n_rec.hide_undo
      ,o_hide_accuse  =>  c_rec.hide_accuse
      ,n_hide_accuse  =>  n_rec.hide_accuse
      ,o_hide_missing  =>  c_rec.hide_missing
      ,n_hide_missing  =>  n_rec.hide_missing
      ,o_hide_my_sugg  =>  c_rec.hide_my_sugg
      ,n_hide_my_sugg  =>  n_rec.hide_my_sugg
      ,o_hide_pcards  =>  c_rec.hide_pcards
      ,n_hide_pcards  =>  n_rec.hide_pcards
      ,o_hide_sugg_hist  =>  c_rec.hide_sugg_hist
      ,n_hide_sugg_hist  =>  n_rec.hide_sugg_hist
      ,run_update  =>  run_upd
      );
   if run_upd then
      update games
        set  user_id = n_rec.user_id
            ,name = n_rec.name
            ,last_act_num = n_rec.last_act_num
            ,completed = n_rec.completed
            ,hide_undo = n_rec.hide_undo
            ,hide_accuse = n_rec.hide_accuse
            ,hide_missing = n_rec.hide_missing
            ,hide_my_sugg = n_rec.hide_my_sugg
            ,hide_pcards = n_rec.hide_pcards
            ,hide_sugg_hist = n_rec.hide_sugg_hist
       where id = c_rec.id;
   end if;
   run_tab := TRUE;
exception
   when others then
      run_tab := TRUE;
      raise;
end upd;
----------------------------------------
-- There is no delete trigger for this table
----------------------------------------
-- Can be called from anywhere, except the BD Trigger
procedure del
      (o_id  in  NUMBER
      )
is
begin
   -- NOTE: there is no delete trigger for this table
   if o_id is null then return; end if;
   run_tab := FALSE;
   delete from games GAM
    where GAM.id = o_id;
   run_tab := TRUE;
end del;
----------------------------------------
end games_tab;
/
select 'GAMES_TAB' as "Package Body:"
 from  user_errors
 where name  = 'GAMES_TAB'
  and  type  = 'PACKAGE BODY'
  and  rownum = 1
/
select '('||line||'/'||position||') '||text as error
 from  user_errors
 where name = 'GAMES_TAB'
  and  type = 'PACKAGE BODY'
 order by sequence
/


create package body players_tab
is

-- Package Body Players_Tab
--    Table functions and integrity checks)

   -- Application: Clue Notes For Oracle
   -- Generated by DTGen (http://dmstex.com/services/dtgen)
   -- December  16, 2013  11:32:29 AM

   --
   --
   -- © Duane.Dieterich@DMSTEX.com 2013
   --
   -- All Rights Reserved
   --
   -- No part of this software may be reproduced, copied, modified or adapted,
   -- without the prior written consent of the author, unless otherwise
   -- indicated for stand-alone materials.
   --
   -- You may quote extracts from this software with attribution to
   -- Duane.Dieterich@DMSTEX.com
   --
   -- For any other mode of sharing, please contact Duane.Dieterich@DMSTEX.com.
   --
   -- Commercial use and distribution of this software is not allowed without
   -- express and prior written consent of the author.
   --
   -- THE SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
   -- INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY
   -- AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL
   -- THE COPYRIGHT HOLDER OR DMSTEX BUSINESS SOLUTIONS LLC, ITS MEMBERS,
   -- MANAGERS, OR EMPLOYEES BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
   -- SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
   -- TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
   -- PROFITS; CORRUPTION OF DATA, OR BUSINESS INTERRUPTION) HOWEVER CAUSED
   -- AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
   -- OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF
   -- THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH
   -- DAMAGE.
   --
   --


----------------------------------------
procedure check_rec
      (id  in  NUMBER
      ,game_id  in out nocopy  NUMBER
      ,name  in out nocopy  VARCHAR2
      ,seq  in out nocopy  NUMBER
      ,total_cards  in out nocopy  NUMBER
      )
is
begin
   -- 1) Set Default Values as Needed
   -- 2) Check for NOT NULL
   if game_id is null then
      raise_application_error(-20004, 'players_tab.check_rec(): game_id cannot be null.');
   end if;
   if name is null then
      raise_application_error(-20004, 'players_tab.check_rec(): name cannot be null.');
   end if;
   if seq is null then
      raise_application_error(-20004, 'players_tab.check_rec(): seq cannot be null.');
   end if;
   -- 3) Sub-type NULL checks
   -- 4) Compress Spaces, as needed
   -- 5) Custom Data Handling
   -- 6) Fold the case, as needed
   -- 7) Check for Domain Values
   -- 8) Custom Constraint Checks
   -- These constraints must be written to account for sub-types
   if not (total_cards >= 0)
   then
      raise_application_error(-20006, 'players_tab.check_rec(): Number of Total Cards for a Player must be greater than or equal to zero');
   end if;
   -- 9) Set eff_beg_dtm, if needed
   -- 10) Set aud_beg_usr and aud_beg_dtm
end check_rec;
----------------------------------------
-- Check Constraints for a players Record
function rec_status
      (id_in  in NUMBER
      )  return varchar2
is
   fs_save    boolean  := util.get_fold_strings;
   ud_save    boolean  := util.get_use_defaults;
   old_tab  players%ROWTYPE;
   new_tab  players%ROWTYPE;
begin
   select * into old_tab from players where id = id_in;
   new_tab := old_tab;
   util.set_fold_strings(FALSE);
   util.set_use_defaults(FALSE);
   check_rec (id  =>  new_tab.id
             ,game_id  =>  new_tab.game_id
             ,name  =>  new_tab.name
             ,seq  =>  new_tab.seq
             ,total_cards  =>  new_tab.total_cards
             );
   if not util.is_equal(old_tab.id, new_tab.id) then
      return 'Data Storage Error on id';
   end if;
   if not util.is_equal(old_tab.game_id, new_tab.game_id) then
      return 'Data Storage Error on game_id';
   end if;
   if not util.is_equal(old_tab.name, new_tab.name) then
      return 'Data Storage Error on name';
   end if;
   if not util.is_equal(old_tab.seq, new_tab.seq) then
      return 'Data Storage Error on seq';
   end if;
   if not util.is_equal(old_tab.total_cards, new_tab.total_cards) then
      return 'Data Storage Error on total_cards';
   end if;
   util.set_use_defaults(ud_save);
   util.set_fold_strings(fs_save);
   return 'OK';
exception
   when others then
      util.set_use_defaults(ud_save);
      util.set_fold_strings(fs_save);
      return sqlerrm;
end rec_status;
----------------------------------------
function get_id
      (players_nk1  in  VARCHAR2
      ,players_nk2  in  VARCHAR2
      ,players_nk3  in  VARCHAR2
      ) return NUMBER
   -- For all the Natural Key Columns, Return an ID
is
   retid  NUMBER(38);
begin
   select id
    into  retid
    from  players  PLY
    where PLY.game_id = games_tab.get_id
             (players_nk1
             ,players_nk2
             )
     and  PLY.name = players_nk3
    ;
   return retid;
exception when no_data_found then return null;
end get_id;
----------------------------------------
function get_nk
      (id_in  in  NUMBER)
   return VARCHAR2
   -- For an ID, return a delimited list of Natural Key Values
is
   rtxt  VARCHAR2(4000);
begin
   select substr(   games_tab.get_nk(PLY.game_id)
    || util.nk_sep || PLY.name
                         ,1 ,4000)
    into  rtxt
    from  players PLY
    where PLY.id = id_in;
   return rtxt;
exception when no_data_found then return null;
end get_nk;
----------------------------------------
-- Should be called exclusively by the BI Trigger
--   or the "ins" procedure below
procedure ins_bi_trigger
      (n_id  in out nocopy  NUMBER
      ,n_game_id  in out nocopy  NUMBER
      ,n_name  in out nocopy  VARCHAR2
      ,n_seq  in out nocopy  NUMBER
      ,n_total_cards  in out nocopy  NUMBER
      )
is
begin
   -- BI Trigger will have run_tab = TRUE, otherwise FALSE
   -- Set n_id, if needed
   if n_id is null then
      select players_seq.nextval
       into  n_id from dual;
   elsif n_id = 0 then
      raise_application_error(-20019, 'ID of zero is not allowed');
   end if;
   check_rec (id  =>  n_id
             ,game_id  =>  n_game_id
             ,name  =>  n_name
             ,seq  =>  n_seq
             ,total_cards  =>  n_total_cards
             );
end ins_bi_trigger;
----------------------------------------
-- Can be called from anywhere, except the BI Trigger
procedure ins
      (n_rec  in out nocopy  players%ROWTYPE
      )
is
begin
   run_tab := FALSE;
   ins_bi_trigger (n_id  =>  n_rec.id
       ,n_game_id  =>  n_rec.game_id
       ,n_name  =>  n_rec.name
       ,n_seq  =>  n_rec.seq
       ,n_total_cards  =>  n_rec.total_cards
       );
   insert into players
         (id
         ,game_id
         ,name
         ,seq
         ,total_cards
         )
   values
         (n_rec.id
         ,n_rec.game_id
         ,n_rec.name
         ,n_rec.seq
         ,n_rec.total_cards
         );
   run_tab := TRUE;
exception
   when others then
      run_tab := TRUE;
      raise;
end ins;
----------------------------------------
-- Should be called exclusively by the BU Trigger
--   or the "upd" procedure below
-- Note: the OLD values must be provided to check ignore_no_change
-- Note2:  Select for Update Lock is assumed on old values row
procedure upd_bu_trigger
      (o_id  in  NUMBER
      ,o_game_id  in  NUMBER
      ,n_game_id  in out nocopy  NUMBER
      ,o_name  in  VARCHAR2
      ,n_name  in out nocopy  VARCHAR2
      ,o_seq  in  NUMBER
      ,n_seq  in out nocopy  NUMBER
      ,o_total_cards  in  NUMBER
      ,n_total_cards  in out nocopy  NUMBER
      ,run_update  out  boolean
      )
is
begin
   run_update := TRUE;
   -- BU Trigger will have run_tab = TRUE, otherwise FALSE
   if     o_game_id = n_game_id
     and  o_name = n_name
     and  o_seq = n_seq
     and  util.is_equal(o_total_cards, n_total_cards)
   then
      if util.get_ignore_no_change then
         run_update := FALSE;
         return;
      end if;
      raise_application_error(-20008, 'players_tab.upd(): Must update one of'
            || ' game_id'
            || ', name'
            || ', seq'
            || ', total_cards'
            || '.');
   end if;
   check_rec (id  =>  o_id
             ,game_id  =>  n_game_id
             ,name  =>  n_name
             ,seq  =>  n_seq
             ,total_cards  =>  n_total_cards
             );
end upd_bu_trigger;
----------------------------------------
-- Can be called from anywhere, except the BU Trigger
-- Note: the OLD values must be provided to set new_rec values
procedure upd
      (o_rec  in             players%ROWTYPE
      ,n_rec  in out nocopy  players%ROWTYPE
      )
is
   c_rec    players%ROWTYPE;  -- Current Row Data
   run_upd  boolean;
begin
   if o_rec.id is null then return; end if;
   run_tab := FALSE;
   select * into c_rec from players t1
    where t1.id = o_rec.id FOR UPDATE;
   -- If old and new match, then replace new with current
   --   because there was no original intent to change new
   if o_rec.game_id = n_rec.game_id then
      n_rec.game_id := c_rec.game_id;
   end if;
   if o_rec.name = n_rec.name then
      n_rec.name := c_rec.name;
   end if;
   if o_rec.seq = n_rec.seq then
      n_rec.seq := c_rec.seq;
   end if;
   if util.is_equal(o_rec.total_cards, n_rec.total_cards) then
      n_rec.total_cards := c_rec.total_cards;
   end if;
   -- Update the new data based on the current data
   upd_bu_trigger (o_id  =>  c_rec.id
      ,o_game_id  =>  c_rec.game_id
      ,n_game_id  =>  n_rec.game_id
      ,o_name  =>  c_rec.name
      ,n_name  =>  n_rec.name
      ,o_seq  =>  c_rec.seq
      ,n_seq  =>  n_rec.seq
      ,o_total_cards  =>  c_rec.total_cards
      ,n_total_cards  =>  n_rec.total_cards
      ,run_update  =>  run_upd
      );
   if run_upd then
      update players
        set  game_id = n_rec.game_id
            ,name = n_rec.name
            ,seq = n_rec.seq
            ,total_cards = n_rec.total_cards
       where id = o_rec.id;
   end if;
   run_tab := TRUE;
exception
   when others then
      run_tab := TRUE;
      raise;
end upd;
----------------------------------------
-- Can be called from anywhere, except the BU Trigger
-- Note: the OLD values must be provided to check ignore_no_change
procedure upd
      (n_rec  in out nocopy  players%ROWTYPE
      )
is
   c_rec    players%ROWTYPE;  -- Current Row Data
   run_upd  boolean;
begin
   if n_rec.id is null then return; end if;
   run_tab := FALSE;
   select * into c_rec from players t1
    where t1.id = n_rec.id FOR UPDATE;
   upd_bu_trigger (o_id  =>  c_rec.id
      ,o_game_id  =>  c_rec.game_id
      ,n_game_id  =>  n_rec.game_id
      ,o_name  =>  c_rec.name
      ,n_name  =>  n_rec.name
      ,o_seq  =>  c_rec.seq
      ,n_seq  =>  n_rec.seq
      ,o_total_cards  =>  c_rec.total_cards
      ,n_total_cards  =>  n_rec.total_cards
      ,run_update  =>  run_upd
      );
   if run_upd then
      update players
        set  game_id = n_rec.game_id
            ,name = n_rec.name
            ,seq = n_rec.seq
            ,total_cards = n_rec.total_cards
       where id = c_rec.id;
   end if;
   run_tab := TRUE;
exception
   when others then
      run_tab := TRUE;
      raise;
end upd;
----------------------------------------
-- There is no delete trigger for this table
----------------------------------------
-- Can be called from anywhere, except the BD Trigger
procedure del
      (o_id  in  NUMBER
      )
is
begin
   -- NOTE: there is no delete trigger for this table
   if o_id is null then return; end if;
   run_tab := FALSE;
   delete from players PLY
    where PLY.id = o_id;
   run_tab := TRUE;
end del;
----------------------------------------
end players_tab;
/
select 'PLAYERS_TAB' as "Package Body:"
 from  user_errors
 where name  = 'PLAYERS_TAB'
  and  type  = 'PACKAGE BODY'
  and  rownum = 1
/
select '('||line||'/'||position||') '||text as error
 from  user_errors
 where name = 'PLAYERS_TAB'
  and  type = 'PACKAGE BODY'
 order by sequence
/


create package body cards_tab
is

-- Package Body Cards_Tab
--    Table functions and integrity checks)

   -- Application: Clue Notes For Oracle
   -- Generated by DTGen (http://dmstex.com/services/dtgen)
   -- December  16, 2013  11:32:29 AM

   --
   --
   -- © Duane.Dieterich@DMSTEX.com 2013
   --
   -- All Rights Reserved
   --
   -- No part of this software may be reproduced, copied, modified or adapted,
   -- without the prior written consent of the author, unless otherwise
   -- indicated for stand-alone materials.
   --
   -- You may quote extracts from this software with attribution to
   -- Duane.Dieterich@DMSTEX.com
   --
   -- For any other mode of sharing, please contact Duane.Dieterich@DMSTEX.com.
   --
   -- Commercial use and distribution of this software is not allowed without
   -- express and prior written consent of the author.
   --
   -- THE SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
   -- INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY
   -- AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL
   -- THE COPYRIGHT HOLDER OR DMSTEX BUSINESS SOLUTIONS LLC, ITS MEMBERS,
   -- MANAGERS, OR EMPLOYEES BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
   -- SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
   -- TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
   -- PROFITS; CORRUPTION OF DATA, OR BUSINESS INTERRUPTION) HOWEVER CAUSED
   -- AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
   -- OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF
   -- THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH
   -- DAMAGE.
   --
   --


----------------------------------------
procedure check_rec
      (id  in  NUMBER
      ,game_id  in out nocopy  NUMBER
      ,name  in out nocopy  VARCHAR2
      ,ctype_id  in out nocopy  NUMBER
      )
is
begin
   -- 1) Set Default Values as Needed
   -- 2) Check for NOT NULL
   if game_id is null then
      raise_application_error(-20004, 'cards_tab.check_rec(): game_id cannot be null.');
   end if;
   if name is null then
      raise_application_error(-20004, 'cards_tab.check_rec(): name cannot be null.');
   end if;
   if ctype_id is null then
      raise_application_error(-20004, 'cards_tab.check_rec(): ctype_id cannot be null.');
   end if;
   -- 3) Sub-type NULL checks
   -- 4) Compress Spaces, as needed
   -- 5) Custom Data Handling
   -- 6) Fold the case, as needed
   if util.get_fold_strings then
      name := upper(name);
   else
      if name is not null
      then
         if name != upper(name) then
            raise_application_error(-20003, 'cards_tab.check_rec(): name must be upper case.');
         end if;
      end if;
   end if;
   -- 7) Check for Domain Values
   -- 8) Custom Constraint Checks
   -- These constraints must be written to account for sub-types
   -- 9) Set eff_beg_dtm, if needed
   -- 10) Set aud_beg_usr and aud_beg_dtm
end check_rec;
----------------------------------------
-- Check Constraints for a cards Record
function rec_status
      (id_in  in NUMBER
      )  return varchar2
is
   fs_save    boolean  := util.get_fold_strings;
   ud_save    boolean  := util.get_use_defaults;
   old_tab  cards%ROWTYPE;
   new_tab  cards%ROWTYPE;
begin
   select * into old_tab from cards where id = id_in;
   new_tab := old_tab;
   util.set_fold_strings(FALSE);
   util.set_use_defaults(FALSE);
   check_rec (id  =>  new_tab.id
             ,game_id  =>  new_tab.game_id
             ,name  =>  new_tab.name
             ,ctype_id  =>  new_tab.ctype_id
             );
   if not util.is_equal(old_tab.id, new_tab.id) then
      return 'Data Storage Error on id';
   end if;
   if not util.is_equal(old_tab.game_id, new_tab.game_id) then
      return 'Data Storage Error on game_id';
   end if;
   if not util.is_equal(old_tab.name, new_tab.name) then
      return 'Data Storage Error on name';
   end if;
   if not util.is_equal(old_tab.ctype_id, new_tab.ctype_id) then
      return 'Data Storage Error on ctype_id';
   end if;
   util.set_use_defaults(ud_save);
   util.set_fold_strings(fs_save);
   return 'OK';
exception
   when others then
      util.set_use_defaults(ud_save);
      util.set_fold_strings(fs_save);
      return sqlerrm;
end rec_status;
----------------------------------------
function get_id
      (cards_nk1  in  VARCHAR2
      ,cards_nk2  in  VARCHAR2
      ,cards_nk3  in  VARCHAR2
      ) return NUMBER
   -- For all the Natural Key Columns, Return an ID
is
   retid  NUMBER(38);
begin
   select id
    into  retid
    from  cards  CRD
    where CRD.game_id = games_tab.get_id
             (cards_nk1
             ,cards_nk2
             )
     and  CRD.name = cards_nk3
    ;
   return retid;
exception when no_data_found then return null;
end get_id;
----------------------------------------
function get_nk
      (id_in  in  NUMBER)
   return VARCHAR2
   -- For an ID, return a delimited list of Natural Key Values
is
   rtxt  VARCHAR2(4000);
begin
   select substr(   games_tab.get_nk(CRD.game_id)
    || util.nk_sep || CRD.name
                         ,1 ,4000)
    into  rtxt
    from  cards CRD
    where CRD.id = id_in;
   return rtxt;
exception when no_data_found then return null;
end get_nk;
----------------------------------------
-- Should be called exclusively by the BI Trigger
--   or the "ins" procedure below
procedure ins_bi_trigger
      (n_id  in out nocopy  NUMBER
      ,n_game_id  in out nocopy  NUMBER
      ,n_name  in out nocopy  VARCHAR2
      ,n_ctype_id  in out nocopy  NUMBER
      )
is
begin
   -- BI Trigger will have run_tab = TRUE, otherwise FALSE
   -- Set n_id, if needed
   if n_id is null then
      select cards_seq.nextval
       into  n_id from dual;
   elsif n_id = 0 then
      raise_application_error(-20019, 'ID of zero is not allowed');
   end if;
   check_rec (id  =>  n_id
             ,game_id  =>  n_game_id
             ,name  =>  n_name
             ,ctype_id  =>  n_ctype_id
             );
end ins_bi_trigger;
----------------------------------------
-- Can be called from anywhere, except the BI Trigger
procedure ins
      (n_rec  in out nocopy  cards%ROWTYPE
      )
is
begin
   run_tab := FALSE;
   ins_bi_trigger (n_id  =>  n_rec.id
       ,n_game_id  =>  n_rec.game_id
       ,n_name  =>  n_rec.name
       ,n_ctype_id  =>  n_rec.ctype_id
       );
   insert into cards
         (id
         ,game_id
         ,name
         ,ctype_id
         )
   values
         (n_rec.id
         ,n_rec.game_id
         ,n_rec.name
         ,n_rec.ctype_id
         );
   run_tab := TRUE;
exception
   when others then
      run_tab := TRUE;
      raise;
end ins;
----------------------------------------
-- Should be called exclusively by the BU Trigger
--   or the "upd" procedure below
-- Note: the OLD values must be provided to check ignore_no_change
-- Note2:  Select for Update Lock is assumed on old values row
procedure upd_bu_trigger
      (o_id  in  NUMBER
      ,o_game_id  in  NUMBER
      ,n_game_id  in out nocopy  NUMBER
      ,o_name  in  VARCHAR2
      ,n_name  in out nocopy  VARCHAR2
      ,o_ctype_id  in  NUMBER
      ,n_ctype_id  in out nocopy  NUMBER
      ,run_update  out  boolean
      )
is
begin
   run_update := TRUE;
   -- BU Trigger will have run_tab = TRUE, otherwise FALSE
   if     o_game_id = n_game_id
     and  o_name = n_name
     and  o_ctype_id = n_ctype_id
   then
      if util.get_ignore_no_change then
         run_update := FALSE;
         return;
      end if;
      raise_application_error(-20008, 'cards_tab.upd(): Must update one of'
            || ' game_id'
            || ', name'
            || ', ctype_id'
            || '.');
   end if;
   check_rec (id  =>  o_id
             ,game_id  =>  n_game_id
             ,name  =>  n_name
             ,ctype_id  =>  n_ctype_id
             );
end upd_bu_trigger;
----------------------------------------
-- Can be called from anywhere, except the BU Trigger
-- Note: the OLD values must be provided to set new_rec values
procedure upd
      (o_rec  in             cards%ROWTYPE
      ,n_rec  in out nocopy  cards%ROWTYPE
      )
is
   c_rec    cards%ROWTYPE;  -- Current Row Data
   run_upd  boolean;
begin
   if o_rec.id is null then return; end if;
   run_tab := FALSE;
   select * into c_rec from cards t1
    where t1.id = o_rec.id FOR UPDATE;
   -- If old and new match, then replace new with current
   --   because there was no original intent to change new
   if o_rec.game_id = n_rec.game_id then
      n_rec.game_id := c_rec.game_id;
   end if;
   if o_rec.name = n_rec.name then
      n_rec.name := c_rec.name;
   end if;
   if o_rec.ctype_id = n_rec.ctype_id then
      n_rec.ctype_id := c_rec.ctype_id;
   end if;
   -- Update the new data based on the current data
   upd_bu_trigger (o_id  =>  c_rec.id
      ,o_game_id  =>  c_rec.game_id
      ,n_game_id  =>  n_rec.game_id
      ,o_name  =>  c_rec.name
      ,n_name  =>  n_rec.name
      ,o_ctype_id  =>  c_rec.ctype_id
      ,n_ctype_id  =>  n_rec.ctype_id
      ,run_update  =>  run_upd
      );
   if run_upd then
      update cards
        set  game_id = n_rec.game_id
            ,name = n_rec.name
            ,ctype_id = n_rec.ctype_id
       where id = o_rec.id;
   end if;
   run_tab := TRUE;
exception
   when others then
      run_tab := TRUE;
      raise;
end upd;
----------------------------------------
-- Can be called from anywhere, except the BU Trigger
-- Note: the OLD values must be provided to check ignore_no_change
procedure upd
      (n_rec  in out nocopy  cards%ROWTYPE
      )
is
   c_rec    cards%ROWTYPE;  -- Current Row Data
   run_upd  boolean;
begin
   if n_rec.id is null then return; end if;
   run_tab := FALSE;
   select * into c_rec from cards t1
    where t1.id = n_rec.id FOR UPDATE;
   upd_bu_trigger (o_id  =>  c_rec.id
      ,o_game_id  =>  c_rec.game_id
      ,n_game_id  =>  n_rec.game_id
      ,o_name  =>  c_rec.name
      ,n_name  =>  n_rec.name
      ,o_ctype_id  =>  c_rec.ctype_id
      ,n_ctype_id  =>  n_rec.ctype_id
      ,run_update  =>  run_upd
      );
   if run_upd then
      update cards
        set  game_id = n_rec.game_id
            ,name = n_rec.name
            ,ctype_id = n_rec.ctype_id
       where id = c_rec.id;
   end if;
   run_tab := TRUE;
exception
   when others then
      run_tab := TRUE;
      raise;
end upd;
----------------------------------------
-- There is no delete trigger for this table
----------------------------------------
-- Can be called from anywhere, except the BD Trigger
procedure del
      (o_id  in  NUMBER
      )
is
begin
   -- NOTE: there is no delete trigger for this table
   if o_id is null then return; end if;
   run_tab := FALSE;
   delete from cards CRD
    where CRD.id = o_id;
   run_tab := TRUE;
end del;
----------------------------------------
end cards_tab;
/
select 'CARDS_TAB' as "Package Body:"
 from  user_errors
 where name  = 'CARDS_TAB'
  and  type  = 'PACKAGE BODY'
  and  rownum = 1
/
select '('||line||'/'||position||') '||text as error
 from  user_errors
 where name = 'CARDS_TAB'
  and  type = 'PACKAGE BODY'
 order by sequence
/


create package body actions_tab
is

-- Package Body Actions_Tab
--    Table functions and integrity checks)

   -- Application: Clue Notes For Oracle
   -- Generated by DTGen (http://dmstex.com/services/dtgen)
   -- December  16, 2013  11:32:29 AM

   --
   --
   -- © Duane.Dieterich@DMSTEX.com 2013
   --
   -- All Rights Reserved
   --
   -- No part of this software may be reproduced, copied, modified or adapted,
   -- without the prior written consent of the author, unless otherwise
   -- indicated for stand-alone materials.
   --
   -- You may quote extracts from this software with attribution to
   -- Duane.Dieterich@DMSTEX.com
   --
   -- For any other mode of sharing, please contact Duane.Dieterich@DMSTEX.com.
   --
   -- Commercial use and distribution of this software is not allowed without
   -- express and prior written consent of the author.
   --
   -- THE SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
   -- INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY
   -- AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL
   -- THE COPYRIGHT HOLDER OR DMSTEX BUSINESS SOLUTIONS LLC, ITS MEMBERS,
   -- MANAGERS, OR EMPLOYEES BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
   -- SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
   -- TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
   -- PROFITS; CORRUPTION OF DATA, OR BUSINESS INTERRUPTION) HOWEVER CAUSED
   -- AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
   -- OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF
   -- THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH
   -- DAMAGE.
   --
   --


----------------------------------------
function next_seq
      (player_id_in  in  NUMBER
      ) return number
is
   -- This PRAGMA would prevent "ORA-04091: Mutating Table".  However,
   --   removing the function from the pending transaction prevents it
   --   from "seeing" any newly inserted records that are pending.
   --PRAGMA AUTONOMOUS_TRANSACTION;
   seq_num  number;
begin
   select max(ACT.seq) into seq_num
    from  actions  ACT
         ,players  PLY
    where ACT.player_id = player_id_in
   ;
   return nvl(seq_num,0) + 1;
exception when others then
   if sqlerrm not like 'ORA-04091:%' then raise;
   else raise_application_error(-20027,
      'ORA-04091: Mutating Table Error.  Try using actions_DML package instead');
   end if;
end next_seq;
----------------------------------------
procedure check_rec
      (id  in  NUMBER
      ,actions_sub_type  in out nocopy  VARCHAR2
      ,player_id  in out nocopy  NUMBER
      ,seq  in out nocopy  NUMBER
      ,resolved  in out nocopy  VARCHAR2
      ,res_action_id  in out nocopy  NUMBER
      ,rev_player_id  in out nocopy  NUMBER
      )
is
   --------------------
   procedure cknl_res_action_id (stname_in varchar2) is begin
      if res_action_id is not null then
         if util.get_fix_non_null_sub_types then
            res_action_id := null;
         else
            raise_application_error(-20026, 'actions_tab.check_rec(): res_action_id must be null for sub-type: ' || stname_in);
         end if;
      end if;
   end cknl_res_action_id;
   --------------------
   procedure cknl_rev_player_id (stname_in varchar2) is begin
      if rev_player_id is not null then
         if util.get_fix_non_null_sub_types then
            rev_player_id := null;
         else
            raise_application_error(-20026, 'actions_tab.check_rec(): rev_player_id must be null for sub-type: ' || stname_in);
         end if;
      end if;
   end cknl_rev_player_id;
   --------------------
begin
   -- 1) Set Default Values as Needed
   if util.get_use_defaults then
      if resolved is null
      then
         resolved := 'NOT';
      end if;
   end if;
   -- 2) Check for NOT NULL
   if player_id is null then
      raise_application_error(-20004, 'actions_tab.check_rec(): player_id cannot be null.');
   end if;
   if seq is null then
      raise_application_error(-20004, 'actions_tab.check_rec(): seq cannot be null.');
   end if;
   if resolved is null then
      raise_application_error(-20004, 'actions_tab.check_rec(): resolved cannot be null.');
   end if;
   -- 3) Sub-type NULL checks
   case actions_sub_type
   when 'accusation' then
      cknl_res_action_id('accusation');
      cknl_rev_player_id('accusation');
   when 'revelation' then
      cknl_res_action_id('revelation');
      cknl_rev_player_id('revelation');
   when 'suggestion' then
      null;   -- There are no NULL checks for this subtype.
   else
      raise_application_error(-20025, 'actions.check_rec(): actions_sub_type must be one of accusation, revelation, suggestion');
   end case;
   -- 4) Compress Spaces, as needed
   -- 5) Custom Data Handling
   -- 6) Fold the case, as needed
   if util.get_fold_strings then
      resolved := upper(resolved);
   else
      if resolved is not null
      then
         if resolved != upper(resolved) then
            raise_application_error(-20003, 'actions_tab.check_rec(): resolved must be upper case.');
         end if;
      end if;
   end if;
   -- 7) Check for Domain Values
   if resolved is not null
      and not Resolutions_dom.includes(resolved)
   then
      raise_application_error(-20005, 'actions_tab.check_rec(): resolved must be one of ("NOT", "REV", "DED", "UND").');
   end if;
   -- 8) Custom Constraint Checks
   -- These constraints must be written to account for sub-types
   if not (seq > 0)
   then
      raise_application_error(-20006, 'actions_tab.check_rec(): Action Sequence number must be greater than zero');
   end if;
   if not (actions_sub_type != 'suggestion' or resolved in ('NOT','UND') or res_action_id is not null)
   then
      raise_application_error(-20006, 'actions_tab.check_rec(): Resolved Suggestions must have a Resolved Action ID');
   end if;
   if not (resolved not in ('NOT','UND') or res_action_id is null)
   then
      raise_application_error(-20006, 'actions_tab.check_rec(): Unresolved Actions cannot have a Resolved Action ID');
   end if;
   -- 9) Set eff_beg_dtm, if needed
   -- 10) Set aud_beg_usr and aud_beg_dtm
end check_rec;
----------------------------------------
-- Check Constraints for a actions Record
function rec_status
      (id_in  in NUMBER
      )  return varchar2
is
   fs_save    boolean  := util.get_fold_strings;
   ud_save    boolean  := util.get_use_defaults;
   old_tab  actions%ROWTYPE;
   new_tab  actions%ROWTYPE;
begin
   select * into old_tab from actions where id = id_in;
   new_tab := old_tab;
   util.set_fold_strings(FALSE);
   util.set_use_defaults(FALSE);
   check_rec (id  =>  new_tab.id
             ,actions_sub_type  =>  new_tab.actions_sub_type
             ,player_id  =>  new_tab.player_id
             ,seq  =>  new_tab.seq
             ,resolved  =>  new_tab.resolved
             ,res_action_id  =>  new_tab.res_action_id
             ,rev_player_id  =>  new_tab.rev_player_id
             );
   if not util.is_equal(old_tab.id, new_tab.id) then
      return 'Data Storage Error on id';
   end if;
   if not util.is_equal(old_tab.actions_sub_type, new_tab.actions_sub_type) then
      return 'Data Storage Error on actions_sub_type';
   end if;
   if not util.is_equal(old_tab.player_id, new_tab.player_id) then
      return 'Data Storage Error on player_id';
   end if;
   if not util.is_equal(old_tab.seq, new_tab.seq) then
      return 'Data Storage Error on seq';
   end if;
   if not util.is_equal(old_tab.resolved, new_tab.resolved) then
      return 'Data Storage Error on resolved';
   end if;
   if not util.is_equal(old_tab.res_action_id, new_tab.res_action_id) then
      return 'Data Storage Error on res_action_id';
   end if;
   if not util.is_equal(old_tab.rev_player_id, new_tab.rev_player_id) then
      return 'Data Storage Error on rev_player_id';
   end if;
   util.set_use_defaults(ud_save);
   util.set_fold_strings(fs_save);
   return 'OK';
exception
   when others then
      util.set_use_defaults(ud_save);
      util.set_fold_strings(fs_save);
      return sqlerrm;
end rec_status;
----------------------------------------
function get_id
      (actions_nk1  in  VARCHAR2
      ,actions_nk2  in  VARCHAR2
      ,actions_nk3  in  VARCHAR2
      ,actions_nk4  in  NUMBER
      ) return NUMBER
   -- For all the Natural Key Columns, Return an ID
is
   retid  NUMBER(38);
begin
   select id
    into  retid
    from  actions  ACT
    where ACT.player_id = players_tab.get_id
             (actions_nk1
             ,actions_nk2
             ,actions_nk3
             )
     and  ACT.seq = actions_nk4
    ;
   return retid;
exception when no_data_found then return null;
end get_id;
----------------------------------------
function get_nk
      (id_in  in  NUMBER)
   return VARCHAR2
   -- For an ID, return a delimited list of Natural Key Values
is
   rtxt  VARCHAR2(4000);
begin
   select substr(   players_tab.get_nk(ACT.player_id)
    || util.nk_sep || ACT.seq
                         ,1 ,4000)
    into  rtxt
    from  actions ACT
    where ACT.id = id_in;
   return rtxt;
exception when no_data_found then return null;
end get_nk;
----------------------------------------
function get_res_id_path
      (id_in  in  NUMBER)
   return varchar2
   -- For a hierarchy ID, return a delimited list of IDs
is
   rtxt  VARCHAR2(4000) := null;
   rlen  number := 0;
begin
   for buff in (
      select id, level from actions
       start with id = id_in
       connect by nocycle id = prior res_action_id
       order by level desc )
   loop
      rlen := rlen + length(buff.id);
      if rlen > 4000 - 3 then
         return rtxt || '...';
      end if;
      rtxt := rtxt || buff.id || util.path_sep;
   end loop;
   return substr(rtxt,1,length(rtxt)-1);
end get_res_id_path;
----------------------------------------
function get_res_nk_path
      (id_in  in  NUMBER)
   return CLOB
   -- For a hierarchy ID, return a delimited list of
   --    Natural Key sets
is
   rtxt  VARCHAR2(32767) := null;
   rlen  number := 0;
begin
   for buff in (
      select get_nk(id) nk, level
       from  actions
       start with id = id_in
       connect by nocycle id = prior res_action_id
       order by level desc )
   loop
      rlen := rlen + length(buff.nk);
      if rlen > 32767 - 3 then
         return rtxt || '...';
      end if;
      rtxt := rtxt || buff.nk || util.path_sep;
   end loop;
   return substr(rtxt,1,length(rtxt)-1);
end get_res_nk_path;
----------------------------------------
function get_res_id_by_id_path
      (id_path_in  VARCHAR2
      ) return NUMBER
is
   ps_pos     number;    -- Path Seperator position in id_path_in
   id_num     number;    -- ID number in a character string
   retid      NUMBER(38);   -- ID number to Return
begin
   if id_path_in is null then return null; end if;
   ps_pos := instr(id_path_in, util.path_sep, -1, 1);
   begin
      -- This should be the last concatenated Natural Key in nk_path_in
      id_num := to_number(substr(id_path_in, ps_pos+1));
   exception when VALUE_ERROR then return null;
   end;
   select ACT.id
    into  retid
    from  actions ACT
    where ACT.id = id_num
     and  get_res_id_path(ACT.id) = id_path_in;
   return retid;
exception when no_data_found then return null;
end get_res_id_by_id_path;
----------------------------------------
-- Should be called exclusively by the BI Trigger
--   or the "ins" procedure below
procedure ins_bi_trigger
      (n_id  in out nocopy  NUMBER
      ,n_actions_sub_type  in out nocopy  VARCHAR2
      ,n_player_id  in out nocopy  NUMBER
      ,n_seq  in out nocopy  NUMBER
      ,n_resolved  in out nocopy  VARCHAR2
      ,n_res_action_id  in out nocopy  NUMBER
      ,n_rev_player_id  in out nocopy  NUMBER
      )
is
begin
   -- BI Trigger will have run_tab = TRUE, otherwise FALSE
   -- Set n_id, if needed
   if n_id is null then
      select actions_seq.nextval
       into  n_id from dual;
      -- Set the ID on this self-referencing record
      if n_res_action_id = 0 then
         n_res_action_id := n_id;
      end if;
   elsif n_id = 0 then
      raise_application_error(-20019, 'ID of zero is not allowed');
   end if;
   check_rec (id  =>  n_id
             ,actions_sub_type  =>  n_actions_sub_type
             ,player_id  =>  n_player_id
             ,seq  =>  n_seq
             ,resolved  =>  n_resolved
             ,res_action_id  =>  n_res_action_id
             ,rev_player_id  =>  n_rev_player_id
             );
end ins_bi_trigger;
----------------------------------------
-- Can be called from anywhere, except the BI Trigger
procedure ins
      (n_rec  in out nocopy  actions%ROWTYPE
      )
is
begin
   run_tab := FALSE;
   ins_bi_trigger (n_id  =>  n_rec.id
       ,n_actions_sub_type  =>  n_rec.actions_sub_type
       ,n_player_id  =>  n_rec.player_id
       ,n_seq  =>  n_rec.seq
       ,n_resolved  =>  n_rec.resolved
       ,n_res_action_id  =>  n_rec.res_action_id
       ,n_rev_player_id  =>  n_rec.rev_player_id
       );
   insert into actions
         (id
         ,actions_sub_type
         ,player_id
         ,seq
         ,resolved
         ,res_action_id
         ,rev_player_id
         )
   values
         (n_rec.id
         ,n_rec.actions_sub_type
         ,n_rec.player_id
         ,n_rec.seq
         ,n_rec.resolved
         ,n_rec.res_action_id
         ,n_rec.rev_player_id
         );
   run_tab := TRUE;
exception
   when others then
      run_tab := TRUE;
      raise;
end ins;
----------------------------------------
-- Should be called exclusively by the BU Trigger
--   or the "upd" procedure below
-- Note: the OLD values must be provided to check ignore_no_change
-- Note2:  Select for Update Lock is assumed on old values row
procedure upd_bu_trigger
      (o_id  in  NUMBER
      ,o_actions_sub_type  in  VARCHAR2
      ,n_actions_sub_type  in out nocopy  VARCHAR2
      ,o_player_id  in  NUMBER
      ,n_player_id  in out nocopy  NUMBER
      ,o_seq  in  NUMBER
      ,n_seq  in out nocopy  NUMBER
      ,o_resolved  in  VARCHAR2
      ,n_resolved  in out nocopy  VARCHAR2
      ,o_res_action_id  in  NUMBER
      ,n_res_action_id  in out nocopy  NUMBER
      ,o_rev_player_id  in  NUMBER
      ,n_rev_player_id  in out nocopy  NUMBER
      ,run_update  out  boolean
      )
is
begin
   run_update := TRUE;
   -- BU Trigger will have run_tab = TRUE, otherwise FALSE
   if     util.is_equal(o_actions_sub_type, n_actions_sub_type)
     and  o_player_id = n_player_id
     and  o_seq = n_seq
     and  o_resolved = n_resolved
     and  util.is_equal(o_res_action_id, n_res_action_id)
     and  util.is_equal(o_rev_player_id, n_rev_player_id)
   then
      if util.get_ignore_no_change then
         run_update := FALSE;
         return;
      end if;
      raise_application_error(-20008, 'actions_tab.upd(): Must update one of'
            || ' actions_sub_type'
            || ', player_id'
            || ', seq'
            || ', resolved'
            || ', res_action_id'
            || ', rev_player_id'
            || '.');
   end if;
   check_rec (id  =>  o_id
             ,actions_sub_type  =>  n_actions_sub_type
             ,player_id  =>  n_player_id
             ,seq  =>  n_seq
             ,resolved  =>  n_resolved
             ,res_action_id  =>  n_res_action_id
             ,rev_player_id  =>  n_rev_player_id
             );
end upd_bu_trigger;
----------------------------------------
-- Can be called from anywhere, except the BU Trigger
-- Note: the OLD values must be provided to set new_rec values
procedure upd
      (o_rec  in             actions%ROWTYPE
      ,n_rec  in out nocopy  actions%ROWTYPE
      )
is
   c_rec    actions%ROWTYPE;  -- Current Row Data
   run_upd  boolean;
begin
   if o_rec.id is null then return; end if;
   run_tab := FALSE;
   select * into c_rec from actions t1
    where t1.id = o_rec.id FOR UPDATE;
   -- If old and new match, then replace new with current
   --   because there was no original intent to change new
   if util.is_equal(o_rec.actions_sub_type, n_rec.actions_sub_type) then
      n_rec.actions_sub_type := c_rec.actions_sub_type;
   end if;
   if o_rec.player_id = n_rec.player_id then
      n_rec.player_id := c_rec.player_id;
   end if;
   if o_rec.seq = n_rec.seq then
      n_rec.seq := c_rec.seq;
   end if;
   if o_rec.resolved = n_rec.resolved then
      n_rec.resolved := c_rec.resolved;
   end if;
   if util.is_equal(o_rec.res_action_id, n_rec.res_action_id) then
      n_rec.res_action_id := c_rec.res_action_id;
   end if;
   if util.is_equal(o_rec.rev_player_id, n_rec.rev_player_id) then
      n_rec.rev_player_id := c_rec.rev_player_id;
   end if;
   -- Update the new data based on the current data
   upd_bu_trigger (o_id  =>  c_rec.id
      ,o_actions_sub_type  =>  c_rec.actions_sub_type
      ,n_actions_sub_type  =>  n_rec.actions_sub_type
      ,o_player_id  =>  c_rec.player_id
      ,n_player_id  =>  n_rec.player_id
      ,o_seq  =>  c_rec.seq
      ,n_seq  =>  n_rec.seq
      ,o_resolved  =>  c_rec.resolved
      ,n_resolved  =>  n_rec.resolved
      ,o_res_action_id  =>  c_rec.res_action_id
      ,n_res_action_id  =>  n_rec.res_action_id
      ,o_rev_player_id  =>  c_rec.rev_player_id
      ,n_rev_player_id  =>  n_rec.rev_player_id
      ,run_update  =>  run_upd
      );
   if run_upd then
      update actions
        set  actions_sub_type = n_rec.actions_sub_type
            ,player_id = n_rec.player_id
            ,seq = n_rec.seq
            ,resolved = n_rec.resolved
            ,res_action_id = n_rec.res_action_id
            ,rev_player_id = n_rec.rev_player_id
       where id = o_rec.id;
   end if;
   run_tab := TRUE;
exception
   when others then
      run_tab := TRUE;
      raise;
end upd;
----------------------------------------
-- Can be called from anywhere, except the BU Trigger
-- Note: the OLD values must be provided to check ignore_no_change
procedure upd
      (n_rec  in out nocopy  actions%ROWTYPE
      )
is
   c_rec    actions%ROWTYPE;  -- Current Row Data
   run_upd  boolean;
begin
   if n_rec.id is null then return; end if;
   run_tab := FALSE;
   select * into c_rec from actions t1
    where t1.id = n_rec.id FOR UPDATE;
   upd_bu_trigger (o_id  =>  c_rec.id
      ,o_actions_sub_type  =>  c_rec.actions_sub_type
      ,n_actions_sub_type  =>  n_rec.actions_sub_type
      ,o_player_id  =>  c_rec.player_id
      ,n_player_id  =>  n_rec.player_id
      ,o_seq  =>  c_rec.seq
      ,n_seq  =>  n_rec.seq
      ,o_resolved  =>  c_rec.resolved
      ,n_resolved  =>  n_rec.resolved
      ,o_res_action_id  =>  c_rec.res_action_id
      ,n_res_action_id  =>  n_rec.res_action_id
      ,o_rev_player_id  =>  c_rec.rev_player_id
      ,n_rev_player_id  =>  n_rec.rev_player_id
      ,run_update  =>  run_upd
      );
   if run_upd then
      update actions
        set  actions_sub_type = n_rec.actions_sub_type
            ,player_id = n_rec.player_id
            ,seq = n_rec.seq
            ,resolved = n_rec.resolved
            ,res_action_id = n_rec.res_action_id
            ,rev_player_id = n_rec.rev_player_id
       where id = c_rec.id;
   end if;
   run_tab := TRUE;
exception
   when others then
      run_tab := TRUE;
      raise;
end upd;
----------------------------------------
-- There is no delete trigger for this table
----------------------------------------
-- Can be called from anywhere, except the BD Trigger
procedure del
      (o_id  in  NUMBER
      )
is
begin
   -- NOTE: there is no delete trigger for this table
   if o_id is null then return; end if;
   run_tab := FALSE;
   delete from actions ACT
    where ACT.id = o_id;
   run_tab := TRUE;
end del;
----------------------------------------
end actions_tab;
/
select 'ACTIONS_TAB' as "Package Body:"
 from  user_errors
 where name  = 'ACTIONS_TAB'
  and  type  = 'PACKAGE BODY'
  and  rownum = 1
/
select '('||line||'/'||position||') '||text as error
 from  user_errors
 where name = 'ACTIONS_TAB'
  and  type = 'PACKAGE BODY'
 order by sequence
/


create package body action_cards_tab
is

-- Package Body Action_Cards_Tab
--    Table functions and integrity checks)

   -- Application: Clue Notes For Oracle
   -- Generated by DTGen (http://dmstex.com/services/dtgen)
   -- December  16, 2013  11:32:29 AM

   --
   --
   -- © Duane.Dieterich@DMSTEX.com 2013
   --
   -- All Rights Reserved
   --
   -- No part of this software may be reproduced, copied, modified or adapted,
   -- without the prior written consent of the author, unless otherwise
   -- indicated for stand-alone materials.
   --
   -- You may quote extracts from this software with attribution to
   -- Duane.Dieterich@DMSTEX.com
   --
   -- For any other mode of sharing, please contact Duane.Dieterich@DMSTEX.com.
   --
   -- Commercial use and distribution of this software is not allowed without
   -- express and prior written consent of the author.
   --
   -- THE SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
   -- INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY
   -- AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL
   -- THE COPYRIGHT HOLDER OR DMSTEX BUSINESS SOLUTIONS LLC, ITS MEMBERS,
   -- MANAGERS, OR EMPLOYEES BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
   -- SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
   -- TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
   -- PROFITS; CORRUPTION OF DATA, OR BUSINESS INTERRUPTION) HOWEVER CAUSED
   -- AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
   -- OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF
   -- THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH
   -- DAMAGE.
   --
   --


----------------------------------------
procedure check_rec
      (id  in  NUMBER
      ,action_id  in out nocopy  NUMBER
      ,card_id  in out nocopy  NUMBER
      )
is
begin
   -- 1) Set Default Values as Needed
   -- 2) Check for NOT NULL
   if action_id is null then
      raise_application_error(-20004, 'action_cards_tab.check_rec(): action_id cannot be null.');
   end if;
   if card_id is null then
      raise_application_error(-20004, 'action_cards_tab.check_rec(): card_id cannot be null.');
   end if;
   -- 3) Sub-type NULL checks
   -- 4) Compress Spaces, as needed
   -- 5) Custom Data Handling
   -- 6) Fold the case, as needed
   -- 7) Check for Domain Values
   -- 8) Custom Constraint Checks
   -- These constraints must be written to account for sub-types
   -- 9) Set eff_beg_dtm, if needed
   -- 10) Set aud_beg_usr and aud_beg_dtm
end check_rec;
----------------------------------------
-- Check Constraints for a action_cards Record
function rec_status
      (id_in  in NUMBER
      )  return varchar2
is
   fs_save    boolean  := util.get_fold_strings;
   ud_save    boolean  := util.get_use_defaults;
   old_tab  action_cards%ROWTYPE;
   new_tab  action_cards%ROWTYPE;
begin
   select * into old_tab from action_cards where id = id_in;
   new_tab := old_tab;
   util.set_fold_strings(FALSE);
   util.set_use_defaults(FALSE);
   check_rec (id  =>  new_tab.id
             ,action_id  =>  new_tab.action_id
             ,card_id  =>  new_tab.card_id
             );
   if not util.is_equal(old_tab.id, new_tab.id) then
      return 'Data Storage Error on id';
   end if;
   if not util.is_equal(old_tab.action_id, new_tab.action_id) then
      return 'Data Storage Error on action_id';
   end if;
   if not util.is_equal(old_tab.card_id, new_tab.card_id) then
      return 'Data Storage Error on card_id';
   end if;
   util.set_use_defaults(ud_save);
   util.set_fold_strings(fs_save);
   return 'OK';
exception
   when others then
      util.set_use_defaults(ud_save);
      util.set_fold_strings(fs_save);
      return sqlerrm;
end rec_status;
----------------------------------------
function get_id
      (action_cards_nk1  in  VARCHAR2
      ,action_cards_nk2  in  VARCHAR2
      ,action_cards_nk3  in  VARCHAR2
      ,action_cards_nk4  in  NUMBER
      ,action_cards_nk5  in  VARCHAR2
      ,action_cards_nk6  in  VARCHAR2
      ,action_cards_nk7  in  VARCHAR2
      ) return NUMBER
   -- For all the Natural Key Columns, Return an ID
is
   retid  NUMBER(38);
begin
   select id
    into  retid
    from  action_cards  ACTC
    where ACTC.action_id = actions_tab.get_id
             (action_cards_nk1
             ,action_cards_nk2
             ,action_cards_nk3
             ,action_cards_nk4
             )
     and  ACTC.card_id = cards_tab.get_id
             (action_cards_nk5
             ,action_cards_nk6
             ,action_cards_nk7
             )
    ;
   return retid;
exception when no_data_found then return null;
end get_id;
----------------------------------------
function get_nk
      (id_in  in  NUMBER)
   return VARCHAR2
   -- For an ID, return a delimited list of Natural Key Values
is
   rtxt  VARCHAR2(4000);
begin
   select substr(   actions_tab.get_nk(ACTC.action_id)
    || util.nk_sep || cards_tab.get_nk(ACTC.card_id)
                         ,1 ,4000)
    into  rtxt
    from  action_cards ACTC
    where ACTC.id = id_in;
   return rtxt;
exception when no_data_found then return null;
end get_nk;
----------------------------------------
-- Should be called exclusively by the BI Trigger
--   or the "ins" procedure below
procedure ins_bi_trigger
      (n_id  in out nocopy  NUMBER
      ,n_action_id  in out nocopy  NUMBER
      ,n_card_id  in out nocopy  NUMBER
      )
is
begin
   -- BI Trigger will have run_tab = TRUE, otherwise FALSE
   -- Set n_id, if needed
   if n_id is null then
      select action_cards_seq.nextval
       into  n_id from dual;
   elsif n_id = 0 then
      raise_application_error(-20019, 'ID of zero is not allowed');
   end if;
   check_rec (id  =>  n_id
             ,action_id  =>  n_action_id
             ,card_id  =>  n_card_id
             );
end ins_bi_trigger;
----------------------------------------
-- Can be called from anywhere, except the BI Trigger
procedure ins
      (n_rec  in out nocopy  action_cards%ROWTYPE
      )
is
begin
   run_tab := FALSE;
   ins_bi_trigger (n_id  =>  n_rec.id
       ,n_action_id  =>  n_rec.action_id
       ,n_card_id  =>  n_rec.card_id
       );
   insert into action_cards
         (id
         ,action_id
         ,card_id
         )
   values
         (n_rec.id
         ,n_rec.action_id
         ,n_rec.card_id
         );
   run_tab := TRUE;
exception
   when others then
      run_tab := TRUE;
      raise;
end ins;
----------------------------------------
-- Should be called exclusively by the BU Trigger
--   or the "upd" procedure below
-- Note: the OLD values must be provided to check ignore_no_change
-- Note2:  Select for Update Lock is assumed on old values row
procedure upd_bu_trigger
      (o_id  in  NUMBER
      ,o_action_id  in  NUMBER
      ,n_action_id  in out nocopy  NUMBER
      ,o_card_id  in  NUMBER
      ,n_card_id  in out nocopy  NUMBER
      ,run_update  out  boolean
      )
is
begin
   run_update := TRUE;
   -- BU Trigger will have run_tab = TRUE, otherwise FALSE
   if     o_action_id = n_action_id
     and  o_card_id = n_card_id
   then
      if util.get_ignore_no_change then
         run_update := FALSE;
         return;
      end if;
      raise_application_error(-20008, 'action_cards_tab.upd(): Must update one of'
            || ' action_id'
            || ', card_id'
            || '.');
   end if;
   check_rec (id  =>  o_id
             ,action_id  =>  n_action_id
             ,card_id  =>  n_card_id
             );
end upd_bu_trigger;
----------------------------------------
-- Can be called from anywhere, except the BU Trigger
-- Note: the OLD values must be provided to set new_rec values
procedure upd
      (o_rec  in             action_cards%ROWTYPE
      ,n_rec  in out nocopy  action_cards%ROWTYPE
      )
is
   c_rec    action_cards%ROWTYPE;  -- Current Row Data
   run_upd  boolean;
begin
   if o_rec.id is null then return; end if;
   run_tab := FALSE;
   select * into c_rec from action_cards t1
    where t1.id = o_rec.id FOR UPDATE;
   -- If old and new match, then replace new with current
   --   because there was no original intent to change new
   if o_rec.action_id = n_rec.action_id then
      n_rec.action_id := c_rec.action_id;
   end if;
   if o_rec.card_id = n_rec.card_id then
      n_rec.card_id := c_rec.card_id;
   end if;
   -- Update the new data based on the current data
   upd_bu_trigger (o_id  =>  c_rec.id
      ,o_action_id  =>  c_rec.action_id
      ,n_action_id  =>  n_rec.action_id
      ,o_card_id  =>  c_rec.card_id
      ,n_card_id  =>  n_rec.card_id
      ,run_update  =>  run_upd
      );
   if run_upd then
      update action_cards
        set  action_id = n_rec.action_id
            ,card_id = n_rec.card_id
       where id = o_rec.id;
   end if;
   run_tab := TRUE;
exception
   when others then
      run_tab := TRUE;
      raise;
end upd;
----------------------------------------
-- Can be called from anywhere, except the BU Trigger
-- Note: the OLD values must be provided to check ignore_no_change
procedure upd
      (n_rec  in out nocopy  action_cards%ROWTYPE
      )
is
   c_rec    action_cards%ROWTYPE;  -- Current Row Data
   run_upd  boolean;
begin
   if n_rec.id is null then return; end if;
   run_tab := FALSE;
   select * into c_rec from action_cards t1
    where t1.id = n_rec.id FOR UPDATE;
   upd_bu_trigger (o_id  =>  c_rec.id
      ,o_action_id  =>  c_rec.action_id
      ,n_action_id  =>  n_rec.action_id
      ,o_card_id  =>  c_rec.card_id
      ,n_card_id  =>  n_rec.card_id
      ,run_update  =>  run_upd
      );
   if run_upd then
      update action_cards
        set  action_id = n_rec.action_id
            ,card_id = n_rec.card_id
       where id = c_rec.id;
   end if;
   run_tab := TRUE;
exception
   when others then
      run_tab := TRUE;
      raise;
end upd;
----------------------------------------
-- There is no delete trigger for this table
----------------------------------------
-- Can be called from anywhere, except the BD Trigger
procedure del
      (o_id  in  NUMBER
      )
is
begin
   -- NOTE: there is no delete trigger for this table
   if o_id is null then return; end if;
   run_tab := FALSE;
   delete from action_cards ACTC
    where ACTC.id = o_id;
   run_tab := TRUE;
end del;
----------------------------------------
end action_cards_tab;
/
select 'ACTION_CARDS_TAB' as "Package Body:"
 from  user_errors
 where name  = 'ACTION_CARDS_TAB'
  and  type  = 'PACKAGE BODY'
  and  rownum = 1
/
select '('||line||'/'||position||') '||text as error
 from  user_errors
 where name = 'ACTION_CARDS_TAB'
  and  type = 'PACKAGE BODY'
 order by sequence
/


create package body pcard_actions_tab
is

-- Package Body Pcard_Actions_Tab
--    Table functions and integrity checks)

   -- Application: Clue Notes For Oracle
   -- Generated by DTGen (http://dmstex.com/services/dtgen)
   -- December  16, 2013  11:32:29 AM

   --
   --
   -- © Duane.Dieterich@DMSTEX.com 2013
   --
   -- All Rights Reserved
   --
   -- No part of this software may be reproduced, copied, modified or adapted,
   -- without the prior written consent of the author, unless otherwise
   -- indicated for stand-alone materials.
   --
   -- You may quote extracts from this software with attribution to
   -- Duane.Dieterich@DMSTEX.com
   --
   -- For any other mode of sharing, please contact Duane.Dieterich@DMSTEX.com.
   --
   -- Commercial use and distribution of this software is not allowed without
   -- express and prior written consent of the author.
   --
   -- THE SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
   -- INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY
   -- AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL
   -- THE COPYRIGHT HOLDER OR DMSTEX BUSINESS SOLUTIONS LLC, ITS MEMBERS,
   -- MANAGERS, OR EMPLOYEES BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
   -- SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
   -- TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
   -- PROFITS; CORRUPTION OF DATA, OR BUSINESS INTERRUPTION) HOWEVER CAUSED
   -- AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
   -- OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF
   -- THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH
   -- DAMAGE.
   --
   --


----------------------------------------
procedure check_rec
      (id  in  NUMBER
      ,card_id  in out nocopy  NUMBER
      ,disposition  in out nocopy  VARCHAR2
      ,player_id  in out nocopy  NUMBER
      ,action_id  in out nocopy  NUMBER
      )
is
begin
   -- 1) Set Default Values as Needed
   -- 2) Check for NOT NULL
   if card_id is null then
      raise_application_error(-20004, 'pcard_actions_tab.check_rec(): card_id cannot be null.');
   end if;
   if disposition is null then
      raise_application_error(-20004, 'pcard_actions_tab.check_rec(): disposition cannot be null.');
   end if;
   if player_id is null then
      raise_application_error(-20004, 'pcard_actions_tab.check_rec(): player_id cannot be null.');
   end if;
   if action_id is null then
      raise_application_error(-20004, 'pcard_actions_tab.check_rec(): action_id cannot be null.');
   end if;
   -- 3) Sub-type NULL checks
   -- 4) Compress Spaces, as needed
   -- 5) Custom Data Handling
   -- 6) Fold the case, as needed
   if util.get_fold_strings then
      disposition := upper(disposition);
   else
      if disposition is not null
      then
         if disposition != upper(disposition) then
            raise_application_error(-20003, 'pcard_actions_tab.check_rec(): disposition must be upper case.');
         end if;
      end if;
   end if;
   -- 7) Check for Domain Values
   if disposition is not null
      and not Dispositions_dom.includes(disposition)
   then
      raise_application_error(-20005, 'pcard_actions_tab.check_rec(): disposition must be one of ("HREV", "LREV", "LPAS", "HDED", "LELT", "LELP").');
   end if;
   -- 8) Custom Constraint Checks
   -- These constraints must be written to account for sub-types
   -- 9) Set eff_beg_dtm, if needed
   -- 10) Set aud_beg_usr and aud_beg_dtm
end check_rec;
----------------------------------------
-- Check Constraints for a pcard_actions Record
function rec_status
      (id_in  in NUMBER
      )  return varchar2
is
   fs_save    boolean  := util.get_fold_strings;
   ud_save    boolean  := util.get_use_defaults;
   old_tab  pcard_actions%ROWTYPE;
   new_tab  pcard_actions%ROWTYPE;
begin
   select * into old_tab from pcard_actions where id = id_in;
   new_tab := old_tab;
   util.set_fold_strings(FALSE);
   util.set_use_defaults(FALSE);
   check_rec (id  =>  new_tab.id
             ,card_id  =>  new_tab.card_id
             ,disposition  =>  new_tab.disposition
             ,player_id  =>  new_tab.player_id
             ,action_id  =>  new_tab.action_id
             );
   if not util.is_equal(old_tab.id, new_tab.id) then
      return 'Data Storage Error on id';
   end if;
   if not util.is_equal(old_tab.card_id, new_tab.card_id) then
      return 'Data Storage Error on card_id';
   end if;
   if not util.is_equal(old_tab.disposition, new_tab.disposition) then
      return 'Data Storage Error on disposition';
   end if;
   if not util.is_equal(old_tab.player_id, new_tab.player_id) then
      return 'Data Storage Error on player_id';
   end if;
   if not util.is_equal(old_tab.action_id, new_tab.action_id) then
      return 'Data Storage Error on action_id';
   end if;
   util.set_use_defaults(ud_save);
   util.set_fold_strings(fs_save);
   return 'OK';
exception
   when others then
      util.set_use_defaults(ud_save);
      util.set_fold_strings(fs_save);
      return sqlerrm;
end rec_status;
----------------------------------------
function get_id
      (pcard_actions_nk1  in  VARCHAR2
      ,pcard_actions_nk2  in  VARCHAR2
      ,pcard_actions_nk3  in  VARCHAR2
      ,pcard_actions_nk4  in  VARCHAR2
      ,pcard_actions_nk5  in  VARCHAR2
      ,pcard_actions_nk6  in  VARCHAR2
      ,pcard_actions_nk7  in  VARCHAR2
      ,pcard_actions_nk8  in  VARCHAR2
      ,pcard_actions_nk9  in  VARCHAR2
      ,pcard_actions_nk10  in  VARCHAR2
      ,pcard_actions_nk11  in  NUMBER
      ) return NUMBER
   -- For all the Natural Key Columns, Return an ID
is
   retid  NUMBER(38);
begin
   select id
    into  retid
    from  pcard_actions  PCA
    where PCA.card_id = cards_tab.get_id
             (pcard_actions_nk1
             ,pcard_actions_nk2
             ,pcard_actions_nk3
             )
     and  PCA.disposition = pcard_actions_nk4
     and  PCA.player_id = players_tab.get_id
             (pcard_actions_nk5
             ,pcard_actions_nk6
             ,pcard_actions_nk7
             )
     and  PCA.action_id = actions_tab.get_id
             (pcard_actions_nk8
             ,pcard_actions_nk9
             ,pcard_actions_nk10
             ,pcard_actions_nk11
             )
    ;
   return retid;
exception when no_data_found then return null;
end get_id;
----------------------------------------
function get_nk
      (id_in  in  NUMBER)
   return VARCHAR2
   -- For an ID, return a delimited list of Natural Key Values
is
   rtxt  VARCHAR2(4000);
begin
   select substr(   cards_tab.get_nk(PCA.card_id)
    || util.nk_sep || PCA.disposition
    || util.nk_sep || players_tab.get_nk(PCA.player_id)
    || util.nk_sep || actions_tab.get_nk(PCA.action_id)
                         ,1 ,4000)
    into  rtxt
    from  pcard_actions PCA
    where PCA.id = id_in;
   return rtxt;
exception when no_data_found then return null;
end get_nk;
----------------------------------------
-- Should be called exclusively by the BI Trigger
--   or the "ins" procedure below
procedure ins_bi_trigger
      (n_id  in out nocopy  NUMBER
      ,n_card_id  in out nocopy  NUMBER
      ,n_disposition  in out nocopy  VARCHAR2
      ,n_player_id  in out nocopy  NUMBER
      ,n_action_id  in out nocopy  NUMBER
      )
is
begin
   -- BI Trigger will have run_tab = TRUE, otherwise FALSE
   -- Set n_id, if needed
   if n_id is null then
      select pcard_actions_seq.nextval
       into  n_id from dual;
   elsif n_id = 0 then
      raise_application_error(-20019, 'ID of zero is not allowed');
   end if;
   check_rec (id  =>  n_id
             ,card_id  =>  n_card_id
             ,disposition  =>  n_disposition
             ,player_id  =>  n_player_id
             ,action_id  =>  n_action_id
             );
end ins_bi_trigger;
----------------------------------------
-- Can be called from anywhere, except the BI Trigger
procedure ins
      (n_rec  in out nocopy  pcard_actions%ROWTYPE
      )
is
begin
   run_tab := FALSE;
   ins_bi_trigger (n_id  =>  n_rec.id
       ,n_card_id  =>  n_rec.card_id
       ,n_disposition  =>  n_rec.disposition
       ,n_player_id  =>  n_rec.player_id
       ,n_action_id  =>  n_rec.action_id
       );
   insert into pcard_actions
         (id
         ,card_id
         ,disposition
         ,player_id
         ,action_id
         )
   values
         (n_rec.id
         ,n_rec.card_id
         ,n_rec.disposition
         ,n_rec.player_id
         ,n_rec.action_id
         );
   run_tab := TRUE;
exception
   when others then
      run_tab := TRUE;
      raise;
end ins;
----------------------------------------
-- Should be called exclusively by the BU Trigger
--   or the "upd" procedure below
-- Note: the OLD values must be provided to check ignore_no_change
-- Note2:  Select for Update Lock is assumed on old values row
procedure upd_bu_trigger
      (o_id  in  NUMBER
      ,o_card_id  in  NUMBER
      ,n_card_id  in out nocopy  NUMBER
      ,o_disposition  in  VARCHAR2
      ,n_disposition  in out nocopy  VARCHAR2
      ,o_player_id  in  NUMBER
      ,n_player_id  in out nocopy  NUMBER
      ,o_action_id  in  NUMBER
      ,n_action_id  in out nocopy  NUMBER
      ,run_update  out  boolean
      )
is
begin
   run_update := TRUE;
   -- BU Trigger will have run_tab = TRUE, otherwise FALSE
   if     o_card_id = n_card_id
     and  o_disposition = n_disposition
     and  o_player_id = n_player_id
     and  o_action_id = n_action_id
   then
      if util.get_ignore_no_change then
         run_update := FALSE;
         return;
      end if;
      raise_application_error(-20008, 'pcard_actions_tab.upd(): Must update one of'
            || ' card_id'
            || ', disposition'
            || ', player_id'
            || ', action_id'
            || '.');
   end if;
   check_rec (id  =>  o_id
             ,card_id  =>  n_card_id
             ,disposition  =>  n_disposition
             ,player_id  =>  n_player_id
             ,action_id  =>  n_action_id
             );
end upd_bu_trigger;
----------------------------------------
-- Can be called from anywhere, except the BU Trigger
-- Note: the OLD values must be provided to set new_rec values
procedure upd
      (o_rec  in             pcard_actions%ROWTYPE
      ,n_rec  in out nocopy  pcard_actions%ROWTYPE
      )
is
   c_rec    pcard_actions%ROWTYPE;  -- Current Row Data
   run_upd  boolean;
begin
   if o_rec.id is null then return; end if;
   run_tab := FALSE;
   select * into c_rec from pcard_actions t1
    where t1.id = o_rec.id FOR UPDATE;
   -- If old and new match, then replace new with current
   --   because there was no original intent to change new
   if o_rec.card_id = n_rec.card_id then
      n_rec.card_id := c_rec.card_id;
   end if;
   if o_rec.disposition = n_rec.disposition then
      n_rec.disposition := c_rec.disposition;
   end if;
   if o_rec.player_id = n_rec.player_id then
      n_rec.player_id := c_rec.player_id;
   end if;
   if o_rec.action_id = n_rec.action_id then
      n_rec.action_id := c_rec.action_id;
   end if;
   -- Update the new data based on the current data
   upd_bu_trigger (o_id  =>  c_rec.id
      ,o_card_id  =>  c_rec.card_id
      ,n_card_id  =>  n_rec.card_id
      ,o_disposition  =>  c_rec.disposition
      ,n_disposition  =>  n_rec.disposition
      ,o_player_id  =>  c_rec.player_id
      ,n_player_id  =>  n_rec.player_id
      ,o_action_id  =>  c_rec.action_id
      ,n_action_id  =>  n_rec.action_id
      ,run_update  =>  run_upd
      );
   if run_upd then
      update pcard_actions
        set  card_id = n_rec.card_id
            ,disposition = n_rec.disposition
            ,player_id = n_rec.player_id
            ,action_id = n_rec.action_id
       where id = o_rec.id;
   end if;
   run_tab := TRUE;
exception
   when others then
      run_tab := TRUE;
      raise;
end upd;
----------------------------------------
-- Can be called from anywhere, except the BU Trigger
-- Note: the OLD values must be provided to check ignore_no_change
procedure upd
      (n_rec  in out nocopy  pcard_actions%ROWTYPE
      )
is
   c_rec    pcard_actions%ROWTYPE;  -- Current Row Data
   run_upd  boolean;
begin
   if n_rec.id is null then return; end if;
   run_tab := FALSE;
   select * into c_rec from pcard_actions t1
    where t1.id = n_rec.id FOR UPDATE;
   upd_bu_trigger (o_id  =>  c_rec.id
      ,o_card_id  =>  c_rec.card_id
      ,n_card_id  =>  n_rec.card_id
      ,o_disposition  =>  c_rec.disposition
      ,n_disposition  =>  n_rec.disposition
      ,o_player_id  =>  c_rec.player_id
      ,n_player_id  =>  n_rec.player_id
      ,o_action_id  =>  c_rec.action_id
      ,n_action_id  =>  n_rec.action_id
      ,run_update  =>  run_upd
      );
   if run_upd then
      update pcard_actions
        set  card_id = n_rec.card_id
            ,disposition = n_rec.disposition
            ,player_id = n_rec.player_id
            ,action_id = n_rec.action_id
       where id = c_rec.id;
   end if;
   run_tab := TRUE;
exception
   when others then
      run_tab := TRUE;
      raise;
end upd;
----------------------------------------
-- There is no delete trigger for this table
----------------------------------------
-- Can be called from anywhere, except the BD Trigger
procedure del
      (o_id  in  NUMBER
      )
is
begin
   -- NOTE: there is no delete trigger for this table
   if o_id is null then return; end if;
   run_tab := FALSE;
   delete from pcard_actions PCA
    where PCA.id = o_id;
   run_tab := TRUE;
end del;
----------------------------------------
end pcard_actions_tab;
/
select 'PCARD_ACTIONS_TAB' as "Package Body:"
 from  user_errors
 where name  = 'PCARD_ACTIONS_TAB'
  and  type  = 'PACKAGE BODY'
  and  rownum = 1
/
select '('||line||'/'||position||') '||text as error
 from  user_errors
 where name = 'PCARD_ACTIONS_TAB'
  and  type = 'PACKAGE BODY'
 order by sequence
/

