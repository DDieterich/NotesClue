
select '=== CLUE create_util ===' as SCRIPT_NAME from dual;

-- Script File "create_util"
--    Create Utilities using generated code

   -- Application: Clue Notes For Oracle
   -- Generated by DTGen (http://dmstex.com/services/dtgen)
   -- December  16, 2013  11:32:28 AM

   --
   --
   -- © Duane.Dieterich@DMSTEX.com 2013
   --
   -- All Rights Reserved
   --
   -- No part of this software may be reproduced, copied, modified or adapted,
   -- without the prior written consent of the author, unless otherwise
   -- indicated for stand-alone materials.
   --
   -- You may quote extracts from this software with attribution to
   -- Duane.Dieterich@DMSTEX.com
   --
   -- For any other mode of sharing, please contact Duane.Dieterich@DMSTEX.com.
   --
   -- Commercial use and distribution of this software is not allowed without
   -- express and prior written consent of the author.
   --
   -- THE SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
   -- INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY
   -- AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL
   -- THE COPYRIGHT HOLDER OR DMSTEX BUSINESS SOLUTIONS LLC, ITS MEMBERS,
   -- MANAGERS, OR EMPLOYEES BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
   -- SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
   -- TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
   -- PROFITS; CORRUPTION OF DATA, OR BUSINESS INTERRUPTION) HOWEVER CAUSED
   -- AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
   -- OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF
   -- THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH
   -- DAMAGE.
   --
   --



-- Table of debug and error messages.
create table util_log
   (dtm              timestamp with local time zone
   ,usr              VARCHAR2(30)
   ,sid              number
   ,txt              varchar2(4000)
   ,loc              varchar2(2000))
/

create index util_log_ix1 on util_log (dtm, usr)
/

comment on table util_log is 'Error and Debug Messages'
/

comment on column util_log.dtm is 'System time when message was logged'
/
comment on column util_log.usr is 'Username for Auditing'
/
comment on column util_log.sid is 'Database Session ID'
/
comment on column util_log.txt is 'Error or Debug message text'
/
comment on column util_log.loc is 'Location in the source code where the message was logged'
/

-- Table of Trace Triggers.  Also creates a IOT
create table util_trc
   (loc  varchar2(1000)
   ,txt  varchar2(2000)
   ,usr  VARCHAR2(30)
   ,sid  number
   ,constraint util_trc_pk primary key (loc, txt, usr, sid))
   organization index
   overflow storage (initial 4k)
   -- Overflow Storage is created as a SYS_IOT table by the database
/

comment on table util_trc is 'Trace Triggers'
/

comment on column util_trc.loc is 'Search string for the location in the source code where the message was logged'
/
comment on column util_trc.txt is 'Search string for the error or debug message text'
/
comment on column util_trc.usr is 'Search string for the username for auditing'
/
comment on column util_trc.sid is 'Matching Database Session ID'
/

-- Table of Name-Value Pairs.  Also creates a IOT
create table util_nvp
   (name         varchar2(30)
   ,value        varchar2(4000)
   ,description  varchar2(1000) default null
   ,constraint util_nvp_pk primary key (name))
   organization index
   overflow storage (initial 4k)
   -- Overflow Storage is created as a SYS_IOT table by the database
/

comment on table util_nvp is 'Name-Value Pairs Table for System Parameters'
/

comment on column util_nvp.name is 'Name for Name-Value Pair'
/
comment on column util_nvp.value is 'Value for Name-Value Pair'
/
comment on column util_nvp.description is 'Description for Name-Value Pair'
/

CREATE package util
is

   -- Package Util
   --    Utility settings and functions

   -- Application: Clue Notes For Oracle
   -- Generated by DTGen (http://dmstex.com/services/dtgen)
   -- December  16, 2013  11:32:28 AM

   --
   --
   -- © Duane.Dieterich@DMSTEX.com 2013
   --
   -- All Rights Reserved
   --
   -- No part of this software may be reproduced, copied, modified or adapted,
   -- without the prior written consent of the author, unless otherwise
   -- indicated for stand-alone materials.
   --
   -- You may quote extracts from this software with attribution to
   -- Duane.Dieterich@DMSTEX.com
   --
   -- For any other mode of sharing, please contact Duane.Dieterich@DMSTEX.com.
   --
   -- Commercial use and distribution of this software is not allowed without
   -- express and prior written consent of the author.
   --
   -- THE SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
   -- INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY
   -- AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL
   -- THE COPYRIGHT HOLDER OR DMSTEX BUSINESS SOLUTIONS LLC, ITS MEMBERS,
   -- MANAGERS, OR EMPLOYEES BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
   -- SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
   -- TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
   -- PROFITS; CORRUPTION OF DATA, OR BUSINESS INTERRUPTION) HOWEVER CAUSED
   -- AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
   -- OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF
   -- THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH
   -- DAMAGE.
   --
   --


   -- Application Version
   version    constant varchar2(10) := '1.0';

   -- Generated Application Exceptions:
   ------------
   --   Error: ORA-20001, gen_no_dml_tv
   -- Message: %s trigger: %s is not allowed on this table/view.
   --   Cause: An attempt was made to insert/update/delete data on a table/view that does not allow this action.
   --  Action: Retry the insert/update/delete on a transactional view (name ends with "_ACT").
   ------------
   --   Error: ORA-20002, gen_no_user
   -- Message: Current user has not been set in the %s Package.
   --   Cause: A call to UTIL.GET_USR was made before a call to UTIL.SET_USR gave a value for the username.
   --  Action: Set the username by calling UTIL.SET_USR with a valid value.
   ------------
   --   Error: ORA-20003, gen_bad_case
   -- Message: %s.check_rec(): %s must be %s case.
   --   Cause: The letter case of a string has failed to meet the requirement listed.
   --  Action: Modifiy the string to conform to the letter case requirement.
   ------------
   --   Error: ORA-20004, gen_null_found
   -- Message: %s.check_rec(): %s cannot be null.
   --   Cause: The data item cannot be null.
   --  Action: Provide a value for this data item.
   ------------
   --   Error: ORA-20005, gen_not_in
   -- Message: %s.check_rec(): %s must be one of (%s).
   --   Cause: The data item does not have a value from the list provided.
   --  Action: Provide a value from the list for the this data item.
   ------------
   --   Error: ORA-20006, gen_cust_cons
   -- Message: %s.check_rec(): %s
   --   Cause: Custom Constraint
   --  Action: Comply with Constraint
   ------------
   --   Error: ORA-20007, gen_future_date
   -- Message: %s.check_rec(): %s cannot be in the future.
   --   Cause: The data item cannot have a date value that is in the future.
   --  Action: Change the date value of the data item to an earlier date/time.
   ------------
   --   Error: ORA-20008, gen_no_change
   -- Message: %s.upd(): Must update one of %s.
   --   Cause: An attempt was made to update data in a table, but the minimum requirement to change one data value was not met (EFF_BEG_DTM is not considered a data value).
   --  Action: Modify the data value of another data item before attempting the update.
   ------------
   --   Error: ORA-20009, gen_early_date
   -- Message: %s.%s(): The new %s date must be greater than %s
   --   Cause: The new date value of the data item precedes its previous value.
   --  Action: Ensure the new data value for the data occurs after its current date/time value.
   ------------
   --   Error: ORA-20010, gen_mv_dml
   -- Message: %s not allowed on materialized view %s
   --   Cause: Data Modification Language (Insert, Update, or Delete) cannot be performed on a Materialized View.
   --  Action: Attempt the Data Modification Language (DML) on the database node instead of a Mid-Tier node.
   ------------
   --   Error: ORA-20011, gen_apex_nfnd
   -- Message: APEX: Unable to find %s
   --   Cause: APEX data was not found during an import.
   --  Action: Import parameter values could be incorrect, or APEX has not been properly loaded on target system.
   ------------
   --   Error: ORA-20012, gen_apex_init
   -- Message: APEX: %s is null.
   --   Cause: Initialization data was not found during an APEX import.
   --  Action: Initialization values could be incorrect, or APEX has not been properly loaded on target system.
   ------------
   --   Error: ORA-20013, gen_many_updates
   -- Message: GEN_MRU updated %i rows for ID %i
   --   Cause: Generated Multi-Row Update updated more than 1 row for a given ID
   --  Action: Correct the duplicate primary key ID.
   ------------
   --   Error: ORA-20014, gen_no_tempcon
   -- Message: %s temporal discontinuity at %s for ID %i
   --   Cause: An attempt was made to insert/update a record with a foreign key that lacks temporal continuity from the given EFF_BEG_DTM
   --  Action: Use an EFF_BEG_DTM that is later
   ------------
   --   Error: ORA-20015, gen_no_eff_fk
   -- Message: Unable to find %s FK for beg_dtm %s of ID %i
   --   Cause: An attempt was made to insert/update a record with a foreign key that doesn''t exist for the given EFF_BEG_DTM
   --  Action: Create the needed Foreign Key record and/or use an EFF_BEG_DTM that is later
   ------------
   --   Error: ORA-20016, gen_dup_tempcon
   -- Message: Duplicate %s NK/UK Data found at %s for ID %i
   --   Cause: An attempt was made to insert/update with duplicate historical data
   --  Action: Use an EFF_BEG_DTM that is later
   ------------
   --   Error: ORA-20017, gen_fk_violation
   -- Message: Foreign Key Violation, %s(%i) not found
   --   Cause: An attempt was made to insert/update a record with a foreign key that is not in the ACTIVE table
   --  Action: Create the foreign key data or change the foreign key reference
   ------------
   --   Error: ORA-20018, gen_child_exists
   -- Message: %s.ID %i child record exists
   --   Cause: An attempt was made to delete a parent record with an existing child record
   --  Action: Remove the child record and retry with a later eff_end_dtm
   ------------
   --   Error: ORA-20019, gen_invalid_0_id
   -- Message: ID of zero is not allowed
   --   Cause: An attempt was made to set an ID to zero.
   --  Action: Negative values are allowed for IDs and will not conflict with the sequence generator
   ------------
   --   Error: ORA-20020, gen_null_id_ret
   -- Message: Null ID was returned from %s
   --   Cause: An attempt to insert/update a foreign key with a natural key or path returned a null ID.
   --  Action: Retry with corrected natural key or path values
   ------------
   --   Error: ORA-20021, gen_dup_id
   -- Message: ID %i has already been used
   --   Cause: An attempt to insert record with an ID that has been used before.
   --  Action: Insert the record with no ID, use a different ID, or "POP" this ID.
   ------------
   --   Error: ORA-20022, gen_extra_wspace
   -- Message: %s.check_rec(): %s cannot have extra whitespace characters.
   --   Cause: Spaces, Tabs, and other whitespace cannot be in front of or behind that data in this column.  Also, consecutive whitespace characters are not allowed.
   --  Action: Remove the extra whitespace characters from the data
   ------------
   --   Error: ORA-20023, gen_null_id
   -- Message: ID is null and could not be found from Natural Keys
   --   Cause: An attempt to update/delete/pop a record with a null ID that could not be found using Natural Key(s'') and/or Natural Key ID(s) lookup.
   --  Action: Retry with a valid ID, valid Natural Key(s), or valid Natural Key ID(s)
   ------------
   --   Error: ORA-20024, gen_st_mismatch
   -- Message: %s.check_rec(): sub_type%i of %s requires a sub_type%i of %s.
   --   Cause: An attempt was made to set a sub-type without the proper parent sub-type
   --  Action: Provide the correct sub-type and parent sub-type.
   ------------
   --   Error: ORA-20025, gen_st_not_found
   -- Message: %s.check_rec(): %_sub_type must be one of %s
   --   Cause: The sub_type value was not one of the listed values.
   --  Action: Provide a valid value for this data item.
   ------------
   --   Error: ORA-20026, gen_st_nn_found
   -- Message: %s.check_rec(): %s must be null for sub_type%.
   --   Cause: The data item must be null for the specified sub-type.
   --  Action: Remove (make NULL) the value for this data item.
   ------------
   --   Error: ORA-20027, gen_mutating_tab
   -- Message: ORA-04091: Mutating Table Error.  Try using %_DML package instead
   --   Cause: An attempt was made to run an SQL statement with a trigger that includes a function that queries other records in the same table
   --  Action: Retry the equivalent SQL using one of the procedures in the DML package instead
   ------------
   --   Error: ORA-20028, gen_st_null_found
   -- Message: %s.check_rec(): %s cannot be null for sub_type%.
   --   Cause: The data item is required for the specified sub-type.
   --  Action: Provide a value for this data item.
   ------------
   --   Error: ORA-20029, gen_xml_too_long
   -- Message: %s.check_rec(): dbms_lob.getlength(xmltype.getclobval(%s)) cannot be longer than $s.
   --   Cause: The data length for this XMLTYPE column is too long.
   --  Action: Try again with shorter XMLTYPE data.
   ------------
   --   Error: ORA-20030, gen_utc_lock_err
   -- Message: %s.check_unique_tc(): Lock Error=%s, Lock Handle=%s, Lock Name=%s
   --   Cause: An attempt to create and acquire a Unique Key Temporal Continuity Lock failed.
   --  Action:

   -------------------------------------------------
   -- Generated ORA-20006 Exception Descriptions:
   --  %s.check_rec(): Action Sequence number must be greater than zero
   --  %s.check_rec(): Number of Total Cards for a Player must be greater than or equal to zero
   --  %s.check_rec(): Number of Last Actions to Display must be greater than or equal to zero
   --  %s.check_rec(): Resolved Suggestions must have a Resolved Action ID
   --  %s.check_rec(): Unresolved Actions cannot have a Resolved Action ID
   -------------------------------------------------

   /*************************************************************
   Generated Database Object Column Names and Column Suffixes
     (* - Alphanumeric wildcard)
   -------------------------------------------------
   *_AFC            - APEX File Character Set
   *_AFD            - APEX File Section 508 Description
   *_AFM            - APEX File MIME Type
   *_AFN            - APEX File Name
   *_AFT            - APEX File Last Update Date/Time
   *_ID             - Surrogate Key Portion of a Primary Key
   *_SUB_TYPE       - Table/Entity Subtype Indicator
   AUD_BEG_DTM      - Audit Start/Begin Date/Time
   AUD_BEG_USR      - Audit Start/Begin User Identifier
   AUD_END_DTM      - Audit Finish/End Date/Time
   AUD_END_USR      - Audit Finish/End User Identifier
   AUD_PREV_BEG_DTM - Date/Time the previous record version was modified
   AUD_PREV_BEG_USR - User Identifier that modified the previous record version
   EFF_BEG_DTM      - Date/Time a record became effective
   EFF_END_DTM      - Date/Time a record was no longer effective
   EFF_PREV_BEG_DTM - Date/Time the previous record version was effective
   ID               - Surrogate Primary Key
   LAST_ACTIVE      - Indicates a record was deleted from active
   POP_DML          - Original DML of a record that was popped
   POP_DTM          - Date/Time a record was popped
   POP_USR          - User Identifier that popped a record
   STAT             - Record Status
   *_SRID           - GEO Location System Reference ID
   *_XCRD           - GEO Location Point X Coordinate (Longitude)
   *_YCRD           - GEO Location Point Y Coordinate (Latitude)
   *************************************************************
   Generated Database Object Suffixes (? - One or More Numeric Digits):
     Note: Oracle Namespace Numbers for Database Objects are also listed.
     Oracle® Database SQL Language Reference 11g Release 2 (11.2)
     Database Object Naming Rules, 8. Within a namespace, no two objects can have the same name.
   -------------------------------------------------
   _A     - (NS1) Active View Self-Reference Helper Package
   _ACT   - (NS1) Active View
   _ALL   - (NS1) All View
   _ASOF  - (NS1) ASOF View
   _AU?   - (NS?) Audit Constraint
   _B??   - (NS8) Binary LOB
   _BD    - (NS3) Before Delete Trigger
   _BI    - (NS3) Before Insert Trigger
   _BU    - (NS3) Before Update Trigger
   _C??   - (NS8) Character LOB
   _CLUS  - (NS5) Clustered Table Storage
   _DML   - (NS1) Data Manipulation Language (API) Package
   _DOBJ  - (NS1) Domain Object Type
   _DOM   - (NS1) Domain Package
   _DTAB  - (NS1) Domain Table Type
   _EF?   - (NS?) Effectivity Constraint
   _EFF   - (NS1) Effectivity Table
   _F     - (NS1) ASOF View Self-Reference Helper View
   _FA?   - (NS?) Foreign Key Audit Constraint
   _FK?   - (NS?) Foreign Key Constraint
   _FX?   - (NS4) Foreign Key Index
   _G?    - (NS1) Geo Spatial Element Info LOB
   _IA?   - (NS4) Audit Index
   _ICL   - (NS4) Cluster Index
   _IOD   - (NS3) Instead of Delete Trigger
   _IOI   - (NS3) Instead of Insert Trigger
   _IOU   - (NS3) Instead of Update Trigger
   _IT?   - (NS4) Effectivity Index
   _IX?   - (NS4) Custom Index
   _L     - (NS1) All View Self-Reference Helper View
   _LA    - (NS4) Last Active Index
   _LA?   - (NS?) Last Active Constraint
   _LOG   - (NS1) Audit Log Table
   _PK    - (NS4) Primary Key Index
   _NK?   - (NS4) Natural Key Index
   _NN?   - (NS?) Not Null Constraint
   _NNH?  - (NS?) Not Null Constraint on EFF/LOG Data
   _NNP?  - (NS?) Not Null Constraint on POP Data
   _O?    - (NS1) Geo Spatial Ordinates LOB
   _OID   - (NS4) OMNI View ID Function-Based Index
   _OMNU  - (NS1) OMNI View
   _POP   - (NS1) POP/UNDO Audit Table
   _S?    - (NS4) Spatial Index
   _SEQ   - (NS1) Sequence
   _SH    - (NS1) Self-Reference Helper Package
   _TAB   - (NS1) Table Package
   _UX?   - (NS4) Custom Unique Index
   _VOBJ  - (NS1) Active View (Virtual) Object Type
   _VTAB  - (NS1) Active View (Virtual) Table Type
   _X?    - (NS8) XMLTYPE LOB
   *************************************************************
   Database Assigned Object Prefixes:
   ----------------------------------
   MDRS_         - SDO_GEOMETRY Sequence
   MDRT_         - SDO_GEOMETRY Table
   SYS_IL$$      - Large Object Index
   SYS_IOT_OVER_ - Index Organized Table (Table Segment)
   SYS_LOB       - Segment Name for "MDRS_" SDO_GEOMETRY Table
   *************************************************************
   Generated APEX Object Suffixes:
   -------------------------------
   _32K               - Full XML Document (always 32K or less)
   _asof_reports      - Navigation Lists
   _ASOF_TS           - Tab Sets
   _DOM_LOV           - Domain List Of Values (Static and Dynamic)
                      -   Note: Some DTGEN Domains are used
   _DISP              - Native Image Display Column in Form
   EDIT               - IR Link Column Name
   _FORM_TS           - Tab Sets
   _LOV               - Foreign Key List Of Values (Dynamic)
   _MAINT_TS          - Tab Sets
   _maintenance_forms - Navigation Lists
   _omni_reports      - Navigation Lists
   _OMNI_TS           - Tab Sets
   _PREV              - XML Document Preview (up to 200 characters)
   _SRID              - Geo-coordinate System Reference ID
   _ST_LOV            - Sub-Type List Of Values (Static)
   _XCRD              - Geo-coordinate System X Coordinate
   _YCRD              - Geo-coordinate System Y Coordinate
   *************************************************************
   APEX LOVs that are based on data outside of application:
   --------------------------------------------------------
   ZZES_DOM_LOV - "STAT" Column Values in an Effectivity Table View
   ZZLA_DOM_LOV - "LAST_ACTIVE" Column Value in an "_ALL" View
   ZZLS_DOM_LOV - "STAT" Column Values in a Logging Table View
   ZZPD_DOM_LOV - "POP_DML" Column Values in a "_POP" Table
   ZZSR_DOM_LOV - GEO Location Coordinate System Reference IDs
   *************************************************************/

   -- Defalt min/max date/time values
   first_dtm  constant timestamp with time zone :=
        to_timestamp_tz('0001-01-01 00:00:00 UTC','YYYY-MM-DD HH24:MI:SS TZR');
   last_dtm   constant timestamp with time zone :=
        to_timestamp_tz('9999-12-31 23:59:59 UTC','YYYY-MM-DD HH24:MI:SS TZR');

   -- Separates values within a set of Natural Keys
   nk_sep  varchar2(1) := ',';
   -- Separates values in a path hierarchy
   path_sep  varchar2(1) := ':';

   -- Indicates whether to fold strings or return an error
   --   TRUE - Change string data to required case
   --   FALSE - Check string data for require case (and return error)
   fold_strings          boolean := true;

   -- Indicates whether to compress spaces in a string or return an error
   --   TRUE - Remove leading and trailing spaces, reduce multiple spaces to 1
   --   FALSE - Check string data extra spaces (and return error)
   compress_spaces       boolean := true;

   -- Centralized date/time for ASOF views
   asof_dtm              timestamp with time zone;

   -- Indicates whether to return an error if an UPDATE is called with no data changes
   --   TRUE - gen_no_change error is ignored during UPDATE
   --   FALSE - gen_no_change error is enforced during UPDATE
   ignore_no_change      boolean := true;

   -- Indicates whether to enforce temporal continuity on foreign keys
   -- WARNING: Disabling temporal continuity disables time based referential integrity
   temporal_continuity   boolean := true;

   -- Indicates whether to use the default value provided for a column
   --   TRUE - default value for column is used during INSERT and UPDATE
   --   FALSE - no default value is used during INSERT and UPDATE
   use_defaults          boolean := true;

   -- Indicates whether to include hex or decimal encodings of unknown
   --       ASCII characters when using the "ascii_conv" function
   --   TRUE - no hex or decimal encodings
   --   FALSE - unknown characters are hex or decimal encoded in output
   include_unknown_ascii  boolean := FALSE;

   -- Indicates whether to set columns outside of the sub-type to
   --       NULL if those columns have values
   --   TRUE - set columns to NULL
   --   FALSE - detect values and throw an error
   fix_non_null_sub_types  boolean := FALSE;

   -- Current Source Code Version
   function get_version
      return varchar2;

   -- Defalt min/max date/time values
   function get_first_dtm
      return timestamp with time zone;
   function get_last_dtm
      return timestamp with time zone;

   -- Centralized Current date/time
   function get_dtm
      return timestamp with local time zone;

   -- Centralized date/time for ASOF views
   procedure set_asof_dtm
         (asof_dtm_in  in  timestamp with time zone);
   function get_asof_dtm
      return timestamp with time zone;

   -- Current User for Audit
   procedure set_usr
         (usr_in  in  VARCHAR2);
   function get_usr
      return VARCHAR2;

   -- Separates values within a set of Natural Keys
   procedure set_nk_sep
         (nk_sep_in  in  varchar2);
   function get_nk_sep
      return varchar2;

   -- Hierarchial Path Seperator
   procedure set_path_sep
         (path_sep_in  in  varchar2);
   function get_path_sep
      return varchar2;

   -- Indicates whether to fold strings or return an error
   procedure set_fold_strings
      (bool_in  in  boolean);
   function get_fold_strings
      return boolean;

   -- Indicates whether to compress spaces in a string or return an error
   procedure set_compress_spaces
      (bool_in  in  boolean);
   function get_compress_spaces
      return boolean;

   -- Indicates whether to return an error if an UPDATE is called with no data changes
   procedure set_ignore_no_change
      (bool_in  in  boolean);
   function get_ignore_no_change
      return boolean;

   -- Indicates whether to enforce temporal continuity on foreign keys
   procedure set_temporal_continuity
      (bool_in  in  boolean);
   function get_temporal_continuity
      return boolean;

   -- Indicates whether to use the default value provided for a column
   procedure set_use_defaults
      (bool_in  in  boolean);
   function get_use_defaults
      return boolean;

   -- Indicates whether to include hex or decimal encodings
   procedure set_include_unknown_ascii
      (bool_in  in  boolean);
   function get_include_unknown_ascii
      return boolean;

   -- Indicates whether to set columns to NULL
   procedure set_fix_non_null_sub_types
      (bool_in  in  boolean);
   function get_fix_non_null_sub_types
      return boolean;

   -- Centralized function GLOBAL lock handles
   function allocate_lock
         (lockname_in  in  varchar2
         ,exp_secs_in  in  number  default 43200)
      return varchar2;
   -- Centralized Multi-locks, used for Unique Key Temporal Continuity Constraints
   function get_multi_lock
         (lhandle_in  in  varchar2
         ,timeout_in  in  INTEGER  default DBMS_LOCK.MAXWAIT)
      return varchar2;

   -- Centralized procedures GLOBAL locks
   function request_lock
         (lockname_in  in  varchar2
         ,timeout_in   in  INTEGER  default null)
      return varchar2;
   function release_lock
      return varchar2;

   -- Wait/Delay Procedure, Default is 10 milliseconds
   procedure wait
         (seconds_in  in  number default null);

   -- Comparison with NULL handling
   function is_equal
         (t1_in  in  varchar2
         ,t2_in  in  varchar2
         ) return boolean;
   function is_equal
         (n1_in  in  number
         ,n2_in  in  number
         ) return boolean;
   function is_equal
         (b1_in  in  blob
         ,b2_in  in  blob
         )  return boolean;
   function is_equal
         (x1_in  in  xmltype
         ,x2_in  in  xmltype
         ) return boolean;
   function is_equal
      (g1_in   in  sdo_geometry
      ,g2_in   in  sdo_geometry
      ,tol_in  in  number default 0.05
      )  return boolean;

   -- Boolean Conversion Functions
   -- NOTE: These functions will not work in SQL statements
   --      "ORA-06553: PLS-382: expression is of wrong type"
   function conv_bool
         (str_in  in  varchar2
         ) return boolean;
   function conv_bool
         (bool_in   in  boolean
         ,true_in   in  varchar2
         ,false_in  in  varchar2
         ) return varchar2;
   function conv_bool
         (bool_in   in  boolean
         ,true_in   in  number
         ,false_in  in  number
         ) return number;

   -- String Conversion Functions
   function ascii_conv
         (str_in  in  varchar2
         ) return varchar2;
   function comp_spc
         (str_in  in  varchar2
         ) return varchar2;

   -- Spatial Data Option Geometry Conversion Functions
   function get_srid
         (geo_in  in  sdo_geometry
         ) return number;
   function get_xcrd
         (geo_in  in  sdo_geometry
         ) return number;
   function get_ycrd
         (geo_in  in  sdo_geometry
         ) return number;
   function get_geom_2dpt
         (xcrd_in  in  number
         ,ycrd_in  in  number
         ,srid_in  in  number
         ) return sdo_geometry;

   -- Long Operations Logging Procedures
   procedure init_longops
         (opname_in       in  varchar2
         ,totalwork_in    in  number
         ,target_desc_in  in  varchar2
         ,units_in        in  varchar2);
   procedure add_longops
         (add_sofar_in  in  number);
   procedure end_longops;

   -- Logging, Tracing, and Error Procedures
   -- Example usage: log('This is my message');
   procedure log
         (txt_in  in  varchar2
         ,loc_in  in  varchar2 default null
         );
   -- Re-Check for trace keys
   procedure set_no_trace_keys;
   -- Example usage: trc($$PLSQL_UNIT || '1: value of ss', ss);
   procedure trc
         (key_in  in  varchar2
         ,txt_in  in  varchar2
         );
   -- Example usage: err(SQLERRM);
   procedure err
         (txt_in  in  varchar2
         );
   -- Example usage: trc_time_interval($$PLSQL_UNIT, start_tstamp);
   procedure trc_time_interval
         (key_in  in  varchar2
         ,tst_in  in  timestamp
         );

   -- Save a Name-Value Pair in the Database
   procedure set_nvp
         (name_in   in  varchar2
         ,value_in  in  varchar2
         ,descr_in  in  varchar2 default null
         );
   -- Retreive a Name-Value Pair from the Database
   function get_nvp
         (name_in  in  varchar2
         ) return varchar2;
   -- Clear a Name-Value Pair in the Database
   procedure clr_nvp
         (name_in   in  varchar2
         );

   -- Return the Special OMNI ID
   function get_omni_id
         (id_in   in  number
         ,key_in  in  number
         ,dtm_in  in  TIMESTAMP WITH LOCAL TIME ZONE
         ) return number deterministic;

end util;
/
select 'UTIL' as "Package:"
 from  user_errors
 where name  = 'UTIL'
  and  type  = 'PACKAGE'
  and  rownum = 1
/
select '('||line||'/'||position||') '||text as error
 from  user_errors
 where name = 'UTIL'
  and  type = 'PACKAGE'
 order by sequence
/

CREATE package body util
is

-- Package Body Util
--    Utility settings and functions

   -- Application: Clue Notes For Oracle
   -- Generated by DTGen (http://dmstex.com/services/dtgen)
   -- December  16, 2013  11:32:28 AM

   --
   --
   -- © Duane.Dieterich@DMSTEX.com 2013
   --
   -- All Rights Reserved
   --
   -- No part of this software may be reproduced, copied, modified or adapted,
   -- without the prior written consent of the author, unless otherwise
   -- indicated for stand-alone materials.
   --
   -- You may quote extracts from this software with attribution to
   -- Duane.Dieterich@DMSTEX.com
   --
   -- For any other mode of sharing, please contact Duane.Dieterich@DMSTEX.com.
   --
   -- Commercial use and distribution of this software is not allowed without
   -- express and prior written consent of the author.
   --
   -- THE SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
   -- INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY
   -- AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL
   -- THE COPYRIGHT HOLDER OR DMSTEX BUSINESS SOLUTIONS LLC, ITS MEMBERS,
   -- MANAGERS, OR EMPLOYEES BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
   -- SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
   -- TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
   -- PROFITS; CORRUPTION OF DATA, OR BUSINESS INTERRUPTION) HOWEVER CAUSED
   -- AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
   -- OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF
   -- THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH
   -- DAMAGE.
   --
   --


-- Current User for Audit
current_usr           VARCHAR2(30);
-- Indicates that trace output should be performed, when called
no_trace_keys         boolean := true;

st_lockhandle         varchar2(128);  -- Single Threaded DBMS_LOCK
st_lockname           varchar2(128);  -- Single Threaded DBMS_LOCK

lo_context      BINARY_INTEGER;  -- DBMS_APPLICATION.set_session_longops
lo_op_name      varchar2(64);    -- DBMS_APPLICATION.set_session_longops
lo_rindex       BINARY_INTEGER;  -- DBMS_APPLICATION.set_session_longops
lo_slno         BINARY_INTEGER;  -- DBMS_APPLICATION.set_session_longops
lo_sofar        number;          -- DBMS_APPLICATION.set_session_longops
lo_totalwork    number;          -- DBMS_APPLICATION.set_session_longops
lo_target       BINARY_INTEGER;  -- DBMS_APPLICATION.set_session_longops
lo_target_desc  varchar2(32);    -- DBMS_APPLICATION.set_session_longops
lo_units        varchar2(32);    -- DBMS_APPLICATION.set_session_longops

----------------------------------------
-- Current Source Code Version
function get_version
   return varchar2
is
begin
   return version;
end get_version;
----------------------------------------
-- Defalt min/max date/time values
function get_first_dtm
   return timestamp with time zone
is
begin
   return first_dtm;
end get_first_dtm;
----------------------------------------
-- Defalt min/max date/time values
function get_last_dtm
      return timestamp with time zone
is
begin
   return last_dtm;
end get_last_dtm;
----------------------------------------
-- Centralized Current date/time
function get_dtm
      return timestamp with local time zone
is
begin
   return systimestamp;
end get_dtm;
----------------------------------------
-- Centralized date/time for ASOF views
procedure set_asof_dtm
      (asof_dtm_in  in  timestamp with time zone)
is
begin
   asof_dtm := asof_dtm_in;
end set_asof_dtm;
----------------------------------------
-- Centralized date/time for ASOF views
function get_asof_dtm
   return timestamp with time zone
is
begin
   return asof_dtm;
end get_asof_dtm;
----------------------------------------
-- Current User for Audit
procedure set_usr
      (usr_in  in  VARCHAR2)
is
begin
   current_usr := substr(usr_in,1,30);
end set_usr;
----------------------------------------
-- Current User for Audit
function get_usr
   return VARCHAR2
is
begin
   if current_usr is null
   then
      raise_application_error(-20002, 'Current User has not been set in the Util Package.');
   end if;
   return current_usr;
end get_usr;
----------------------------------------
-- Separates values within a set of Natural Keys
procedure set_nk_sep
         (nk_sep_in  in  varchar2)
is
begin
   nk_sep := nk_sep_in;
end set_nk_sep;
----------------------------------------
-- Separates values within a set of Natural Keys
function get_nk_sep
      return varchar2
is
begin
  return nk_sep;
end get_nk_sep;
----------------------------------------
-- Hierarchial Path Seperator
procedure set_path_sep
         (path_sep_in  in  varchar2)
is
begin
   path_sep := path_sep_in;
end set_path_sep;
----------------------------------------
-- Hierarchial Path Seperator
function get_path_sep
      return varchar2
is
begin
  return path_sep;
end get_path_sep;
----------------------------------------
-- Indicates whether to fold strings or return an error
procedure set_fold_strings
      (bool_in  in  boolean)
is
begin
   fold_strings := bool_in;
end set_fold_strings;
----------------------------------------
-- Indicates whether to fold strings or return an error
function get_fold_strings
      return boolean
is
begin
   return fold_strings;
end get_fold_strings;
----------------------------------------
-- Indicates whether to compress spaces in a string or return an error
procedure set_compress_spaces
      (bool_in  in  boolean)
is
begin
   compress_spaces := bool_in;
end set_compress_spaces;
----------------------------------------
-- Indicates whether to compress spaces in a string or return an error
function get_compress_spaces
      return boolean
is
begin
   return compress_spaces;
end get_compress_spaces;
----------------------------------------
-- Indicates whether to return an error if an UPDATE is called with no data changes
procedure set_ignore_no_change
      (bool_in  in  boolean)
is
begin
   ignore_no_change := bool_in;
end set_ignore_no_change;
----------------------------------------
-- Indicates whether to return an error if an UPDATE is called with no data changes
function get_ignore_no_change
      return boolean
is
begin
   return ignore_no_change;
end get_ignore_no_change;
----------------------------------------
-- Indicates whether to enforce temporal continuity on foreign keys
procedure set_temporal_continuity
      (bool_in  in  boolean)
is
begin
   temporal_continuity := bool_in;
end set_temporal_continuity;
----------------------------------------
-- Indicates whether to enforce temporal continuity on foreign keys
function get_temporal_continuity
      return boolean
is
begin
   return temporal_continuity;
end get_temporal_continuity;
----------------------------------------
-- Indicates whether to use the default value provided for a column
procedure set_use_defaults
      (bool_in  in  boolean)
is
begin
   use_defaults := bool_in;
end set_use_defaults;
----------------------------------------
-- Indicates whether to use the default value provided for a column
function get_use_defaults
      return boolean
is
begin
   return use_defaults;
end get_use_defaults;
----------------------------------------
-- Indicates whether to include hex or decimal encodings
procedure set_include_unknown_ascii
      (bool_in  in  boolean)
is
begin
   include_unknown_ascii := bool_in;
end set_include_unknown_ascii;
----------------------------------------
-- Indicates whether to include hex or decimal encodings
function get_include_unknown_ascii
      return boolean
is
begin
   return include_unknown_ascii;
end get_include_unknown_ascii;
----------------------------------------
-- Indicates whether to set columns to NULL
procedure set_fix_non_null_sub_types
      (bool_in  in  boolean)
is
begin
   fix_non_null_sub_types := bool_in;
end set_fix_non_null_sub_types;
----------------------------------------
-- Indicates whether to set columns to NULL
function get_fix_non_null_sub_types
      return boolean
is
begin
   return fix_non_null_sub_types;
end get_fix_non_null_sub_types;
----------------------------------------
-- Centralized function GLOBAL lock handles
function allocate_lock
      (lockname_in  in  varchar2
      ,exp_secs_in  in  number  default 43200)
   return varchar2
is
   PRAGMA AUTONOMOUS_TRANSACTION;
   ret_txt  varchar2(128);
begin
   dbms_lock.allocate_unique(lockname        => lockname_in
                            ,lockhandle      => ret_txt
                            ,expiration_secs => exp_secs_in);
   return ret_txt;
end allocate_lock;
----------------------------------------
-- Centralized Multi-locks, used for Unique Key Temporal Continuity Constraints
function get_multi_lock
      (lhandle_in  in  varchar2
      ,timeout_in  in  INTEGER  default DBMS_LOCK.MAXWAIT)
   return  varchar2
is
   retcd   number;
begin
   -- These locks will slow a bulk insert/update.
   -- Commits should be done about every 100 records.
   retcd := dbms_lock.request(lockhandle        => lhandle_in
                             ,lockmode          => DBMS_LOCK.X_MODE
                             ,timeout           => timeout_in
                             ,release_on_commit => TRUE);
   case retcd
   when 0 then return 'SUCCESS';
   when 1 then return 'TIMEOUT';
   when 2 then return 'DEADLOCK';
   when 3 then return 'PARAMETER ERROR';
   when 4 then return 'ALREADY LOCKED';
   when 5 then return 'ILLEGAL LOCKNAME';
          else return 'UNKNOWN: ' || retcd;
   end case;
end get_multi_lock;
----------------------------------------
-- Centralized procedures GLOBAL locks
function request_lock
      (lockname_in  in  varchar2
      ,timeout_in   in  INTEGER  default null)
   return varchar2
is
begin
   if st_lockname is not null AND st_lockname != lockname_in then
      return 'RELEASE ONLY';
   end if;
   st_lockname   := substr(lockname_in,1,128);
   st_lockhandle := allocate_lock(st_lockname);
   return get_multi_lock(st_lockhandle);
end request_lock;
----------------------------------------
-- Centralized procedure GLOBAL locks
function release_lock
   return varchar2
is
   retcd INTEGER;
begin
   if st_lockname is null then return 'SUCCESS'; end if;
   retcd := dbms_lock.release(lockhandle => st_lockhandle);
   st_lockname := null;
   case retcd
   when 0 then return 'SUCCESS';
   when 3 then return 'PARAMETER ERROR';
   when 4 then return 'SUCCESS'; -- This session doesn't own the lock
   when 5 then return 'ILLEGAL LOCKNAME';
          else return 'UNKNOWN: ' || retcd;
   end case;
end release_lock;
----------------------------------------
-- Wait/Delay Procedure
procedure wait
         (seconds_in  in  number default null)
is
begin
   dbms_lock.sleep(nvl(seconds_in,0.01));
end wait;
----------------------------------------
-- Comparison with NULL handling
function is_equal
      (t1_in  in  varchar2
      ,t2_in  in  varchar2
      )  return boolean
is
begin
   if t1_in = t2_in or (t1_in is null and t2_in is null)
   then return TRUE;
   else return FALSE;
   end if;
end is_equal;
----------------------------------------
-- Comparison with NULL handling
function is_equal
      (n1_in  in  number
      ,n2_in  in  number
      )  return boolean
is
begin
   if n1_in = n2_in or (n1_in is null and n2_in is null)
   then return TRUE;
   else return FALSE;
   end if;
end is_equal;
----------------------------------------
-- Comparison with NULL handling
function is_equal
      (b1_in  in  blob
      ,b2_in  in  blob
      )  return boolean
is
   ret_num  number;
begin
   if b1_in is null and b2_in is null then return TRUE; end if;
   if b1_in is null or b2_in is null then return FALSE; end if;
   ret_num := dbms_lob.compare(b1_in, b2_in);
   if ret_num is not null and ret_num = 0 then return TRUE; end if;
   return FALSE;
end is_equal;
----------------------------------------
-- Comparison with NULL handling
function is_equal
      (x1_in  in  xmltype
      ,x2_in  in  xmltype
      )  return boolean
is
   diff_len  number;
begin
   if x1_in is null and x2_in is null then return TRUE; end if;
   if x1_in is null or x2_in is null then return FALSE; end if;
   select length(diff_val) into diff_len
      from xmltable(xmlnamespaces(default 'http://xmlns.oracle.com/xdb/xdiff.xsd')
                   ,'/'
                    passing xmldiff(x1_in, x2_in, 0, 'XMLDF_FL_ALGORITHM_LOCAL')
            columns diff_val clob path '/xdiff');
   if diff_len = 0 then return TRUE; end if;
   return FALSE;
end is_equal;
----------------------------------------
-- Comparison with NULL handling
function is_equal
      (g1_in   in  sdo_geometry
      ,g2_in   in  sdo_geometry
      ,tol_in  in  number default 0.05
      )  return boolean
is
   ret_str  varchar2(100);
begin
   if g1_in is null and g2_in is null then return TRUE; end if;
   if g1_in is null or g2_in is null then return FALSE; end if;
   ret_str := sdo_geom.relate(g1_in, 'EQUAL', g2_in, tol_in);
   if ret_str = 'EQUAL' then return TRUE; end if;
   return FALSE;
end is_equal;
----------------------------------------
-- Boolean Conversion Functions
function conv_bool
      (str_in  in  varchar2
      ) return boolean
is
begin
   if upper(substr(str_in,1,1)) = 'T'
   then return TRUE;
   else return FALSE;
   end if;
end conv_bool;
----------------------------------------
-- Boolean Conversion Functions
function conv_bool
      (bool_in   in  boolean
      ,true_in   in  varchar2
      ,false_in  in  varchar2
      ) return varchar2
is
begin
   if bool_in then return true_in;
              else return false_in;
   end if;
end conv_bool;
----------------------------------------
-- Boolean Conversion Functions
function conv_bool
      (bool_in   in  boolean
      ,true_in   in  number
      ,false_in  in  number
      ) return number
is
begin
   if bool_in then return true_in;
              else return false_in;
   end if;
end conv_bool;
----------------------------------------
-- Spatial Data Option Geometry Conversion Functions
function get_srid
      (geo_in  in  sdo_geometry
      ) return number
is
begin
   return geo_in.sdo_srid;
end get_srid;
----------------------------------------
-- Spatial Data Option Geometry Conversion Functions
function get_xcrd
      (geo_in  in  sdo_geometry
      ) return number
is
begin
   return geo_in.sdo_point.x;
end get_xcrd;
----------------------------------------
-- Spatial Data Option Geometry Conversion Functions
function get_ycrd
      (geo_in  in  sdo_geometry
      ) return number
is
begin
   return geo_in.sdo_point.y;
end get_ycrd;
----------------------------------------
-- Spatial Data Option Geometry Conversion Functions
function get_geom_2dpt
      (xcrd_in  in  number
      ,ycrd_in  in  number
      ,srid_in  in  number
      ) return sdo_geometry
is
begin
   if xcrd_in is null or ycrd_in is null then return null; end if;
   return sdo_geometry(2001, srid_in
                           , sdo_point_type(xcrd_in, ycrd_in, null)
                           , null, null );
end get_geom_2dpt;
----------------------------------------
-- Convert string to US7ASCII characters (the characters
--   that are commonly available on your keyboard
function ascii_conv
         (str_in   in  varchar2)
   return varchar2
is
   char_val  number;
   i_char    varchar2(8);
   ret_str   varchar2(32767) := '';
   procedure add_hex_rep is begin
      if include_unknown_ascii then
         -- Add a Hexadecimal Representative of the character
         ret_str := ret_str || '&#x' || substr(i_char,2) || ';';
      end if;
   end add_hex_rep;
begin
   for i in 1 .. length(str_in) loop
      -- Extract each character from the string and
      --   convert it to UTF-16 encoding
      i_char := asciistr(substr(str_in,i,1));
      if length(i_char) = 1 then
         char_val := ascii(i_char);
         if char_val between 9 and 12 or  -- [:space:] is 9, 10, 11, 12, and 32
            char_val between 32 and 126
         then
            -- This is a US7ASCII Printable Character, add it
            ret_str := ret_str || i_char;
         elsif include_unknown_ascii then
            -- This is a US7ASCII Non-Printable Character
            ret_str := ret_str || '&#' || char_val || ';';
         end if;
      elsif substr(i_char,1,1) != '\' then
         if include_unknown_ascii then
            -- Add a NULL place holder for the character
            ret_str := ret_str || '&#0;';
         end if;
      -- Change commonly used UTF-16 characters to ASCII-7
      --   This was formerly implemented as an associative array.
      --   The "case" statement may execute slower, but loads "statically"
      --   Static loading is prefered for APEX page processing
      elsif substr(i_char,2,2) = '00' then
         case substr(i_char,4,1)
         when 'A' then
            case substr(i_char,5)           -- \00A*
            when '0' then ret_str := ret_str || '  ';
            when '1' then ret_str := ret_str || '!';
            when '2' then ret_str := ret_str || 'c';
            when '3' then ret_str := ret_str || 'L';
            when '5' then ret_str := ret_str || 'Y';
            when '6' then ret_str := ret_str || '|';
            when '7' then ret_str := ret_str || 'S';
            when '8' then ret_str := ret_str || '..';
            when '9' then ret_str := ret_str || '(c)';
            when 'A' then ret_str := ret_str || '^a';
            when 'B' then ret_str := ret_str || '<<';
            when 'C' then ret_str := ret_str || '-not-';
            when 'D' then ret_str := ret_str || '-';
            when 'E' then ret_str := ret_str || '(R)';
            else add_hex_rep;
            end case;
         when 'B' then
            case substr(i_char,5)           -- \00B*
            when '0' then ret_str := ret_str || 'Deg';
            when '1' then ret_str := ret_str || '+/-';
            when '2' then ret_str := ret_str || '^2';
            when '3' then ret_str := ret_str || '^3';
            when '4' then ret_str := ret_str || '''';
            when '5' then ret_str := ret_str || 'u';
            when '6' then ret_str := ret_str || '(P)';
            when '7' then ret_str := ret_str || '-';
            when '9' then ret_str := ret_str || '^1';
            when 'A' then ret_str := ret_str || '^o';
            when 'B' then ret_str := ret_str || '>>';
            when 'C' then ret_str := ret_str || '1/4';
            when 'D' then ret_str := ret_str || '1/2';
            when 'E' then ret_str := ret_str || '3/4';
            when 'F' then ret_str := ret_str || '?';
            else add_hex_rep;
            end case;
         when 'C' then
            case substr(i_char,5)           -- \00C*
            when '0' then ret_str := ret_str || 'A';
            when '1' then ret_str := ret_str || 'A';
            when '2' then ret_str := ret_str || 'A';
            when '3' then ret_str := ret_str || 'A';
            when '4' then ret_str := ret_str || 'A';
            when '5' then ret_str := ret_str || 'A';
            when '6' then ret_str := ret_str || 'AE';
            when '7' then ret_str := ret_str || 'C';
            when '8' then ret_str := ret_str || 'E';
            when '9' then ret_str := ret_str || 'E';
            when 'A' then ret_str := ret_str || 'E';
            when 'B' then ret_str := ret_str || 'E';
            when 'C' then ret_str := ret_str || 'I';
            when 'D' then ret_str := ret_str || 'I';
            when 'E' then ret_str := ret_str || 'I';
            when 'F' then ret_str := ret_str || 'I';
            else add_hex_rep;
            end case;
         when 'D' then
            case substr(i_char,5)           -- \00D*
            when '0' then ret_str := ret_str || 'D';
            when '1' then ret_str := ret_str || 'N';
            when '2' then ret_str := ret_str || 'O';
            when '3' then ret_str := ret_str || 'O';
            when '4' then ret_str := ret_str || 'O';
            when '5' then ret_str := ret_str || 'O';
            when '6' then ret_str := ret_str || 'O';
            when '7' then ret_str := ret_str || '*';
            when '8' then ret_str := ret_str || 'OE';
            when '9' then ret_str := ret_str || 'U';
            when 'A' then ret_str := ret_str || 'U';
            when 'B' then ret_str := ret_str || 'U';
            when 'C' then ret_str := ret_str || 'U';
            when 'D' then ret_str := ret_str || 'Y';
            when 'E' then ret_str := ret_str || 'TH';
            when 'F' then ret_str := ret_str || 'B';
            else add_hex_rep;
            end case;
         when 'E' then
            case substr(i_char,5)           -- \00E*
            when '0' then ret_str := ret_str || 'a';
            when '1' then ret_str := ret_str || 'a';
            when '2' then ret_str := ret_str || 'a';
            when '3' then ret_str := ret_str || 'a';
            when '4' then ret_str := ret_str || 'a';
            when '5' then ret_str := ret_str || 'a';
            when '6' then ret_str := ret_str || 'ae';
            when '7' then ret_str := ret_str || 'c';
            when '8' then ret_str := ret_str || 'e';
            when '9' then ret_str := ret_str || 'e';
            when 'A' then ret_str := ret_str || 'e';
            when 'B' then ret_str := ret_str || 'e';
            when 'C' then ret_str := ret_str || 'i';
            when 'D' then ret_str := ret_str || 'i';
            when 'E' then ret_str := ret_str || 'i';
            when 'F' then ret_str := ret_str || 'i';
            else add_hex_rep;
            end case;
         when 'F' then
            case substr(i_char,5)           -- \00F*
            when '0' then ret_str := ret_str || 'd';
            when '1' then ret_str := ret_str || 'n';
            when '2' then ret_str := ret_str || '0';
            when '3' then ret_str := ret_str || '0';
            when '4' then ret_str := ret_str || '0';
            when '5' then ret_str := ret_str || '0';
            when '6' then ret_str := ret_str || '0';
            when '7' then ret_str := ret_str || '/';
            when '8' then ret_str := ret_str || 'oe';
            when '9' then ret_str := ret_str || 'u';
            when 'A' then ret_str := ret_str || 'u';
            when 'B' then ret_str := ret_str || 'u';
            when 'C' then ret_str := ret_str || 'u';
            when 'D' then ret_str := ret_str || 'u';
            when 'E' then ret_str := ret_str || 'th';
            when 'F' then ret_str := ret_str || 'y';
            else add_hex_rep;
            end case;
         else add_hex_rep;
         end case;
      else
         case substr(i_char,2,1)
         when '0' then
            case substr(i_char,3)             -- \0*
            when '142' then ret_str := ret_str || 'Z';
            when '152' then ret_str := ret_str || 'CE';
            when '153' then ret_str := ret_str || 'ce';
            when '158' then ret_str := ret_str || 'z';
            when '160' then ret_str := ret_str || 'S';
            when '161' then ret_str := ret_str || 's';
            when '178' then ret_str := ret_str || 'Y';
            when '192' then ret_str := ret_str || 'f';
            when '2C6' then ret_str := ret_str || '^';
            when '2DC' then ret_str := ret_str || '~';
            else add_hex_rep;
            end case;
         when '2' then
            case substr(i_char,3)             -- \2*
            when '013' then ret_str := ret_str || '-';
            when '014' then ret_str := ret_str || '--';
            when '018' then ret_str := ret_str || '''';
            when '019' then ret_str := ret_str || '''';
            when '01A' then ret_str := ret_str || '''';
            when '01C' then ret_str := ret_str || '"';
            when '01D' then ret_str := ret_str || '"';
            when '01E' then ret_str := ret_str || '"';
            when '020' then ret_str := ret_str || '+';
            when '021' then ret_str := ret_str || '++';
            when '022' then ret_str := ret_str || '*)';
            when '026' then ret_str := ret_str || '...';
            when '030' then ret_str := ret_str || '0/00';
            when '039' then ret_str := ret_str || '<';
            when '03A' then ret_str := ret_str || '>';
            when '0AC' then ret_str := ret_str || 'EU';
            when '122' then ret_str := ret_str || '(TM)';
            else add_hex_rep;
            end case;
         else add_hex_rep;
         end case;
      end if;
   end loop;
   return ret_str;
end ascii_conv;
----------------------------------------
-- Remove leading and trailing spaces, reduce multiple spaces to 1
function comp_spc
         (str_in   in  varchar2)
   return varchar2
is
begin
   return regexp_replace(
             regexp_replace(
                regexp_replace(str_in
                              ,'^[[:space:]]+', '', 1, 1)  -- Replace 1st occurance at beg
                           ,'[[:space:]]+$', '', 1, 1)  -- Replace 1st occurance at end
                        ,'[[:space:]]+', ' ', 1, 0)  -- Replace ALL occurances
                        ;
end comp_spc;
----------------------------------------
-- Long Operations Logging Procedures
procedure init_longops
      (opname_in       in  varchar2
      ,totalwork_in    in  number
      ,target_desc_in  in  varchar2
      ,units_in        in  varchar2)
is
begin
   if lo_rindex = dbms_application_info.set_session_longops_nohint then
      lo_slno        := null;
      lo_op_name     := opname_in;
      lo_target      := 0;
      lo_context     := 0;
      lo_sofar       := 0;
      lo_totalwork   := totalwork_in;
      lo_target_desc := target_desc_in;
      lo_units       := units_in;
      dbms_application_info.set_session_longops
         (lo_rindex, lo_slno, lo_op_name, lo_target, lo_context,
          lo_sofar, lo_totalwork, lo_target_desc, lo_units);
   end if;
end init_longops;
----------------------------------------
-- Long Operations Logging Procedures
procedure add_longops
      (add_sofar_in  in  number)
is
begin
   if lo_rindex <> dbms_application_info.set_session_longops_nohint then
      lo_sofar := lo_sofar + add_sofar_in;
      dbms_application_info.set_session_longops
         (lo_rindex, lo_slno, lo_op_name, lo_target, lo_context,
          lo_sofar, lo_totalwork, lo_target_desc, lo_units);
   end if;
end add_longops;
----------------------------------------
-- Long Operations Logging Procedures
procedure end_longops
is
begin
   if lo_rindex <> dbms_application_info.set_session_longops_nohint then
      lo_sofar := lo_totalwork;
      dbms_application_info.set_session_longops
         (lo_rindex, lo_slno, lo_op_name, lo_target, lo_context,
          lo_sofar, lo_totalwork, lo_target_desc, lo_units);
      lo_rindex := dbms_application_info.set_session_longops_nohint;
   end if;
end end_longops;
----------------------------------------
-- Logging, Tracing, and Error Procedures
procedure log
      (txt_in  in  varchar2
      ,loc_in  in  varchar2 default null
      )
is
/*  Sample output from DBMS_UTILITY.FORMAT_CALL_STACK:
----- PL/SQL Call Stack -----
  object      line  object
  handle    number  name
A4A6A840        76  package body GEN2.UTIL
AA345744         6  anonymous block
AA345744        16  anonymous block
*/
   PRAGMA AUTONOMOUS_TRANSACTION;
   usr_buff  VARCHAR2(30);
   fcs_txt  varchar2(2000);
   log_txt  varchar2(4000);  -- Required for Multi-byte Character CLOB Conversion
begin
   -- pragma restrict_references(format_call_stack,WNDS);
   -- WNDS Asserts that the subprogram writes no database state
   --      (does not modify database tables).
   -- DBMS_UTILITY.FORMAT_CALL_STACK returns up to 2000 characters
   fcs_txt := DBMS_UTILITY.FORMAT_CALL_STACK;
   usr_buff := nvl(current_usr, USER);
   log_txt := substrb(txt_in,1,4000);
   insert into util_log
         (dtm
         ,usr
         ,sid
         ,txt
         ,loc
         )
      values
         (systimestamp
         ,usr_buff
         ,sys_context('USERENV', 'SID')
         ,log_txt
         ,nvl(substr(loc_in,1,4000), fcs_txt)
         );
   -- DO NOT dbms_output.put_line(txt_in || fcs_txt);
   commit;
end log;
----------------------------------------
-- Re-Check for trace keys
procedure set_no_trace_keys
is
   PRAGMA AUTONOMOUS_TRANSACTION;
   cursor loc_curs is select loc from util_trc;
   loc_buff  loc_curs%ROWTYPE;
begin
   open loc_curs; fetch loc_curs into loc_buff;
   no_trace_keys := loc_curs%NOTFOUND; close loc_curs;
end set_no_trace_keys;
----------------------------------------
-- Logging, Tracing, and Error Procedures
procedure trc
      (key_in  in  varchar2
      ,txt_in  in  varchar2
      )
is
   cursor c_trc (loc_in varchar2
                ,usr_in VARCHAR2
                ,sid_in number)
   is
      select 'X' from util_trc
       where (loc = '%' or loc_in like loc)
        and  (txt = '%' or txt_in like txt)
        and  (usr = '%' or usr_in like usr)
        and  (sid =  0  or sid_in =    sid);
   loc_buff  util_trc.loc%TYPE;
   usr_buff  VARCHAR2(30);
   jnk       varchar2(1);
begin
   if no_trace_keys then return; end if;
   set_no_trace_keys;
   if no_trace_keys then return; end if;
   loc_buff := 'KEY=' || substr(key_in,1,                     128) ||
             ', ACT=' || sys_context('USERENV', 'ACTION',      32) ||
             ', MOD=' || sys_context('USERENV', 'MODULE',      48) ||
             ', CI='  || sys_context('USERENV', 'CLIENT_INFO', 64) ||
             ', HST=' || sys_context('USERENV', 'HOST',        64) ||
             ', TRM=' || sys_context('USERENV', 'TERMINAL',    32) ||
             ', OU='  || sys_context('USERENV', 'OS_USER',     32);
   usr_buff := nvl(current_usr, USER);
   open c_trc (loc_buff
              ,usr_buff
              ,sys_context('USERENV', 'SID'));
   fetch c_trc into jnk;
   if c_trc%FOUND then log(txt_in, loc_buff); end if;
   close c_trc;
end trc;
----------------------------------------
-- Logging, Tracing, and Error Procedures
procedure err
      (txt_in  in  varchar2
      )
is
   fcs_txt  varchar2(2000) := DBMS_UTILITY.FORMAT_ERROR_BACKTRACE;
   retstr   varchar2(100);
begin
   log (txt_in, fcs_txt);
   end_longops;
   retstr := release_lock;
end err;
----------------------------------------
-- Logging, Tracing, and Error Procedures
procedure trc_time_interval
      (key_in  in  varchar2
      ,tst_in  in  timestamp
      )
is
   tstr   varchar2(100);
begin
   if no_trace_keys then return; end if;
   --  NOTE: "to_char" format does not seem to work
   --        tstr = '+000000000 00:00:00.000000000'
   tstr := to_char(systimestamp - tst_in);
   trc('TI ' || key_in, substr(tstr, instr(tstr, ' ')+1));
end trc_time_interval;
----------------------------------------
-- Fix the Name portion of a Name-Value Pair
function fix_nvp_name
         (name_in   in  varchar2)
   return varchar2
is
begin
   return upper
            (regexp_replace
               (regexp_replace
                  (regexp_replace
                     (ascii_conv(name_in)
                     ,'^[[:space:]]+', '', 1, 1)  -- Replace 1st occurance at beg
                  ,'[[:space:]]+$', '', 1, 1)  -- Replace 1st occurance at end
               ,'[[:space:]]+', ' ', 1, 0)  -- Replace ALL occurances
            );
end fix_nvp_name;
----------------------------------------
-- Save a Name-Value Pair in the Database
procedure set_nvp
         (name_in   in  varchar2
         ,value_in  in  varchar2
         ,descr_in  in  varchar2 default null
         )
is
   fixed_name  varchar2(30);
begin
   fixed_name := fix_nvp_name(name_in);
   insert into util_nvp (name, value, description)
      values (fixed_name, value_in, descr_in);
exception
   when DUP_VAL_ON_INDEX then
      update util_nvp set value = value_in, description = descr_in
       where name = fixed_name;
end set_nvp;
----------------------------------------
-- Retreive a Name-Value Pair from the Database
function get_nvp
         (name_in  in  varchar2
         ) return varchar2
is
   fixed_name  varchar2(30);
   retval  varchar2(4000);
begin
   fixed_name := fix_nvp_name(name_in);
   select value into retval from util_nvp where name = fixed_name;
   return retval;
exception when NO_DATA_FOUND then return null;
end get_nvp;
----------------------------------------
-- Clear a Name-Value Pair in the Database
procedure clr_nvp
         (name_in   in  varchar2
         )
is
   fixed_name  varchar2(30);
begin
   fixed_name := fix_nvp_name(name_in);
   delete from util_nvp where name = fixed_name;
end clr_nvp;
----------------------------------------
-- Return the Special OMNI ID
function get_omni_id
      (id_in   in  number
      ,key_in  in  number
      ,dtm_in  in  TIMESTAMP WITH LOCAL TIME ZONE
      ) return number deterministic
is
begin
   return to_number(id_in || '.' || key_in ||
                    to_char(dtm_in, 'fmFF9fmSSSSSfmDDDfmYY') );
end get_omni_id;
----------------------------------------
begin
   st_lockname := null;
   lo_rindex := dbms_application_info.set_session_longops_nohint;
   set_no_trace_keys;
   asof_dtm  := systimestamp;
end util;
/
select 'UTIL' as "Package Body:"
 from  user_errors
 where name  = 'UTIL'
  and  type  = 'PACKAGE BODY'
  and  rownum = 1
/
select '('||line||'/'||position||') '||text as error
 from  user_errors
 where name = 'UTIL'
  and  type = 'PACKAGE BODY'
 order by sequence
/

create PACKAGE clue
as

   -- Package Clue
   --    Generated Specification Text

   -- Application: Clue Notes For Oracle
   -- Generated by DTGen (http://dmstex.com/services/dtgen)
   -- December  16, 2013  11:32:28 AM

   --
   --
   -- © Duane.Dieterich@DMSTEX.com 2013
   --
   -- All Rights Reserved
   --
   -- No part of this software may be reproduced, copied, modified or adapted,
   -- without the prior written consent of the author, unless otherwise
   -- indicated for stand-alone materials.
   --
   -- You may quote extracts from this software with attribution to
   -- Duane.Dieterich@DMSTEX.com
   --
   -- For any other mode of sharing, please contact Duane.Dieterich@DMSTEX.com.
   --
   -- Commercial use and distribution of this software is not allowed without
   -- express and prior written consent of the author.
   --
   -- THE SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
   -- INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY
   -- AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL
   -- THE COPYRIGHT HOLDER OR DMSTEX BUSINESS SOLUTIONS LLC, ITS MEMBERS,
   -- MANAGERS, OR EMPLOYEES BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
   -- SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
   -- TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
   -- PROFITS; CORRUPTION OF DATA, OR BUSINESS INTERRUPTION) HOWEVER CAUSED
   -- AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
   -- OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF
   -- THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH
   -- DAMAGE.
   --
   --


   -- Undefined PACKAGE

end clue;
/
select 'CLUE' as "Package:"
 from  user_errors
 where name  = 'CLUE'
  and  type  = 'PACKAGE'
  and  rownum = 1
/
select '('||line||'/'||position||') '||text as error
 from  user_errors
 where name = 'CLUE'
  and  type = 'PACKAGE'
 order by sequence
/

