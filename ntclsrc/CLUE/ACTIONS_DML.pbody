
--
--  Create CLUE.ACTIONS_DML Package Body
--

set define off


--DBMS_METADATA:CLUE.ACTIONS_DML

  CREATE OR REPLACE EDITIONABLE PACKAGE BODY "CLUE"."ACTIONS_DML" 
is

 -- Package Body Actions_Dml
 -- (Data Manipulation Language, Foreign Key and Path Lookup)

   -- Application: Clue Notes For Oracle
   -- Generated by DTGen (http://dmstex.com/services/dtgen)
   -- December  16, 2013  11:32:31 AM

   --
   --
   -- ? Duane.Dieterich@DMSTEX.com 2013
   --
   -- All Rights Reserved
   --
   -- No part of this software may be reproduced, copied, modified or adapted,
   -- without the prior written consent of the author, unless otherwise
   -- indicated for stand-alone materials.
   --
   -- You may quote extracts from this software with attribution to
   -- Duane.Dieterich@DMSTEX.com
   --
   -- For any other mode of sharing, please contact Duane.Dieterich@DMSTEX.com.
   --
   -- Commercial use and distribution of this software is not allowed without
   -- express and prior written consent of the author.
   --
   -- THE SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
   -- INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY
   -- AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL
   -- THE COPYRIGHT HOLDER OR DMSTEX BUSINESS SOLUTIONS LLC, ITS MEMBERS,
   -- MANAGERS, OR EMPLOYEES BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
   -- SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
   -- TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
   -- PROFITS; CORRUPTION OF DATA, OR BUSINESS INTERRUPTION) HOWEVER CAUSED
   -- AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
   -- OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF
   -- THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH
   -- DAMAGE.
   --
   --


----------------------------------------
function get_next_id
      return NUMBER
is
   retid  NUMBER;
begin
   select actions_seq.nextval
    into  retid from dual;
   return retid;
end get_next_id;
----------------------------------------
function get_curr_id
      return NUMBER
is
   retid  NUMBER;
begin
   select actions_seq.currval
    into  retid from dual;
   return retid;
end get_curr_id;
----------------------------------------
function get_id
      (players_nk1  in  VARCHAR2
      ,players_nk2  in  VARCHAR2
      ,players_nk3  in  VARCHAR2
      ,seq  in  NUMBER
      ) return number
   -- For all the Natural Key Columns, Return an ID
is
begin
   return actions_tab.get_id
      (players_nk1
      ,players_nk2
      ,players_nk3
      ,seq
      );
end get_id;
----------------------------------------
-- For all the Natural Key Column IDs, Return an ID
function get_id2
      (player_id_in  in  NUMBER
      ,seq_in  in  NUMBER
      ) return NUMBER
is
   retid  NUMBER(38);
begin
   select id
    into  retid
    from  actions  ACT
    where player_id_in = ACT.player_id
     and  seq_in = ACT.seq
    ;
   return retid;
exception when no_data_found then return null;
end get_id2;
----------------------------------------
function get_nk
      (id_in  in  NUMBER)
   return VARCHAR2
   -- For an ID, return a delimited list of Natural Key Values
is
begin
   return actions_tab.get_nk(id_in);
end get_nk;
----------------------------------------
function get_res_id_path
      (id_in  in  NUMBER)
   return VARCHAR2
   -- For a hierarchy ID, return a delimited list of IDs
is
begin
   return actions_tab.get_res_id_path(id_in);
end get_res_id_path;
----------------------------------------
function get_res_nk_path
      (id_in  in  NUMBER)
   return CLOB
   -- For a hierarchy ID, return a delimited list of
   --    Natural Key sets
is
begin
   return actions_tab.get_res_nk_path(id_in);
end get_res_nk_path;
----------------------------------------
function get_res_id_by_id_path
      (id_path_in  VARCHAR2
      ) return NUMBER
is
begin
   return actions_tab.get_res_id_by_id_path(id_path_in);
end get_res_id_by_id_path;
----------------------------------------
function get_res_id_by_nk_path
      (nk_path_in  in  VARCHAR2
      ) return NUMBER
is
   path_len   number;          -- Length of nk_path_in
   ps_occ     number;          -- Path Seperator substring search occurance
   ps_pos     number;          -- Path Seperator position in nk_path_in
   path_frag  VARCHAR2(32767);  -- Concatenated Natural Key Path Fragment
   ns_pos     number;          -- Natural Key Seperator position in nk_path_in
   nk_frag    VARCHAR2(4000);  -- First Natural Key String from path_frag
begin
   if nk_path_in is null then return null; end if;
   path_len := length(nk_path_in);
   ps_occ := 0;
   -- To account for embedded path_sep chars in nk_path_in,
   while ps_occ < 1 loop   -- increase this ps_occ limit
      ps_occ := ps_occ + 1;
      -- Attempt to find the last conatenated Natural Key in nk_path_in
      ps_pos := instr(nk_path_in, util.path_sep, -1, ps_occ);
      -- Don't search beyond 4000 characters in the path
      if path_len - ps_pos > 4001 then return null; end if;
      -- This should be the last concatenated Natural Key in nk_path_in
      path_frag := substr(nk_path_in, ps_pos+1);
      ns_pos := instr(path_frag, util.nk_sep, 1, 1);
      -- This should the first Natural Key value in the last concatenated Natural Key
      nk_frag := substr(path_frag, 1, ns_pos-1);
      -- This will find cadidates for nk_path_in checks
      for buff in (
         select ACT.id
               ,get_res_nk_path(ACT.id) check_path
          from  actions_A ACT
          where players_nk1 like nk_frag || '%' )
      loop
         if buff.check_path = nk_path_in then return buff.id; end if;
      end loop;
      if ps_pos = 0 then
         -- ps_pos is 0, so there is nothing more to search
         return null;
      end if;
   end loop;
   return null;
end get_res_id_by_nk_path;
----------------------------------------
procedure clear
      (n_rec  in out nocopy  actions_act%ROWTYPE
      )
is
begin
   n_rec.id := null;
   n_rec.actions_sub_type := null;
   n_rec.player_id := null;
   n_rec.players_nk1 := null;
   n_rec.players_nk2 := null;
   n_rec.players_nk3 := null;
   n_rec.seq := null;
   n_rec.resolved := null;
   n_rec.res_action_id := null;
   n_rec.res_id_path := null;
   n_rec.res_nk_path := null;
   n_rec.res_actions_nk1 := null;
   n_rec.res_actions_nk2 := null;
   n_rec.res_actions_nk3 := null;
   n_rec.res_actions_nk4 := null;
   n_rec.rev_player_id := null;
   n_rec.rev_players_nk1 := null;
   n_rec.rev_players_nk2 := null;
   n_rec.rev_players_nk3 := null;
end clear;
----------
function clear
      (n_rec  in out nocopy  actions_act%ROWTYPE
      ) return varchar2
is
begin
   clear(n_rec);
   return '';
exception when others then return sqlerrm;
end clear;
----------------------------------------
procedure clear
      (n_tab  in out nocopy  actions%ROWTYPE
      )
is
begin
   n_tab.id := null;
   n_tab.actions_sub_type := null;
   n_tab.player_id := null;
   n_tab.seq := null;
   n_tab.resolved := null;
   n_tab.res_action_id := null;
   n_tab.rev_player_id := null;
end clear;
----------
function clear
      (n_tab  in out nocopy  actions%ROWTYPE
      ) return varchar2
is
begin
   clear(n_tab);
   return '';
exception when others then return sqlerrm;
end clear;
----------------------------------------
procedure get_rec_by_id
      (n_rec  in out nocopy  actions_act%ROWTYPE
      )
is
   start_tstamp  timestamp := systimestamp;
begin
   if n_rec.id is null then
      clear(n_rec);
   else
      select * into n_rec from actions_act
       where id = n_rec.id;
   end if;
   return;
   util.trc_time_interval('actions_dml.get_rec_by_id(act rec) ID:' || n_rec.id, start_tstamp);
end get_rec_by_id;
----------
function get_rec_by_id
      (n_rec  in out nocopy  actions_act%ROWTYPE
      ) return varchar2
is
begin
   get_rec_by_id(n_rec);
   return '';
exception when others then return sqlerrm;
end get_rec_by_id;
----------------------------------------
procedure get_rec_by_id
      (n_tab  in out nocopy  actions%ROWTYPE
      )
is
   start_tstamp  timestamp := systimestamp;
begin
   if n_tab.id is null then
      clear(n_tab);
   else
      select * into n_tab from actions
       where id = n_tab.id;
   end if;
   return;
   util.trc_time_interval('actions_dml.get_rec_by_id(tab rec) ID:' || n_tab.id, start_tstamp);
end get_rec_by_id;
----------
function get_rec_by_id
      (n_tab  in out nocopy  actions%ROWTYPE
      ) return varchar2
is
begin
   get_rec_by_id(n_tab);
   return '';
exception when others then return sqlerrm;
end get_rec_by_id;
----------------------------------------
-- Insert a actions ACTIVE View Record
procedure ins
      (new_rec  in out nocopy  actions_act%ROWTYPE
      ,upd_vals_in  in  boolean default TRUE
      )
is
   new_tab  actions%ROWTYPE;
   start_tstamp  timestamp := systimestamp;
begin
   -- Set self-referencing n_res_action_id, if needed
   if new_rec.res_action_id is null then
      if    new_rec.res_actions_nk1 = new_rec.players_nk1
        and new_rec.res_actions_nk2 = new_rec.players_nk2
        and new_rec.res_actions_nk3 = new_rec.players_nk3
        and new_rec.res_actions_nk4 = new_rec.seq
      then
         if new_rec.id is not null then
            new_rec.res_action_id := new_rec.id;
         else
            -- An ID of "0" during insert is a flag to the actions_TAB
            --   package to duplicate the new ID in this self-referenced ID
            new_rec.res_action_id := 0;
         end if;
      end if;
   end if;
   -- Set new_rec.res_action_id from new_rec.res_id_path, if needed
   if new_rec.res_action_id is null then
      if new_rec.res_id_path is not null then
         new_rec.res_action_id := actions_tab.get_res_id_by_id_path(new_rec.res_id_path);
         if new_rec.res_action_id is null then
            raise_application_error(-20020, 'Null ID was returned from actions_tab.get_res_id_by_id_path');
         end if;
      -- Set new_rec.res_action_id from new_rec.res_nk_path, if needed
      elsif new_rec.res_nk_path is not null then
         new_rec.res_action_id := get_res_id_by_nk_path(new_rec.res_nk_path);
         if new_rec.res_action_id is null then
            raise_application_error(-20020, 'Null ID was returned from get_res_id_by_nk_path');
         end if;
      else
      -- Lack of proper indentation is for convenience of generator
      if    new_rec.res_actions_nk1 is not null
        and new_rec.res_actions_nk2 is not null
        and new_rec.res_actions_nk3 is not null
        and new_rec.res_actions_nk4 is not null
      then
         new_rec.res_action_id := actions_tab.get_id
            (new_rec.res_actions_nk1
            ,new_rec.res_actions_nk2
            ,new_rec.res_actions_nk3
            ,new_rec.res_actions_nk4
            );
         if new_rec.res_action_id is null then
            raise_application_error(-20020, 'Null ID was returned from actions_tab.get_id');
         end if;
      end if;
      -- Lack of proper indentation is for convenience of generator
      end if;
   end if;
   -- Set new_rec.player_id, if needed
   if new_rec.player_id is null then
      if    new_rec.players_nk1 is not null
        and new_rec.players_nk2 is not null
        and new_rec.players_nk3 is not null
      then
         new_rec.player_id := players_tab.get_id
            (new_rec.players_nk1
            ,new_rec.players_nk2
            ,new_rec.players_nk3
            );
         if new_rec.player_id is null then
            raise_application_error(-20020, 'Null ID was returned from players_tab.get_id');
         end if;
      end if;
   end if;
   -- Set new_rec.rev_player_id, if needed
   if new_rec.rev_player_id is null then
      if    new_rec.rev_players_nk1 is not null
        and new_rec.rev_players_nk2 is not null
        and new_rec.rev_players_nk3 is not null
      then
         new_rec.rev_player_id := players_tab.get_id
            (new_rec.rev_players_nk1
            ,new_rec.rev_players_nk2
            ,new_rec.rev_players_nk3
            );
         if new_rec.rev_player_id is null then
            raise_application_error(-20020, 'Null ID was returned from players_tab.get_id');
         end if;
      end if;
   end if;
   new_tab.id := new_rec.id;
   new_tab.actions_sub_type := new_rec.actions_sub_type;
   new_tab.player_id := new_rec.player_id;
   new_tab.seq := new_rec.seq;
   new_tab.resolved := new_rec.resolved;
   new_tab.res_action_id := new_rec.res_action_id;
   new_tab.rev_player_id := new_rec.rev_player_id;
   actions_tab.ins(new_tab);
   if upd_vals_in then
      -- actions_tab.ins returns a new ID, if needed
      select * into new_rec from actions_act
       where id = new_tab.id;
   end if;
   return;
   util.trc_time_interval('actions_dml.ins(act rec) ID:' || new_rec.id, start_tstamp);
end ins;
----------
function ins
      (new_rec  in out nocopy  actions_act%ROWTYPE
      ,upd_vals_in  in  boolean default TRUE
      ) return varchar2
is
begin
   ins(new_rec, upd_vals_in);
   return '';
exception when others then return sqlerrm;
end ins;
----------------------------------------
-- Insert a actions Table Record
procedure ins
      (new_tab   in out nocopy  actions%ROWTYPE
      )
is
   start_tstamp  timestamp := systimestamp;
begin
   actions_tab.ins(new_tab);
   return;
   util.trc_time_interval('actions_dml.ins(tab rec) ID:' || new_tab.id, start_tstamp);
end ins;
----------
function ins
      (new_tab   in out nocopy  actions%ROWTYPE
      ) return varchar2
is
begin
   ins(new_tab);
   return '';
exception when others then return sqlerrm;
end ins;
----------------------------------------
-- Insert columns for actions ACTIVE View
--   without returning updated data in each column
procedure ins
      (id_in  in  NUMBER default null
      ,actions_sub_type_in  in  VARCHAR2 default null
      ,player_id_in  in  NUMBER default null
      ,players_nk1_in  in  VARCHAR2 default null
      ,players_nk2_in  in  VARCHAR2 default null
      ,players_nk3_in  in  VARCHAR2 default null
      ,seq_in  in  NUMBER default null
      ,resolved_in  in  VARCHAR2 default null
      ,res_action_id_in  in  NUMBER default null
      ,res_id_path_in  in  VARCHAR2 default null
      ,res_nk_path_in  in  VARCHAR2 default null
      ,res_actions_nk1_in  in  VARCHAR2 default null
      ,res_actions_nk2_in  in  VARCHAR2 default null
      ,res_actions_nk3_in  in  VARCHAR2 default null
      ,res_actions_nk4_in  in  NUMBER default null
      ,rev_player_id_in  in  NUMBER default null
      ,rev_players_nk1_in  in  VARCHAR2 default null
      ,rev_players_nk2_in  in  VARCHAR2 default null
      ,rev_players_nk3_in  in  VARCHAR2 default null
      )
is
   new_rec  actions_act%ROWTYPE;
   start_tstamp  timestamp := systimestamp;
begin
   new_rec.id := id_in;
   new_rec.actions_sub_type := actions_sub_type_in;
   new_rec.player_id := player_id_in;
   new_rec.players_nk1 := players_nk1_in;
   new_rec.players_nk2 := players_nk2_in;
   new_rec.players_nk3 := players_nk3_in;
   new_rec.seq := seq_in;
   new_rec.resolved := resolved_in;
   new_rec.res_action_id := res_action_id_in;
   new_rec.res_id_path := res_id_path_in;
   new_rec.res_nk_path := res_nk_path_in;
   new_rec.res_actions_nk1 := res_actions_nk1_in;
   new_rec.res_actions_nk2 := res_actions_nk2_in;
   new_rec.res_actions_nk3 := res_actions_nk3_in;
   new_rec.res_actions_nk4 := res_actions_nk4_in;
   new_rec.rev_player_id := rev_player_id_in;
   new_rec.rev_players_nk1 := rev_players_nk1_in;
   new_rec.rev_players_nk2 := rev_players_nk2_in;
   new_rec.rev_players_nk3 := rev_players_nk3_in;
   ins(new_rec, FALSE);
   return;
   util.trc_time_interval('actions_dml.ins(tab col) ID:' || id_in, start_tstamp);
end ins;
----------
function ins
      (id_in  in  NUMBER default null
      ,actions_sub_type_in  in  VARCHAR2 default null
      ,player_id_in  in  NUMBER default null
      ,players_nk1_in  in  VARCHAR2 default null
      ,players_nk2_in  in  VARCHAR2 default null
      ,players_nk3_in  in  VARCHAR2 default null
      ,seq_in  in  NUMBER default null
      ,resolved_in  in  VARCHAR2 default null
      ,res_action_id_in  in  NUMBER default null
      ,res_id_path_in  in  VARCHAR2 default null
      ,res_nk_path_in  in  VARCHAR2 default null
      ,res_actions_nk1_in  in  VARCHAR2 default null
      ,res_actions_nk2_in  in  VARCHAR2 default null
      ,res_actions_nk3_in  in  VARCHAR2 default null
      ,res_actions_nk4_in  in  NUMBER default null
      ,rev_player_id_in  in  NUMBER default null
      ,rev_players_nk1_in  in  VARCHAR2 default null
      ,rev_players_nk2_in  in  VARCHAR2 default null
      ,rev_players_nk3_in  in  VARCHAR2 default null
      ) return varchar2
is
begin
   ins
      (id_in
      ,actions_sub_type_in
      ,player_id_in
      ,players_nk1_in
      ,players_nk2_in
      ,players_nk3_in
      ,seq_in
      ,resolved_in
      ,res_action_id_in
      ,res_id_path_in
      ,res_nk_path_in
      ,res_actions_nk1_in
      ,res_actions_nk2_in
      ,res_actions_nk3_in
      ,res_actions_nk4_in
      ,rev_player_id_in
      ,rev_players_nk1_in
      ,rev_players_nk2_in
      ,rev_players_nk3_in
      );
   return '';
exception when others then return sqlerrm;
end ins;
----------------------------------------
-- Insert columns for actions ACTIVE View
--   with updated data returned in each column
procedure ins2
      (id_io  in out nocopy  NUMBER
      ,actions_sub_type_io  in out nocopy  VARCHAR2
      ,player_id_io  in out nocopy  NUMBER
      ,players_nk1_io  in out nocopy  VARCHAR2
      ,players_nk2_io  in out nocopy  VARCHAR2
      ,players_nk3_io  in out nocopy  VARCHAR2
      ,seq_io  in out nocopy  NUMBER
      ,resolved_io  in out nocopy  VARCHAR2
      ,res_action_id_io  in out nocopy  NUMBER
      ,res_id_path_io  in out nocopy  VARCHAR2
      ,res_nk_path_io  in out nocopy  VARCHAR2
      ,res_actions_nk1_io  in out nocopy  VARCHAR2
      ,res_actions_nk2_io  in out nocopy  VARCHAR2
      ,res_actions_nk3_io  in out nocopy  VARCHAR2
      ,res_actions_nk4_io  in out nocopy  NUMBER
      ,rev_player_id_io  in out nocopy  NUMBER
      ,rev_players_nk1_io  in out nocopy  VARCHAR2
      ,rev_players_nk2_io  in out nocopy  VARCHAR2
      ,rev_players_nk3_io  in out nocopy  VARCHAR2
      )
is
   new_rec  actions_act%ROWTYPE;
   start_tstamp  timestamp := systimestamp;
begin
   new_rec.id := id_io;
   new_rec.actions_sub_type := actions_sub_type_io;
   new_rec.player_id := player_id_io;
   new_rec.players_nk1 := players_nk1_io;
   new_rec.players_nk2 := players_nk2_io;
   new_rec.players_nk3 := players_nk3_io;
   new_rec.seq := seq_io;
   new_rec.resolved := resolved_io;
   new_rec.res_action_id := res_action_id_io;
   new_rec.res_id_path := res_id_path_io;
   new_rec.res_nk_path := res_nk_path_io;
   new_rec.res_actions_nk1 := res_actions_nk1_io;
   new_rec.res_actions_nk2 := res_actions_nk2_io;
   new_rec.res_actions_nk3 := res_actions_nk3_io;
   new_rec.res_actions_nk4 := res_actions_nk4_io;
   new_rec.rev_player_id := rev_player_id_io;
   new_rec.rev_players_nk1 := rev_players_nk1_io;
   new_rec.rev_players_nk2 := rev_players_nk2_io;
   new_rec.rev_players_nk3 := rev_players_nk3_io;
   --
   ins(new_rec);
   --
   id_io := new_rec.id;
   actions_sub_type_io := new_rec.actions_sub_type;
   player_id_io := new_rec.player_id;
   players_nk1_io := new_rec.players_nk1;
   players_nk2_io := new_rec.players_nk2;
   players_nk3_io := new_rec.players_nk3;
   seq_io := new_rec.seq;
   resolved_io := new_rec.resolved;
   res_action_id_io := new_rec.res_action_id;
   res_id_path_io := new_rec.res_id_path;
   res_nk_path_io := new_rec.res_nk_path;
   res_actions_nk1_io := new_rec.res_actions_nk1;
   res_actions_nk2_io := new_rec.res_actions_nk2;
   res_actions_nk3_io := new_rec.res_actions_nk3;
   res_actions_nk4_io := new_rec.res_actions_nk4;
   rev_player_id_io := new_rec.rev_player_id;
   rev_players_nk1_io := new_rec.rev_players_nk1;
   rev_players_nk2_io := new_rec.rev_players_nk2;
   rev_players_nk3_io := new_rec.rev_players_nk3;
   return;
   util.trc_time_interval('actions_dml.ins2(tab col) ID:' || id_io, start_tstamp);
end ins2;
----------
function ins2
      (id_io  in out nocopy  NUMBER
      ,actions_sub_type_io  in out nocopy  VARCHAR2
      ,player_id_io  in out nocopy  NUMBER
      ,players_nk1_io  in out nocopy  VARCHAR2
      ,players_nk2_io  in out nocopy  VARCHAR2
      ,players_nk3_io  in out nocopy  VARCHAR2
      ,seq_io  in out nocopy  NUMBER
      ,resolved_io  in out nocopy  VARCHAR2
      ,res_action_id_io  in out nocopy  NUMBER
      ,res_id_path_io  in out nocopy  VARCHAR2
      ,res_nk_path_io  in out nocopy  VARCHAR2
      ,res_actions_nk1_io  in out nocopy  VARCHAR2
      ,res_actions_nk2_io  in out nocopy  VARCHAR2
      ,res_actions_nk3_io  in out nocopy  VARCHAR2
      ,res_actions_nk4_io  in out nocopy  NUMBER
      ,rev_player_id_io  in out nocopy  NUMBER
      ,rev_players_nk1_io  in out nocopy  VARCHAR2
      ,rev_players_nk2_io  in out nocopy  VARCHAR2
      ,rev_players_nk3_io  in out nocopy  VARCHAR2
      ) return varchar2
is
begin
   ins2
      (id_io
      ,actions_sub_type_io
      ,player_id_io
      ,players_nk1_io
      ,players_nk2_io
      ,players_nk3_io
      ,seq_io
      ,resolved_io
      ,res_action_id_io
      ,res_id_path_io
      ,res_nk_path_io
      ,res_actions_nk1_io
      ,res_actions_nk2_io
      ,res_actions_nk3_io
      ,res_actions_nk4_io
      ,rev_player_id_io
      ,rev_players_nk1_io
      ,rev_players_nk2_io
      ,rev_players_nk3_io
      );
   return '';
exception when others then return sqlerrm;
end ins2;
----------------------------------------
-- Insert columns for actions Table
--   with updated data returned in each column
procedure ins2
      (id_io  in out nocopy  NUMBER
      ,actions_sub_type_io  in out nocopy  VARCHAR2
      ,player_id_io  in out nocopy  NUMBER
      ,seq_io  in out nocopy  NUMBER
      ,resolved_io  in out nocopy  VARCHAR2
      ,res_action_id_io  in out nocopy  NUMBER
      ,rev_player_id_io  in out nocopy  NUMBER
      )
is
   new_rec  actions%ROWTYPE;
   start_tstamp  timestamp := systimestamp;
begin
   new_rec.id := id_io;
   new_rec.actions_sub_type := actions_sub_type_io;
   new_rec.player_id := player_id_io;
   new_rec.seq := seq_io;
   new_rec.resolved := resolved_io;
   new_rec.res_action_id := res_action_id_io;
   new_rec.rev_player_id := rev_player_id_io;
   --
   actions_tab.ins(new_rec);
   --
   id_io := new_rec.id;
   actions_sub_type_io := new_rec.actions_sub_type;
   player_id_io := new_rec.player_id;
   seq_io := new_rec.seq;
   resolved_io := new_rec.resolved;
   res_action_id_io := new_rec.res_action_id;
   rev_player_id_io := new_rec.rev_player_id;
   return;
   util.trc_time_interval('actions_dml.ins2(tab col) ID:' || id_io, start_tstamp);
end ins2;
----------
function ins2
      (id_io  in out nocopy  NUMBER
      ,actions_sub_type_io  in out nocopy  VARCHAR2
      ,player_id_io  in out nocopy  NUMBER
      ,seq_io  in out nocopy  NUMBER
      ,resolved_io  in out nocopy  VARCHAR2
      ,res_action_id_io  in out nocopy  NUMBER
      ,rev_player_id_io  in out nocopy  NUMBER
      ) return varchar2
is
begin
   ins2
      (id_io
      ,actions_sub_type_io
      ,player_id_io
      ,seq_io
      ,resolved_io
      ,res_action_id_io
      ,rev_player_id_io
      );
   return '';
exception when others then return sqlerrm;
end ins2;
----------------------------------------
-- Special Use Update for Specific Column Updates.
--   Only differences between old and new data will be updated.
--   Set upd_val_in TRUE to get updated data in new_rec
procedure upd
      (old_rec  in  actions_act%ROWTYPE
      ,new_rec  in out nocopy  actions_act%ROWTYPE
      ,upd_vals_in  in  boolean default FALSE
      )
is
   old_tab  actions%ROWTYPE;
   new_tab  actions%ROWTYPE;
   start_tstamp  timestamp := systimestamp;
begin
   if old_rec.id is null then
      raise_application_error (-20023, 'ID is null');
   end if;
   -- Set self-referencing n_res_action_id, if needed
   if new_rec.res_action_id is null then
      if    new_rec.res_actions_nk1 = new_rec.players_nk1
        and new_rec.res_actions_nk2 = new_rec.players_nk2
        and new_rec.res_actions_nk3 = new_rec.players_nk3
        and new_rec.res_actions_nk4 = new_rec.seq
      then
         if new_rec.id is not null then
            new_rec.res_action_id := new_rec.id;
         else
            -- An ID of "0" during insert is a flag to the actions_TAB
            --   package to duplicate the new ID in this self-referenced ID
            new_rec.res_action_id := 0;
         end if;
      end if;
   end if;
   -- Set new_rec.res_action_id from new_rec.res_id_path, if needed
   if new_rec.res_action_id is null then
      if new_rec.res_id_path is not null then
         new_rec.res_action_id := actions_tab.get_res_id_by_id_path(new_rec.res_id_path);
         if new_rec.res_action_id is null then
            raise_application_error(-20020, 'Null ID was returned from actions_tab.get_res_id_by_id_path');
         end if;
      -- Set new_rec.res_action_id from new_rec.res_nk_path, if needed
      elsif new_rec.res_nk_path is not null then
         new_rec.res_action_id := get_res_id_by_nk_path(new_rec.res_nk_path);
         if new_rec.res_action_id is null then
            raise_application_error(-20020, 'Null ID was returned from get_res_id_by_nk_path');
         end if;
      else
      -- Lack of proper indentation is for convenience of generator
      if    new_rec.res_actions_nk1 is not null
        and new_rec.res_actions_nk2 is not null
        and new_rec.res_actions_nk3 is not null
        and new_rec.res_actions_nk4 is not null
      then
         new_rec.res_action_id := actions_tab.get_id
            (new_rec.res_actions_nk1
            ,new_rec.res_actions_nk2
            ,new_rec.res_actions_nk3
            ,new_rec.res_actions_nk4
            );
         if new_rec.res_action_id is null then
            raise_application_error(-20020, 'Null ID was returned from actions_tab.get_id');
         end if;
      end if;
      -- Lack of proper indentation is for convenience of generator
      end if;
   end if;
   -- Set new_rec.player_id, if needed
   if new_rec.player_id is null then
      if    new_rec.players_nk1 is not null
        and new_rec.players_nk2 is not null
        and new_rec.players_nk3 is not null
      then
         new_rec.player_id := players_tab.get_id
            (new_rec.players_nk1
            ,new_rec.players_nk2
            ,new_rec.players_nk3
            );
         if new_rec.player_id is null then
            raise_application_error(-20020, 'Null ID was returned from players_tab.get_id');
         end if;
      end if;
   end if;
   -- Set new_rec.rev_player_id, if needed
   if new_rec.rev_player_id is null then
      if    new_rec.rev_players_nk1 is not null
        and new_rec.rev_players_nk2 is not null
        and new_rec.rev_players_nk3 is not null
      then
         new_rec.rev_player_id := players_tab.get_id
            (new_rec.rev_players_nk1
            ,new_rec.rev_players_nk2
            ,new_rec.rev_players_nk3
            );
         if new_rec.rev_player_id is null then
            raise_application_error(-20020, 'Null ID was returned from players_tab.get_id');
         end if;
      end if;
   end if;
   -- Set self-referencing n_res_action_id, if needed
   if util.is_equal(new_rec.res_action_id, old_rec.res_action_id) then
      if    new_rec.res_actions_nk1 = new_rec.players_nk1
        and new_rec.res_actions_nk2 = new_rec.players_nk2
        and new_rec.res_actions_nk3 = new_rec.players_nk3
        and new_rec.res_actions_nk4 = new_rec.seq
      then
         new_rec.res_action_id := old_rec.id;
      end if;
   end if;
   -- Set new_rec.res_action_id from new_rec.res_id_path, if needed
   if util.is_equal(new_rec.res_action_id, old_rec.res_action_id) then
      if not util.is_equal(new_rec.res_id_path, actions_tab.get_res_id_path(old_rec.id)) and
         not util.is_equal(new_rec.res_id_path, old_rec.res_id_path)
      then
         new_rec.res_action_id := actions_tab.get_res_id_by_id_path(new_rec.res_id_path);
         if new_rec.res_action_id is null then
            raise_application_error(-20020, 'Null ID was returned from actions_tab.get_res_id_by_id_path');
         end if;
      -- Set new_rec.res_action_id from new_rec.res_nk_path, if needed
      elsif util.is_equal(new_rec.res_action_id, old_rec.res_action_id) and
            not util.is_equal(new_rec.res_nk_path, actions_tab.get_res_nk_path(old_rec.id)) and
            not util.is_equal(new_rec.res_nk_path, old_rec.res_nk_path)
      then
         new_rec.res_action_id := get_res_id_by_nk_path(new_rec.res_nk_path);
         if new_rec.res_action_id is null then
            raise_application_error(-20020, 'Null ID was returned from get_res_id_by_nk_path');
         end if;
      else
      -- Lack of proper indentation is for convenience of generator
      if    not util.is_equal(new_rec.res_actions_nk1, old_rec.res_actions_nk1)
        or  not util.is_equal(new_rec.res_actions_nk2, old_rec.res_actions_nk2)
        or  not util.is_equal(new_rec.res_actions_nk3, old_rec.res_actions_nk3)
        or  not util.is_equal(new_rec.res_actions_nk4, old_rec.res_actions_nk4)
      then
         new_rec.res_action_id := actions_tab.get_id
            (new_rec.res_actions_nk1
            ,new_rec.res_actions_nk2
            ,new_rec.res_actions_nk3
            ,new_rec.res_actions_nk4
            );
         if new_rec.res_action_id is null then
            raise_application_error(-20020, 'Null ID was returned from actions_tab.get_id');
         end if;
      end if;
      -- Lack of proper indentation is for convenience of generator
      end if;
   end if;
   -- Set new_rec.player_id, if needed
   if new_rec.player_id = old_rec.player_id then
      if    not (new_rec.players_nk1 = old_rec.players_nk1)
        or  not (new_rec.players_nk2 = old_rec.players_nk2)
        or  not (new_rec.players_nk3 = old_rec.players_nk3)
      then
         new_rec.player_id := players_tab.get_id
            (new_rec.players_nk1
            ,new_rec.players_nk2
            ,new_rec.players_nk3
            );
         if new_rec.player_id is null then
            raise_application_error(-20020, 'Null ID was returned from players_tab.get_id');
         end if;
      end if;
   end if;
   -- Set new_rec.rev_player_id, if needed
   if util.is_equal(new_rec.rev_player_id, old_rec.rev_player_id) then
      if    not util.is_equal(new_rec.rev_players_nk1, old_rec.rev_players_nk1)
        or  not util.is_equal(new_rec.rev_players_nk2, old_rec.rev_players_nk2)
        or  not util.is_equal(new_rec.rev_players_nk3, old_rec.rev_players_nk3)
      then
         new_rec.rev_player_id := players_tab.get_id
            (new_rec.rev_players_nk1
            ,new_rec.rev_players_nk2
            ,new_rec.rev_players_nk3
            );
         if new_rec.rev_player_id is null then
            raise_application_error(-20020, 'Null ID was returned from players_tab.get_id');
         end if;
      end if;
   end if;
   -- Load the Table Record from the View Record
   old_tab.id := old_rec.id;
   new_tab.id := new_rec.id;
   old_tab.actions_sub_type := old_rec.actions_sub_type;
   new_tab.actions_sub_type := new_rec.actions_sub_type;
   old_tab.player_id := old_rec.player_id;
   new_tab.player_id := new_rec.player_id;
   old_tab.seq := old_rec.seq;
   new_tab.seq := new_rec.seq;
   old_tab.resolved := old_rec.resolved;
   new_tab.resolved := new_rec.resolved;
   old_tab.res_action_id := old_rec.res_action_id;
   new_tab.res_action_id := new_rec.res_action_id;
   old_tab.rev_player_id := old_rec.rev_player_id;
   new_tab.rev_player_id := new_rec.rev_player_id;
   -- Run the update
   actions_tab.upd(old_tab, new_tab);
   if upd_vals_in then
      -- Load the View Record from the Returned (new) Table Record
      -- actions_tab.upd should have set new ID = old ID
      select * into new_rec from actions_act
       where id = old_tab.id;
   end if;
   return;
   util.trc_time_interval('actions_dml.upd(trigger) ID:' || old_tab.id, start_tstamp);
end upd;
----------
function upd
      (old_rec  in  actions_act%ROWTYPE
      ,new_rec  in out nocopy  actions_act%ROWTYPE
      ,upd_vals_in  in  boolean default FALSE
      ) return varchar2
is
begin
   upd(old_rec, new_rec, upd_vals_in);
   return '';
exception when others then return sqlerrm;
end upd;
----------------------------------------
-- Special Use Update for Specific Column Updates.
--   Only differences between old and new data will be updated.
--   Set upd_val_in TRUE to get updated data in new_rec
procedure upd
      (old_tab  in  actions%ROWTYPE
      ,new_tab  in out nocopy  actions%ROWTYPE
      )
is
   start_tstamp  timestamp := systimestamp;
begin
   if old_tab.id is null then
      raise_application_error (-20023, 'ID is null');
   end if;
   -- Run the update
   actions_tab.upd(old_tab, new_tab);
   return;
   util.trc_time_interval('actions_dml.upd(trigger) ID:' || old_tab.id, start_tstamp);
end upd;
----------
function upd
      (old_tab  in  actions%ROWTYPE
      ,new_tab  in out nocopy  actions%ROWTYPE
      ) return varchar2
is
begin
   upd(old_tab, new_tab);
   return '';
exception when others then return sqlerrm;
end upd;
----------------------------------------
-- Update a actions ACTIVE View Record
procedure upd
      (new_rec  in out nocopy  actions_act%ROWTYPE
      ,upd_vals_in  in  boolean default TRUE
      )
is
   old_rec  actions_act%ROWTYPE;
   start_tstamp  timestamp := systimestamp;
begin
   if new_rec.id is null then
      if    new_rec.players_nk1 is not null
        and new_rec.players_nk2 is not null
        and new_rec.players_nk3 is not null
        and new_rec.seq is not null
      then
         new_rec.id := actions_tab.get_id
            (new_rec.players_nk1
            ,new_rec.players_nk2
            ,new_rec.players_nk3
            ,new_rec.seq
            );
      end if;
   end if;
   if new_rec.id is null then
      if    new_rec.player_id is not null
        and new_rec.seq is not null
      then
         begin
            select id into new_rec.id from actions
             where player_id = new_rec.player_id
              and  seq = new_rec.seq
               ;
         exception when NO_DATA_FOUND then new_rec.id := null;
         end;
      end if;
   end if;
   if new_rec.id is null then
      raise_application_error (-20023, 'ID is null and could not be found from Natural Keys');
   end if;
   select * into old_rec from actions_act
    where id = new_rec.id;
   upd(old_rec, new_rec, upd_vals_in);
   return;
   util.trc_time_interval('actions_dml.upd(act rec) ID:' || new_rec.id, start_tstamp);
end upd;
----------
function upd
      (new_rec  in out nocopy  actions_act%ROWTYPE
      ,upd_vals_in  in  boolean default TRUE
      ) return varchar2
is
begin
   upd(new_rec, upd_vals_in);
   return '';
exception when others then return sqlerrm;
end upd;
----------------------------------------
-- Update a actions Table Record
procedure upd
      (new_tab   in out nocopy  actions%ROWTYPE
      )
is
   start_tstamp  timestamp := systimestamp;
begin
   if new_tab.id is null then
      if    new_tab.player_id is not null
        and new_tab.seq is not null
      then
         begin
            select id into new_tab.id from actions
             where player_id = new_tab.player_id
              and  seq = new_tab.seq
               ;
         exception when NO_DATA_FOUND then new_tab.id := null;
         end;
      end if;
   end if;
   if new_tab.id is null then
      raise_application_error (-20023, 'ID is null and could not be found from Natural Keys');
   end if;
   actions_tab.upd(new_tab);
   return;
   util.trc_time_interval('actions_dml.upd(tab rec) ID:' || new_tab.id, start_tstamp);
end upd;
----------
function upd
      (new_tab   in out nocopy  actions%ROWTYPE
      ) return varchar2
is
begin
   upd(new_tab);
   return '';
exception when others then return sqlerrm;
end upd;
----------------------------------------
-- Update columns for actions ACTIVE View
--   without returning updated data in each column
procedure upd
      (id_in  in  NUMBER default null
      ,actions_sub_type_in  in  VARCHAR2 default null
      ,player_id_in  in  NUMBER default null
      ,players_nk1_in  in  VARCHAR2 default null
      ,players_nk2_in  in  VARCHAR2 default null
      ,players_nk3_in  in  VARCHAR2 default null
      ,seq_in  in  NUMBER default null
      ,resolved_in  in  VARCHAR2 default null
      ,res_action_id_in  in  NUMBER default null
      ,res_id_path_in  in  VARCHAR2 default null
      ,res_nk_path_in  in  VARCHAR2 default null
      ,res_actions_nk1_in  in  VARCHAR2 default null
      ,res_actions_nk2_in  in  VARCHAR2 default null
      ,res_actions_nk3_in  in  VARCHAR2 default null
      ,res_actions_nk4_in  in  NUMBER default null
      ,rev_player_id_in  in  NUMBER default null
      ,rev_players_nk1_in  in  VARCHAR2 default null
      ,rev_players_nk2_in  in  VARCHAR2 default null
      ,rev_players_nk3_in  in  VARCHAR2 default null
      )
is
   new_rec  actions_act%ROWTYPE;
   start_tstamp  timestamp := systimestamp;
begin
   new_rec.id := id_in;
   new_rec.actions_sub_type := actions_sub_type_in;
   new_rec.player_id := player_id_in;
   new_rec.players_nk1 := players_nk1_in;
   new_rec.players_nk2 := players_nk2_in;
   new_rec.players_nk3 := players_nk3_in;
   new_rec.seq := seq_in;
   new_rec.resolved := resolved_in;
   new_rec.res_action_id := res_action_id_in;
   new_rec.res_id_path := res_id_path_in;
   new_rec.res_nk_path := res_nk_path_in;
   new_rec.res_actions_nk1 := res_actions_nk1_in;
   new_rec.res_actions_nk2 := res_actions_nk2_in;
   new_rec.res_actions_nk3 := res_actions_nk3_in;
   new_rec.res_actions_nk4 := res_actions_nk4_in;
   new_rec.rev_player_id := rev_player_id_in;
   new_rec.rev_players_nk1 := rev_players_nk1_in;
   new_rec.rev_players_nk2 := rev_players_nk2_in;
   new_rec.rev_players_nk3 := rev_players_nk3_in;
   -- Make corrections when ID is supplied, but NK is missing
   if    new_rec.ID is not null
     and new_rec.players_nk1 is null
     and new_rec.players_nk2 is null
     and new_rec.players_nk3 is null
     and new_rec.seq is null
   then
      select ACT.players_nk1
            ,ACT.players_nk2
            ,ACT.players_nk3
            ,ACT.seq
       into  new_rec.players_nk1
            ,new_rec.players_nk2
            ,new_rec.players_nk3
            ,new_rec.seq
       from  actions_act  ACT
       where ACT.id = new_rec.ID;
   end if;
   -- Make corrections when player_id is supplied, but the Natural Key is missing
   if    new_rec.player_id is not null
     and new_rec.players_nk1 is null
     and new_rec.players_nk2 is null
     and new_rec.players_nk3 is null
   then
      select PLY.games_nk1
            ,PLY.games_nk2
            ,PLY.name
       into  new_rec.players_nk1
            ,new_rec.players_nk2
            ,new_rec.players_nk3
       from  players_act  PLY
       where PLY.id = new_rec.player_id;
   end if;
   -- Make corrections when res_action_id is supplied, but the Natural Key is missing
   if    new_rec.res_action_id is not null
     and new_rec.res_actions_nk1 is null
     and new_rec.res_actions_nk2 is null
     and new_rec.res_actions_nk3 is null
     and new_rec.res_actions_nk4 is null
   then
      select ACT.players_nk1
            ,ACT.players_nk2
            ,ACT.players_nk3
            ,ACT.seq
       into  new_rec.res_actions_nk1
            ,new_rec.res_actions_nk2
            ,new_rec.res_actions_nk3
            ,new_rec.res_actions_nk4
       from  actions_act  ACT
       where ACT.id = new_rec.res_action_id;
   end if;
   -- Make corrections when rev_player_id is supplied, but the Natural Key is missing
   if    new_rec.rev_player_id is not null
     and new_rec.rev_players_nk1 is null
     and new_rec.rev_players_nk2 is null
     and new_rec.rev_players_nk3 is null
   then
      select PLY.games_nk1
            ,PLY.games_nk2
            ,PLY.name
       into  new_rec.rev_players_nk1
            ,new_rec.rev_players_nk2
            ,new_rec.rev_players_nk3
       from  players_act  PLY
       where PLY.id = new_rec.rev_player_id;
   end if;
   upd(new_rec, FALSE);
   return;
   util.trc_time_interval('actions_dml.upd(act col) ID:' || id_in, start_tstamp);
end upd;
----------
function upd
      (id_in  in  NUMBER default null
      ,actions_sub_type_in  in  VARCHAR2 default null
      ,player_id_in  in  NUMBER default null
      ,players_nk1_in  in  VARCHAR2 default null
      ,players_nk2_in  in  VARCHAR2 default null
      ,players_nk3_in  in  VARCHAR2 default null
      ,seq_in  in  NUMBER default null
      ,resolved_in  in  VARCHAR2 default null
      ,res_action_id_in  in  NUMBER default null
      ,res_id_path_in  in  VARCHAR2 default null
      ,res_nk_path_in  in  VARCHAR2 default null
      ,res_actions_nk1_in  in  VARCHAR2 default null
      ,res_actions_nk2_in  in  VARCHAR2 default null
      ,res_actions_nk3_in  in  VARCHAR2 default null
      ,res_actions_nk4_in  in  NUMBER default null
      ,rev_player_id_in  in  NUMBER default null
      ,rev_players_nk1_in  in  VARCHAR2 default null
      ,rev_players_nk2_in  in  VARCHAR2 default null
      ,rev_players_nk3_in  in  VARCHAR2 default null
      ) return varchar2
is
begin
   upd
      (id_in
      ,actions_sub_type_in
      ,player_id_in
      ,players_nk1_in
      ,players_nk2_in
      ,players_nk3_in
      ,seq_in
      ,resolved_in
      ,res_action_id_in
      ,res_id_path_in
      ,res_nk_path_in
      ,res_actions_nk1_in
      ,res_actions_nk2_in
      ,res_actions_nk3_in
      ,res_actions_nk4_in
      ,rev_player_id_in
      ,rev_players_nk1_in
      ,rev_players_nk2_in
      ,rev_players_nk3_in
      );
   return '';
exception when others then return sqlerrm;
end upd;
----------------------------------------
-- Update columns for actions ACTIVE View
--   with updated data returned in each column
procedure upd2
      (id_io  in out nocopy  NUMBER
      ,actions_sub_type_io  in out nocopy  VARCHAR2
      ,player_id_io  in out nocopy  NUMBER
      ,players_nk1_io  in out nocopy  VARCHAR2
      ,players_nk2_io  in out nocopy  VARCHAR2
      ,players_nk3_io  in out nocopy  VARCHAR2
      ,seq_io  in out nocopy  NUMBER
      ,resolved_io  in out nocopy  VARCHAR2
      ,res_action_id_io  in out nocopy  NUMBER
      ,res_id_path_io  in out nocopy  VARCHAR2
      ,res_nk_path_io  in out nocopy  VARCHAR2
      ,res_actions_nk1_io  in out nocopy  VARCHAR2
      ,res_actions_nk2_io  in out nocopy  VARCHAR2
      ,res_actions_nk3_io  in out nocopy  VARCHAR2
      ,res_actions_nk4_io  in out nocopy  NUMBER
      ,rev_player_id_io  in out nocopy  NUMBER
      ,rev_players_nk1_io  in out nocopy  VARCHAR2
      ,rev_players_nk2_io  in out nocopy  VARCHAR2
      ,rev_players_nk3_io  in out nocopy  VARCHAR2
      )
is
   new_rec  actions_act%ROWTYPE;
   start_tstamp  timestamp := systimestamp;
begin
   new_rec.id := id_io;
   new_rec.actions_sub_type := actions_sub_type_io;
   new_rec.player_id := player_id_io;
   new_rec.players_nk1 := players_nk1_io;
   new_rec.players_nk2 := players_nk2_io;
   new_rec.players_nk3 := players_nk3_io;
   new_rec.seq := seq_io;
   new_rec.resolved := resolved_io;
   new_rec.res_action_id := res_action_id_io;
   new_rec.res_id_path := res_id_path_io;
   new_rec.res_nk_path := res_nk_path_io;
   new_rec.res_actions_nk1 := res_actions_nk1_io;
   new_rec.res_actions_nk2 := res_actions_nk2_io;
   new_rec.res_actions_nk3 := res_actions_nk3_io;
   new_rec.res_actions_nk4 := res_actions_nk4_io;
   new_rec.rev_player_id := rev_player_id_io;
   new_rec.rev_players_nk1 := rev_players_nk1_io;
   new_rec.rev_players_nk2 := rev_players_nk2_io;
   new_rec.rev_players_nk3 := rev_players_nk3_io;
   --
   --  upd(new_rec) will set new_rec.id as needed
   upd(new_rec);
   --
   id_io := new_rec.id;
   actions_sub_type_io := new_rec.actions_sub_type;
   player_id_io := new_rec.player_id;
   players_nk1_io := new_rec.players_nk1;
   players_nk2_io := new_rec.players_nk2;
   players_nk3_io := new_rec.players_nk3;
   seq_io := new_rec.seq;
   resolved_io := new_rec.resolved;
   res_action_id_io := new_rec.res_action_id;
   res_id_path_io := new_rec.res_id_path;
   res_nk_path_io := new_rec.res_nk_path;
   res_actions_nk1_io := new_rec.res_actions_nk1;
   res_actions_nk2_io := new_rec.res_actions_nk2;
   res_actions_nk3_io := new_rec.res_actions_nk3;
   res_actions_nk4_io := new_rec.res_actions_nk4;
   rev_player_id_io := new_rec.rev_player_id;
   rev_players_nk1_io := new_rec.rev_players_nk1;
   rev_players_nk2_io := new_rec.rev_players_nk2;
   rev_players_nk3_io := new_rec.rev_players_nk3;
   return;
   util.trc_time_interval('actions_dml.upd2(act col) ID:' || id_io, start_tstamp);
end upd2;
----------
function upd2
      (id_io  in out nocopy  NUMBER
      ,actions_sub_type_io  in out nocopy  VARCHAR2
      ,player_id_io  in out nocopy  NUMBER
      ,players_nk1_io  in out nocopy  VARCHAR2
      ,players_nk2_io  in out nocopy  VARCHAR2
      ,players_nk3_io  in out nocopy  VARCHAR2
      ,seq_io  in out nocopy  NUMBER
      ,resolved_io  in out nocopy  VARCHAR2
      ,res_action_id_io  in out nocopy  NUMBER
      ,res_id_path_io  in out nocopy  VARCHAR2
      ,res_nk_path_io  in out nocopy  VARCHAR2
      ,res_actions_nk1_io  in out nocopy  VARCHAR2
      ,res_actions_nk2_io  in out nocopy  VARCHAR2
      ,res_actions_nk3_io  in out nocopy  VARCHAR2
      ,res_actions_nk4_io  in out nocopy  NUMBER
      ,rev_player_id_io  in out nocopy  NUMBER
      ,rev_players_nk1_io  in out nocopy  VARCHAR2
      ,rev_players_nk2_io  in out nocopy  VARCHAR2
      ,rev_players_nk3_io  in out nocopy  VARCHAR2
      ) return varchar2
is
begin
   upd2
      (id_io
      ,actions_sub_type_io
      ,player_id_io
      ,players_nk1_io
      ,players_nk2_io
      ,players_nk3_io
      ,seq_io
      ,resolved_io
      ,res_action_id_io
      ,res_id_path_io
      ,res_nk_path_io
      ,res_actions_nk1_io
      ,res_actions_nk2_io
      ,res_actions_nk3_io
      ,res_actions_nk4_io
      ,rev_player_id_io
      ,rev_players_nk1_io
      ,rev_players_nk2_io
      ,rev_players_nk3_io
      );
   return '';
exception when others then return sqlerrm;
end upd2;
----------------------------------------
-- Update columns for actions Table
--   with updated data returned in each column
procedure upd2
      (id_io  in out nocopy  NUMBER
      ,actions_sub_type_io  in out nocopy  VARCHAR2
      ,player_id_io  in out nocopy  NUMBER
      ,seq_io  in out nocopy  NUMBER
      ,resolved_io  in out nocopy  VARCHAR2
      ,res_action_id_io  in out nocopy  NUMBER
      ,rev_player_id_io  in out nocopy  NUMBER
      )
is
   new_rec  actions%ROWTYPE;
   start_tstamp  timestamp := systimestamp;
begin
   if id_io is null then
      if    player_id_io is not null
        and seq_io is not null
      then
         begin
            select id into id_io from actions
             where player_id = player_id_io
              and  seq = seq_io
               ;
         exception when NO_DATA_FOUND then id_io := null;
         end;
      end if;
   end if;
   if id_io is null then
      raise_application_error (-20023, 'ID is null and could not be found from Natural Keys');
   end if;
   new_rec.id := id_io;
   new_rec.actions_sub_type := actions_sub_type_io;
   new_rec.player_id := player_id_io;
   new_rec.seq := seq_io;
   new_rec.resolved := resolved_io;
   new_rec.res_action_id := res_action_id_io;
   new_rec.rev_player_id := rev_player_id_io;
   --
   actions_tab.upd(new_rec);
   --
   id_io := new_rec.id;
   actions_sub_type_io := new_rec.actions_sub_type;
   player_id_io := new_rec.player_id;
   seq_io := new_rec.seq;
   resolved_io := new_rec.resolved;
   res_action_id_io := new_rec.res_action_id;
   rev_player_id_io := new_rec.rev_player_id;
   return;
   util.trc_time_interval('actions_dml.upd2(tab col) ID:' || id_io, start_tstamp);
end upd2;
----------
function upd2
      (id_io  in out nocopy  NUMBER
      ,actions_sub_type_io  in out nocopy  VARCHAR2
      ,player_id_io  in out nocopy  NUMBER
      ,seq_io  in out nocopy  NUMBER
      ,resolved_io  in out nocopy  VARCHAR2
      ,res_action_id_io  in out nocopy  NUMBER
      ,rev_player_id_io  in out nocopy  NUMBER
      ) return varchar2
is
begin
    upd2
      (id_io
      ,actions_sub_type_io
      ,player_id_io
      ,seq_io
      ,resolved_io
      ,res_action_id_io
      ,rev_player_id_io
      );
   return '';
exception when others then return sqlerrm;
end upd2;

----------------------------------------
-- Application Delete procedure without updated parameters
procedure del
      (id_in  in  NUMBER default null
      ,player_id_in  in  NUMBER default null
      ,players_nk1_in  in  VARCHAR2 default null
      ,players_nk2_in  in  VARCHAR2 default null
      ,players_nk3_in  in  VARCHAR2 default null
      ,seq_in  in  NUMBER default null
      )
is
   start_tstamp  timestamp := systimestamp;
   tmp_id  NUMBER;
begin
   tmp_id := id_in;
   if tmp_id is null then
      if    players_nk1_in is not null
        and players_nk2_in is not null
        and players_nk3_in is not null
        and seq_in is not null
      then
         tmp_id := actions_tab.get_id
            (players_nk1_in
            ,players_nk2_in
            ,players_nk3_in
            ,seq_in
            );
      end if;
   end if;
   if tmp_id is null then
      if    player_id_in is not null
        and seq_in is not null
      then
         begin
            select id into tmp_id from actions
             where player_id = player_id_in
              and  seq = seq_in
               ;
         exception when NO_DATA_FOUND then tmp_id := null;
         end;
      end if;
   end if;
   if tmp_id is null then
      raise_application_error (-20023, 'ID is null and could not be found from Natural Keys');
   end if;
   actions_tab.del(tmp_id);
   return;
   util.trc_time_interval('actions_dml.del ID:' || id_in, start_tstamp);
end del;
----------
function del
      (id_in  in  NUMBER default null
      ,player_id_in  in  NUMBER default null
      ,players_nk1_in  in  VARCHAR2 default null
      ,players_nk2_in  in  VARCHAR2 default null
      ,players_nk3_in  in  VARCHAR2 default null
      ,seq_in  in  NUMBER default null
      ) return varchar2
is
begin
   del
      (id_in
      ,player_id_in
      ,players_nk1_in
      ,players_nk2_in
      ,players_nk3_in
      ,seq_in
      );
   return '';
exception when others then return sqlerrm;
end del;
----------------------------------------
-- Application Delete procedure with updated parameters
procedure del2
      (id_io  in out nocopy  NUMBER
      ,player_id_in  in  NUMBER default null
      ,players_nk1_in  in  VARCHAR2 default null
      ,players_nk2_in  in  VARCHAR2 default null
      ,players_nk3_in  in  VARCHAR2 default null
      ,seq_in  in  NUMBER default null
      )
is
   start_tstamp  timestamp := systimestamp;
begin
   if id_io is null then
      if    players_nk1_in is not null
        and players_nk2_in is not null
        and players_nk3_in is not null
        and seq_in is not null
      then
         id_io := actions_tab.get_id
            (players_nk1_in
            ,players_nk2_in
            ,players_nk3_in
            ,seq_in
            );
      end if;
   end if;
   if id_io is null then
      if    player_id_in is not null
        and seq_in is not null
      then
         begin
            select id into id_io from actions
             where player_id = player_id_in
              and  seq = seq_in
               ;
         exception when NO_DATA_FOUND then id_io := null;
         end;
      end if;
   end if;
   if id_io is null then
      raise_application_error (-20023, 'ID is null and could not be found from Natural Keys');
   end if;
   actions_tab.del(id_io);
   return;
   util.trc_time_interval('actions_dml.del2 ID:' || id_io, start_tstamp);
end del2;
----------
function del2
      (id_io  in out nocopy  NUMBER
      ,player_id_in  in  NUMBER default null
      ,players_nk1_in  in  VARCHAR2 default null
      ,players_nk2_in  in  VARCHAR2 default null
      ,players_nk3_in  in  VARCHAR2 default null
      ,seq_in  in  NUMBER default null
      ) return varchar2
is
begin
   del2
      (id_io
      ,player_id_in
      ,players_nk1_in
      ,players_nk2_in
      ,players_nk3_in
      ,seq_in
      );
   return '';
exception when others then return sqlerrm;
end del2;
----------------------------------------
procedure load_dim
      (dim_tab  in out nocopy  actions%ROWTYPE
      )
is
   -- Special Data Warehouse Dimension Function
   start_tstamp  timestamp := systimestamp;
   procedure private_upd is
      saved_inc  boolean := util.get_ignore_no_change;
   begin
      util.set_ignore_no_change(TRUE);
      upd (dim_tab);
      util.set_ignore_no_change(saved_inc);
   exception
      when others then
         util.set_ignore_no_change(saved_inc);
         raise;
   end private_upd;
begin
   -- Attempt to find matching record based on natural keys
   if dim_tab.id is null then
      begin
         select id
          into  dim_tab.id
          from  actions
          where player_id = dim_tab.player_id
           and  player_id = dim_tab.player_id
           and  seq = dim_tab.seq
         ;
      exception
         when NO_DATA_FOUND then dim_tab.id := null;
      end;
   end if;
   if dim_tab.id is not null then
      -- If found, perform update on non-NK columns that changed
      private_upd;
      return;
      util.trc_time_interval('actions_dml.load_dimE ID:' || dim_tab.id, start_tstamp);
   end if;
   -- If not found, insert new record
   begin
      ins(dim_tab);
   exception
      when DUP_VAL_ON_INDEX then
         -- Since this can run multi-threaded, another thread
         --   may have already populated this value.
         private_upd;
   end;
   return;
   util.trc_time_interval('actions_dml.load_dim ID:' || dim_tab.id, start_tstamp);
end load_dim;
----------
function load_dim
      (dim_tab  in out nocopy  actions%ROWTYPE
      ) return varchar2
is
begin
   load_dim(dim_tab);
   return '';
exception when others then return sqlerrm;
end load_dim;
----------------------------------------
end actions_dml;
/

set define on
