
--
--  Create CLUE.ACTIONS_TAB Package Body
--

set define off


--DBMS_METADATA:CLUE.ACTIONS_TAB

  CREATE OR REPLACE EDITIONABLE PACKAGE BODY "CLUE"."ACTIONS_TAB" 
is

-- Package Body Actions_Tab
--    Table functions and integrity checks)

   -- Application: Clue Notes For Oracle
   -- Generated by DTGen (http://dmstex.com/services/dtgen)
   -- December  16, 2013  11:32:29 AM

   --
   --
   -- ? Duane.Dieterich@DMSTEX.com 2013
   --
   -- All Rights Reserved
   --
   -- No part of this software may be reproduced, copied, modified or adapted,
   -- without the prior written consent of the author, unless otherwise
   -- indicated for stand-alone materials.
   --
   -- You may quote extracts from this software with attribution to
   -- Duane.Dieterich@DMSTEX.com
   --
   -- For any other mode of sharing, please contact Duane.Dieterich@DMSTEX.com.
   --
   -- Commercial use and distribution of this software is not allowed without
   -- express and prior written consent of the author.
   --
   -- THE SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
   -- INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY
   -- AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL
   -- THE COPYRIGHT HOLDER OR DMSTEX BUSINESS SOLUTIONS LLC, ITS MEMBERS,
   -- MANAGERS, OR EMPLOYEES BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
   -- SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
   -- TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
   -- PROFITS; CORRUPTION OF DATA, OR BUSINESS INTERRUPTION) HOWEVER CAUSED
   -- AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
   -- OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF
   -- THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH
   -- DAMAGE.
   --
   --


----------------------------------------
function next_seq
      (player_id_in  in  NUMBER
      ) return number
is
   -- This PRAGMA would prevent "ORA-04091: Mutating Table".  However,
   --   removing the function from the pending transaction prevents it
   --   from "seeing" any newly inserted records that are pending.
   --PRAGMA AUTONOMOUS_TRANSACTION;
   seq_num  number;
begin
   select max(ACT.seq) into seq_num
    from  actions  ACT
         ,players  PLY
    where ACT.player_id = player_id_in
   ;
   return nvl(seq_num,0) + 1;
exception when others then
   if sqlerrm not like 'ORA-04091:%' then raise;
   else raise_application_error(-20027,
      'ORA-04091: Mutating Table Error.  Try using actions_DML package instead');
   end if;
end next_seq;
----------------------------------------
procedure check_rec
      (id  in  NUMBER
      ,actions_sub_type  in out nocopy  VARCHAR2
      ,player_id  in out nocopy  NUMBER
      ,seq  in out nocopy  NUMBER
      ,resolved  in out nocopy  VARCHAR2
      ,res_action_id  in out nocopy  NUMBER
      ,rev_player_id  in out nocopy  NUMBER
      )
is
   --------------------
   procedure cknl_res_action_id (stname_in varchar2) is begin
      if res_action_id is not null then
         if util.get_fix_non_null_sub_types then
            res_action_id := null;
         else
            raise_application_error(-20026, 'actions_tab.check_rec(): res_action_id must be null for sub-type: ' || stname_in);
         end if;
      end if;
   end cknl_res_action_id;
   --------------------
   procedure cknl_rev_player_id (stname_in varchar2) is begin
      if rev_player_id is not null then
         if util.get_fix_non_null_sub_types then
            rev_player_id := null;
         else
            raise_application_error(-20026, 'actions_tab.check_rec(): rev_player_id must be null for sub-type: ' || stname_in);
         end if;
      end if;
   end cknl_rev_player_id;
   --------------------
begin
   -- 1) Set Default Values as Needed
   if util.get_use_defaults then
      if resolved is null
      then
         resolved := 'NOT';
      end if;
   end if;
   -- 2) Check for NOT NULL
   if player_id is null then
      raise_application_error(-20004, 'actions_tab.check_rec(): player_id cannot be null.');
   end if;
   if seq is null then
      raise_application_error(-20004, 'actions_tab.check_rec(): seq cannot be null.');
   end if;
   if resolved is null then
      raise_application_error(-20004, 'actions_tab.check_rec(): resolved cannot be null.');
   end if;
   -- 3) Sub-type NULL checks
   case actions_sub_type
   when 'accusation' then
      cknl_res_action_id('accusation');
      cknl_rev_player_id('accusation');
   when 'revelation' then
      cknl_res_action_id('revelation');
      cknl_rev_player_id('revelation');
   when 'suggestion' then
      null;   -- There are no NULL checks for this subtype.
   else
      raise_application_error(-20025, 'actions.check_rec(): actions_sub_type must be one of accusation, revelation, suggestion');
   end case;
   -- 4) Compress Spaces, as needed
   -- 5) Custom Data Handling
   -- 6) Fold the case, as needed
   if util.get_fold_strings then
      resolved := upper(resolved);
   else
      if resolved is not null
      then
         if resolved != upper(resolved) then
            raise_application_error(-20003, 'actions_tab.check_rec(): resolved must be upper case.');
         end if;
      end if;
   end if;
   -- 7) Check for Domain Values
   if resolved is not null
      and not Resolutions_dom.includes(resolved)
   then
      raise_application_error(-20005, 'actions_tab.check_rec(): resolved must be one of ("NOT", "REV", "DED", "UND").');
   end if;
   -- 8) Custom Constraint Checks
   -- These constraints must be written to account for sub-types
   if not (seq > 0)
   then
      raise_application_error(-20006, 'actions_tab.check_rec(): Action Sequence number must be greater than zero');
   end if;
   if not (actions_sub_type != 'suggestion' or resolved in ('NOT','UND') or res_action_id is not null)
   then
      raise_application_error(-20006, 'actions_tab.check_rec(): Resolved Suggestions must have a Resolved Action ID');
   end if;
   if not (resolved not in ('NOT','UND') or res_action_id is null)
   then
      raise_application_error(-20006, 'actions_tab.check_rec(): Unresolved Actions cannot have a Resolved Action ID');
   end if;
   -- 9) Set eff_beg_dtm, if needed
   -- 10) Set aud_beg_usr and aud_beg_dtm
end check_rec;
----------------------------------------
-- Check Constraints for a actions Record
function rec_status
      (id_in  in NUMBER
      )  return varchar2
is
   fs_save    boolean  := util.get_fold_strings;
   ud_save    boolean  := util.get_use_defaults;
   old_tab  actions%ROWTYPE;
   new_tab  actions%ROWTYPE;
begin
   select * into old_tab from actions where id = id_in;
   new_tab := old_tab;
   util.set_fold_strings(FALSE);
   util.set_use_defaults(FALSE);
   check_rec (id  =>  new_tab.id
             ,actions_sub_type  =>  new_tab.actions_sub_type
             ,player_id  =>  new_tab.player_id
             ,seq  =>  new_tab.seq
             ,resolved  =>  new_tab.resolved
             ,res_action_id  =>  new_tab.res_action_id
             ,rev_player_id  =>  new_tab.rev_player_id
             );
   if not util.is_equal(old_tab.id, new_tab.id) then
      return 'Data Storage Error on id';
   end if;
   if not util.is_equal(old_tab.actions_sub_type, new_tab.actions_sub_type) then
      return 'Data Storage Error on actions_sub_type';
   end if;
   if not util.is_equal(old_tab.player_id, new_tab.player_id) then
      return 'Data Storage Error on player_id';
   end if;
   if not util.is_equal(old_tab.seq, new_tab.seq) then
      return 'Data Storage Error on seq';
   end if;
   if not util.is_equal(old_tab.resolved, new_tab.resolved) then
      return 'Data Storage Error on resolved';
   end if;
   if not util.is_equal(old_tab.res_action_id, new_tab.res_action_id) then
      return 'Data Storage Error on res_action_id';
   end if;
   if not util.is_equal(old_tab.rev_player_id, new_tab.rev_player_id) then
      return 'Data Storage Error on rev_player_id';
   end if;
   util.set_use_defaults(ud_save);
   util.set_fold_strings(fs_save);
   return 'OK';
exception
   when others then
      util.set_use_defaults(ud_save);
      util.set_fold_strings(fs_save);
      return sqlerrm;
end rec_status;
----------------------------------------
function get_id
      (actions_nk1  in  VARCHAR2
      ,actions_nk2  in  VARCHAR2
      ,actions_nk3  in  VARCHAR2
      ,actions_nk4  in  NUMBER
      ) return NUMBER
   -- For all the Natural Key Columns, Return an ID
is
   retid  NUMBER(38);
begin
   select id
    into  retid
    from  actions  ACT
    where ACT.player_id = players_tab.get_id
             (actions_nk1
             ,actions_nk2
             ,actions_nk3
             )
     and  ACT.seq = actions_nk4
    ;
   return retid;
exception when no_data_found then return null;
end get_id;
----------------------------------------
function get_nk
      (id_in  in  NUMBER)
   return VARCHAR2
   -- For an ID, return a delimited list of Natural Key Values
is
   rtxt  VARCHAR2(4000);
begin
   select substr(   players_tab.get_nk(ACT.player_id)
    || util.nk_sep || ACT.seq
                         ,1 ,4000)
    into  rtxt
    from  actions ACT
    where ACT.id = id_in;
   return rtxt;
exception when no_data_found then return null;
end get_nk;
----------------------------------------
function get_res_id_path
      (id_in  in  NUMBER)
   return varchar2
   -- For a hierarchy ID, return a delimited list of IDs
is
   rtxt  VARCHAR2(4000) := null;
   rlen  number := 0;
begin
   for buff in (
      select id, level from actions
       start with id = id_in
       connect by nocycle id = prior res_action_id
       order by level desc )
   loop
      rlen := rlen + length(buff.id);
      if rlen > 4000 - 3 then
         return rtxt || '...';
      end if;
      rtxt := rtxt || buff.id || util.path_sep;
   end loop;
   return substr(rtxt,1,length(rtxt)-1);
end get_res_id_path;
----------------------------------------
function get_res_nk_path
      (id_in  in  NUMBER)
   return CLOB
   -- For a hierarchy ID, return a delimited list of
   --    Natural Key sets
is
   rtxt  VARCHAR2(32767) := null;
   rlen  number := 0;
begin
   for buff in (
      select get_nk(id) nk, level
       from  actions
       start with id = id_in
       connect by nocycle id = prior res_action_id
       order by level desc )
   loop
      rlen := rlen + length(buff.nk);
      if rlen > 32767 - 3 then
         return rtxt || '...';
      end if;
      rtxt := rtxt || buff.nk || util.path_sep;
   end loop;
   return substr(rtxt,1,length(rtxt)-1);
end get_res_nk_path;
----------------------------------------
function get_res_id_by_id_path
      (id_path_in  VARCHAR2
      ) return NUMBER
is
   ps_pos     number;    -- Path Seperator position in id_path_in
   id_num     number;    -- ID number in a character string
   retid      NUMBER(38);   -- ID number to Return
begin
   if id_path_in is null then return null; end if;
   ps_pos := instr(id_path_in, util.path_sep, -1, 1);
   begin
      -- This should be the last concatenated Natural Key in nk_path_in
      id_num := to_number(substr(id_path_in, ps_pos+1));
   exception when VALUE_ERROR then return null;
   end;
   select ACT.id
    into  retid
    from  actions ACT
    where ACT.id = id_num
     and  get_res_id_path(ACT.id) = id_path_in;
   return retid;
exception when no_data_found then return null;
end get_res_id_by_id_path;
----------------------------------------
-- Should be called exclusively by the BI Trigger
--   or the "ins" procedure below
procedure ins_bi_trigger
      (n_id  in out nocopy  NUMBER
      ,n_actions_sub_type  in out nocopy  VARCHAR2
      ,n_player_id  in out nocopy  NUMBER
      ,n_seq  in out nocopy  NUMBER
      ,n_resolved  in out nocopy  VARCHAR2
      ,n_res_action_id  in out nocopy  NUMBER
      ,n_rev_player_id  in out nocopy  NUMBER
      )
is
begin
   -- BI Trigger will have run_tab = TRUE, otherwise FALSE
   -- Set n_id, if needed
   if n_id is null then
      select actions_seq.nextval
       into  n_id from dual;
      -- Set the ID on this self-referencing record
      if n_res_action_id = 0 then
         n_res_action_id := n_id;
      end if;
   elsif n_id = 0 then
      raise_application_error(-20019, 'ID of zero is not allowed');
   end if;
   check_rec (id  =>  n_id
             ,actions_sub_type  =>  n_actions_sub_type
             ,player_id  =>  n_player_id
             ,seq  =>  n_seq
             ,resolved  =>  n_resolved
             ,res_action_id  =>  n_res_action_id
             ,rev_player_id  =>  n_rev_player_id
             );
end ins_bi_trigger;
----------------------------------------
-- Can be called from anywhere, except the BI Trigger
procedure ins
      (n_rec  in out nocopy  actions%ROWTYPE
      )
is
begin
   run_tab := FALSE;
   ins_bi_trigger (n_id  =>  n_rec.id
       ,n_actions_sub_type  =>  n_rec.actions_sub_type
       ,n_player_id  =>  n_rec.player_id
       ,n_seq  =>  n_rec.seq
       ,n_resolved  =>  n_rec.resolved
       ,n_res_action_id  =>  n_rec.res_action_id
       ,n_rev_player_id  =>  n_rec.rev_player_id
       );
   insert into actions
         (id
         ,actions_sub_type
         ,player_id
         ,seq
         ,resolved
         ,res_action_id
         ,rev_player_id
         )
   values
         (n_rec.id
         ,n_rec.actions_sub_type
         ,n_rec.player_id
         ,n_rec.seq
         ,n_rec.resolved
         ,n_rec.res_action_id
         ,n_rec.rev_player_id
         );
   run_tab := TRUE;
exception
   when others then
      run_tab := TRUE;
      raise;
end ins;
----------------------------------------
-- Should be called exclusively by the BU Trigger
--   or the "upd" procedure below
-- Note: the OLD values must be provided to check ignore_no_change
-- Note2:  Select for Update Lock is assumed on old values row
procedure upd_bu_trigger
      (o_id  in  NUMBER
      ,o_actions_sub_type  in  VARCHAR2
      ,n_actions_sub_type  in out nocopy  VARCHAR2
      ,o_player_id  in  NUMBER
      ,n_player_id  in out nocopy  NUMBER
      ,o_seq  in  NUMBER
      ,n_seq  in out nocopy  NUMBER
      ,o_resolved  in  VARCHAR2
      ,n_resolved  in out nocopy  VARCHAR2
      ,o_res_action_id  in  NUMBER
      ,n_res_action_id  in out nocopy  NUMBER
      ,o_rev_player_id  in  NUMBER
      ,n_rev_player_id  in out nocopy  NUMBER
      ,run_update  out  boolean
      )
is
begin
   run_update := TRUE;
   -- BU Trigger will have run_tab = TRUE, otherwise FALSE
   if     util.is_equal(o_actions_sub_type, n_actions_sub_type)
     and  o_player_id = n_player_id
     and  o_seq = n_seq
     and  o_resolved = n_resolved
     and  util.is_equal(o_res_action_id, n_res_action_id)
     and  util.is_equal(o_rev_player_id, n_rev_player_id)
   then
      if util.get_ignore_no_change then
         run_update := FALSE;
         return;
      end if;
      raise_application_error(-20008, 'actions_tab.upd(): Must update one of'
            || ' actions_sub_type'
            || ', player_id'
            || ', seq'
            || ', resolved'
            || ', res_action_id'
            || ', rev_player_id'
            || '.');
   end if;
   check_rec (id  =>  o_id
             ,actions_sub_type  =>  n_actions_sub_type
             ,player_id  =>  n_player_id
             ,seq  =>  n_seq
             ,resolved  =>  n_resolved
             ,res_action_id  =>  n_res_action_id
             ,rev_player_id  =>  n_rev_player_id
             );
end upd_bu_trigger;
----------------------------------------
-- Can be called from anywhere, except the BU Trigger
-- Note: the OLD values must be provided to set new_rec values
procedure upd
      (o_rec  in             actions%ROWTYPE
      ,n_rec  in out nocopy  actions%ROWTYPE
      )
is
   c_rec    actions%ROWTYPE;  -- Current Row Data
   run_upd  boolean;
begin
   if o_rec.id is null then return; end if;
   run_tab := FALSE;
   select * into c_rec from actions t1
    where t1.id = o_rec.id FOR UPDATE;
   -- If old and new match, then replace new with current
   --   because there was no original intent to change new
   if util.is_equal(o_rec.actions_sub_type, n_rec.actions_sub_type) then
      n_rec.actions_sub_type := c_rec.actions_sub_type;
   end if;
   if o_rec.player_id = n_rec.player_id then
      n_rec.player_id := c_rec.player_id;
   end if;
   if o_rec.seq = n_rec.seq then
      n_rec.seq := c_rec.seq;
   end if;
   if o_rec.resolved = n_rec.resolved then
      n_rec.resolved := c_rec.resolved;
   end if;
   if util.is_equal(o_rec.res_action_id, n_rec.res_action_id) then
      n_rec.res_action_id := c_rec.res_action_id;
   end if;
   if util.is_equal(o_rec.rev_player_id, n_rec.rev_player_id) then
      n_rec.rev_player_id := c_rec.rev_player_id;
   end if;
   -- Update the new data based on the current data
   upd_bu_trigger (o_id  =>  c_rec.id
      ,o_actions_sub_type  =>  c_rec.actions_sub_type
      ,n_actions_sub_type  =>  n_rec.actions_sub_type
      ,o_player_id  =>  c_rec.player_id
      ,n_player_id  =>  n_rec.player_id
      ,o_seq  =>  c_rec.seq
      ,n_seq  =>  n_rec.seq
      ,o_resolved  =>  c_rec.resolved
      ,n_resolved  =>  n_rec.resolved
      ,o_res_action_id  =>  c_rec.res_action_id
      ,n_res_action_id  =>  n_rec.res_action_id
      ,o_rev_player_id  =>  c_rec.rev_player_id
      ,n_rev_player_id  =>  n_rec.rev_player_id
      ,run_update  =>  run_upd
      );
   if run_upd then
      update actions
        set  actions_sub_type = n_rec.actions_sub_type
            ,player_id = n_rec.player_id
            ,seq = n_rec.seq
            ,resolved = n_rec.resolved
            ,res_action_id = n_rec.res_action_id
            ,rev_player_id = n_rec.rev_player_id
       where id = o_rec.id;
   end if;
   run_tab := TRUE;
exception
   when others then
      run_tab := TRUE;
      raise;
end upd;
----------------------------------------
-- Can be called from anywhere, except the BU Trigger
-- Note: the OLD values must be provided to check ignore_no_change
procedure upd
      (n_rec  in out nocopy  actions%ROWTYPE
      )
is
   c_rec    actions%ROWTYPE;  -- Current Row Data
   run_upd  boolean;
begin
   if n_rec.id is null then return; end if;
   run_tab := FALSE;
   select * into c_rec from actions t1
    where t1.id = n_rec.id FOR UPDATE;
   upd_bu_trigger (o_id  =>  c_rec.id
      ,o_actions_sub_type  =>  c_rec.actions_sub_type
      ,n_actions_sub_type  =>  n_rec.actions_sub_type
      ,o_player_id  =>  c_rec.player_id
      ,n_player_id  =>  n_rec.player_id
      ,o_seq  =>  c_rec.seq
      ,n_seq  =>  n_rec.seq
      ,o_resolved  =>  c_rec.resolved
      ,n_resolved  =>  n_rec.resolved
      ,o_res_action_id  =>  c_rec.res_action_id
      ,n_res_action_id  =>  n_rec.res_action_id
      ,o_rev_player_id  =>  c_rec.rev_player_id
      ,n_rev_player_id  =>  n_rec.rev_player_id
      ,run_update  =>  run_upd
      );
   if run_upd then
      update actions
        set  actions_sub_type = n_rec.actions_sub_type
            ,player_id = n_rec.player_id
            ,seq = n_rec.seq
            ,resolved = n_rec.resolved
            ,res_action_id = n_rec.res_action_id
            ,rev_player_id = n_rec.rev_player_id
       where id = c_rec.id;
   end if;
   run_tab := TRUE;
exception
   when others then
      run_tab := TRUE;
      raise;
end upd;
----------------------------------------
-- There is no delete trigger for this table
----------------------------------------
-- Can be called from anywhere, except the BD Trigger
procedure del
      (o_id  in  NUMBER
      )
is
begin
   -- NOTE: there is no delete trigger for this table
   if o_id is null then return; end if;
   run_tab := FALSE;
   delete from actions ACT
    where ACT.id = o_id;
   run_tab := TRUE;
end del;
----------------------------------------
end actions_tab;
/

set define on
