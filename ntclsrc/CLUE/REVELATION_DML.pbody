
--
--  Create CLUE.REVELATION_DML Package Body
--

set define off


--DBMS_METADATA:CLUE.REVELATION_DML

  CREATE OR REPLACE EDITIONABLE PACKAGE BODY "CLUE"."REVELATION_DML" 
is

   -- Package Body Revelation_Dml
   -- (Data Manipulation Language, Foreign Key and Path Lookup)

   -- Application: Clue Notes For Oracle
   -- Generated by DTGen (http://dmstex.com/services/dtgen)
   -- December  16, 2013  11:32:34 AM

   --
   --
   -- ? Duane.Dieterich@DMSTEX.com 2013
   --
   -- All Rights Reserved
   --
   -- No part of this software may be reproduced, copied, modified or adapted,
   -- without the prior written consent of the author, unless otherwise
   -- indicated for stand-alone materials.
   --
   -- You may quote extracts from this software with attribution to
   -- Duane.Dieterich@DMSTEX.com
   --
   -- For any other mode of sharing, please contact Duane.Dieterich@DMSTEX.com.
   --
   -- Commercial use and distribution of this software is not allowed without
   -- express and prior written consent of the author.
   --
   -- THE SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
   -- INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY
   -- AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL
   -- THE COPYRIGHT HOLDER OR DMSTEX BUSINESS SOLUTIONS LLC, ITS MEMBERS,
   -- MANAGERS, OR EMPLOYEES BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
   -- SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
   -- TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
   -- PROFITS; CORRUPTION OF DATA, OR BUSINESS INTERRUPTION) HOWEVER CAUSED
   -- AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
   -- OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF
   -- THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH
   -- DAMAGE.
   --
   --


--------------------------------------------
-- Return the next Surrogate Key ID for actions
function get_next_id
      return NUMBER
is
   retid  NUMBER;
begin
   select actions_seq.nextval
    into  retid from dual;
   return retid;
end get_next_id;
--------------------------------------------
-- Return the current Surrogate Key ID for actions
function get_curr_id
      return NUMBER
is
   retid  NUMBER;
begin
   select actions_seq.currval
    into  retid from dual;
   return retid;
end get_curr_id;
--------------------------------------------
-- Return the next Surrogate Key ID for the Natural Keys of actions
function get_id
      (players_nk1  in  VARCHAR2
      ,players_nk2  in  VARCHAR2
      ,players_nk3  in  VARCHAR2
      ,seq  in  NUMBER
      ) return NUMBER
is
begin
   return actions_tab.get_id
      (players_nk1
      ,players_nk2
      ,players_nk3
      ,seq
      );
end get_id;
----------------------------------------
-- For all the Natural Key Column IDs, Return an ID
function get_id2
      (player_id_in  in  NUMBER
      ,seq_in  in  NUMBER
      ) return NUMBER
is
   retid  NUMBER(38);
begin
   select id
    into  retid
    from  actions  ACT
    where player_id_in = ACT.player_id
     and  seq_in = ACT.seq
    ;
   return retid;
exception when no_data_found then return null;
end get_id2;
--------------------------------------------
-- Return a concatenated string of Natural Keys for a actions id
function get_nk
      (id_in  in  NUMBER
      ) return VARCHAR2
is
begin
   return actions_tab.get_nk(id_in);
end get_nk;

--------------------------------------------
-- Set a "view" record to null
procedure clear
      (n_rec  in out nocopy  revelation_ACT%ROWTYPE
      )
is
begin
   n_rec.id := null;
   n_rec.player_id := null;
   n_rec.players_nk1 := null;
   n_rec.players_nk2 := null;
   n_rec.players_nk3 := null;
   n_rec.seq := null;
   n_rec.resolved := null;
end clear;
----------
function clear
      (n_rec  in out nocopy  revelation_ACT%ROWTYPE
      ) return varchar2
is
begin
   clear(n_rec);
   return '';
exception when others then return sqlerrm;
end clear;
--------------------------------------------
-- Set a "table" record to null
procedure clear
      (n_tab  in out nocopy  revelation%ROWTYPE
      )
is
begin
   n_tab.id := null;
   n_tab.player_id := null;
   n_tab.seq := null;
   n_tab.resolved := null;
end clear;
----------
function clear
      (n_tab  in out nocopy  revelation%ROWTYPE
      ) return varchar2
is
begin
   clear(n_tab);
   return '';
exception when others then return sqlerrm;
end clear;
----------------------------------------
procedure get_rec_by_id
      (n_rec  in out nocopy  revelation_act%ROWTYPE
      )
is
   start_tstamp  timestamp := systimestamp;
begin
   if n_rec.id is null then
      clear(n_rec);
   else
      select * into n_rec from revelation_act
       where id = n_rec.id;
   end if;
   return;
   util.trc_time_interval('revelation_dml.get_rec_by_id(act rec) ID:' || n_rec.id, start_tstamp);
end get_rec_by_id;
----------
function get_rec_by_id
      (n_rec  in out nocopy  revelation_act%ROWTYPE
      ) return varchar2
is
begin
   get_rec_by_id(n_rec);
   return '';
exception when others then return sqlerrm;
end get_rec_by_id;
----------------------------------------
procedure get_rec_by_id
      (n_tab  in out nocopy  revelation%ROWTYPE
      )
is
   start_tstamp  timestamp := systimestamp;
begin
   if n_tab.id is null then
      clear(n_tab);
   else
      select * into n_tab from revelation
       where id = n_tab.id;
   end if;
   return;
   util.trc_time_interval('revelation_dml.get_rec_by_id(tab rec) ID:' || n_tab.id, start_tstamp);
end get_rec_by_id;
----------
function get_rec_by_id
      (n_tab  in out nocopy  revelation%ROWTYPE
      ) return varchar2
is
begin
   get_rec_by_id(n_tab);
   return '';
exception when others then return sqlerrm;
end get_rec_by_id;
--------------------------------------------
-- Insert a revelation ACTIVE View Record
procedure ins
      (new_rec  in out nocopy  revelation_act%ROWTYPE
      ,upd_vals_in  in  boolean default TRUE
      )
is
   new_act  actions_act%ROWTYPE;
   start_tstamp  timestamp := systimestamp;
begin
   new_act.id := new_rec.id;
   new_act.player_id := new_rec.player_id;
   new_act.players_nk1 := new_rec.players_nk1;
   new_act.players_nk2 := new_rec.players_nk2;
   new_act.players_nk3 := new_rec.players_nk3;
   new_act.seq := new_rec.seq;
   new_act.resolved := new_rec.resolved;
   new_act.actions_sub_type := 'revelation';
   actions_dml.ins(new_act, upd_vals_in);
   if upd_vals_in then
      new_rec.id := new_act.id;
      new_rec.player_id := new_act.player_id;
      new_rec.players_nk1 := new_act.players_nk1;
      new_rec.players_nk2 := new_act.players_nk2;
      new_rec.players_nk3 := new_act.players_nk3;
      new_rec.seq := new_act.seq;
      new_rec.resolved := new_act.resolved;
   end if;
   return;
   util.trc_time_interval('revelation_dml.ins(act rec) ID:' || new_rec.id, start_tstamp);
end ins;
----------
function ins
      (new_rec  in out nocopy  revelation_act%ROWTYPE
      ,upd_vals_in  in  boolean default TRUE
      ) return varchar2
is
begin
   ins(new_rec, upd_vals_in);
   return '';
exception when others then return sqlerrm;
end ins;
--------------------------------------------
-- Insert a revelation Table Record
procedure ins
      (new_tab  in out nocopy  revelation%ROWTYPE
      ,upd_vals_in  in  boolean default TRUE
      )
is
   new_base  actions%ROWTYPE;
   start_tstamp  timestamp := systimestamp;
begin
   new_base.id := new_tab.id;
   new_base.player_id := new_tab.player_id;
   new_base.seq := new_tab.seq;
   new_base.resolved := new_tab.resolved;
   new_base.actions_sub_type := 'revelation';
   actions_tab.ins(new_base);
   if upd_vals_in then
      new_tab.id := new_base.id;
      new_tab.player_id := new_base.player_id;
      new_tab.seq := new_base.seq;
      new_tab.resolved := new_base.resolved;
   end if;
   return;
   util.trc_time_interval('revelation_dml.ins(tab rec) ID:' || new_tab.id, start_tstamp);
end ins;
----------
function ins
      (new_tab  in out nocopy  revelation%ROWTYPE
      ,upd_vals_in  in  boolean default TRUE
      ) return varchar2
is
begin
   ins(new_tab, upd_vals_in);
   return '';
exception when others then return sqlerrm;
end ins;
--------------------------------------------
-- Insert columns for actions ACTIVE View
procedure ins
      (id_in  in  NUMBER default null
      ,player_id_in  in  NUMBER default null
      ,players_nk1_in  in  VARCHAR2 default null
      ,players_nk2_in  in  VARCHAR2 default null
      ,players_nk3_in  in  VARCHAR2 default null
      ,seq_in  in  NUMBER default null
      ,resolved_in  in  VARCHAR2 default null
      )
is
   new_rec  actions_act%ROWTYPE;
   start_tstamp  timestamp := systimestamp;
begin
   new_rec.id := id_in;
   new_rec.player_id := player_id_in;
   new_rec.players_nk1 := players_nk1_in;
   new_rec.players_nk2 := players_nk2_in;
   new_rec.players_nk3 := players_nk3_in;
   new_rec.seq := seq_in;
   new_rec.resolved := resolved_in;
   new_rec.actions_sub_type := 'revelation';
   actions_dml.ins(new_rec, FALSE);
   return;
   util.trc_time_interval('revelation_dml.ins(act_col) ID:' || id_in, start_tstamp);
end ins;
----------
function ins
      (id_in  in  NUMBER default null
      ,player_id_in  in  NUMBER default null
      ,players_nk1_in  in  VARCHAR2 default null
      ,players_nk2_in  in  VARCHAR2 default null
      ,players_nk3_in  in  VARCHAR2 default null
      ,seq_in  in  NUMBER default null
      ,resolved_in  in  VARCHAR2 default null
      ) return varchar2
is
begin
    ins
      (id_in
      ,player_id_in
      ,players_nk1_in
      ,players_nk2_in
      ,players_nk3_in
      ,seq_in
      ,resolved_in
      );
   return '';
exception when others then return sqlerrm;
end ins;
--------------------------------------------
-- Insert columns for revelation ACTIVE View
procedure ins2
      (id_io  in out nocopy  NUMBER
      ,player_id_io  in out nocopy  NUMBER
      ,players_nk1_io  in out nocopy  VARCHAR2
      ,players_nk2_io  in out nocopy  VARCHAR2
      ,players_nk3_io  in out nocopy  VARCHAR2
      ,seq_io  in out nocopy  NUMBER
      ,resolved_io  in out nocopy  VARCHAR2
      )
is
   new_rec  actions_act%ROWTYPE;
   start_tstamp  timestamp := systimestamp;
begin
   new_rec.id := id_io;
   new_rec.player_id := player_id_io;
   new_rec.players_nk1 := players_nk1_io;
   new_rec.players_nk2 := players_nk2_io;
   new_rec.players_nk3 := players_nk3_io;
   new_rec.seq := seq_io;
   new_rec.resolved := resolved_io;
   new_rec.actions_sub_type := 'revelation';
   --
   actions_dml.ins(new_rec);
   --
   id_io := new_rec.id;
   player_id_io := new_rec.player_id;
   players_nk1_io := new_rec.players_nk1;
   players_nk2_io := new_rec.players_nk2;
   players_nk3_io := new_rec.players_nk3;
   seq_io := new_rec.seq;
   resolved_io := new_rec.resolved;
   return;
   util.trc_time_interval('revelation_dml.ins2(act col) ID:' || id_io, start_tstamp);
end ins2;
----------
function ins2
      (id_io  in out nocopy  NUMBER
      ,player_id_io  in out nocopy  NUMBER
      ,players_nk1_io  in out nocopy  VARCHAR2
      ,players_nk2_io  in out nocopy  VARCHAR2
      ,players_nk3_io  in out nocopy  VARCHAR2
      ,seq_io  in out nocopy  NUMBER
      ,resolved_io  in out nocopy  VARCHAR2
      ) return varchar2
is
begin
   ins2
      (id_io
      ,player_id_io
      ,players_nk1_io
      ,players_nk2_io
      ,players_nk3_io
      ,seq_io
      ,resolved_io
      );
   return '';
exception when others then return sqlerrm;
end ins2;
--------------------------------------------
-- Insert columns for revelation Table
procedure ins2
      (id_io  in out nocopy  NUMBER
      ,player_id_io  in out nocopy  NUMBER
      ,seq_io  in out nocopy  NUMBER
      ,resolved_io  in out nocopy  VARCHAR2
      )
is
   new_rec  actions%ROWTYPE;
   start_tstamp  timestamp := systimestamp;
begin
   new_rec.id := id_io;
   new_rec.player_id := player_id_io;
   new_rec.seq := seq_io;
   new_rec.resolved := resolved_io;
   new_rec.actions_sub_type := 'revelation';
   --
   actions_tab.ins(new_rec);
   --
   id_io := new_rec.id;
   player_id_io := new_rec.player_id;
   seq_io := new_rec.seq;
   resolved_io := new_rec.resolved;
   return;
   util.trc_time_interval('revelation_dml.ins2(tab col) ID:' || id_io, start_tstamp);
end ins2;
----------
function ins2
      (id_io  in out nocopy  NUMBER
      ,player_id_io  in out nocopy  NUMBER
      ,seq_io  in out nocopy  NUMBER
      ,resolved_io  in out nocopy  VARCHAR2
      ) return varchar2
is
begin
   ins2
      (id_io
      ,player_id_io
      ,seq_io
      ,resolved_io
      );
   return '';
exception when others then return sqlerrm;
end ins2;
--------------------------------------------
-- Used by the BU Trigger on the view, avoid if possible
procedure upd
      (old_rec  in  revelation_act%ROWTYPE
      ,new_rec  in out nocopy  revelation_act%ROWTYPE
      ,upd_vals_in  in  boolean default FALSE
      )
is
   old_act  actions_act%ROWTYPE;
   new_act  actions_act%ROWTYPE;
   start_tstamp  timestamp := systimestamp;
begin
   old_act.id := old_rec.id;
   new_act.id := new_rec.id;
   old_act.player_id := old_rec.player_id;
   new_act.player_id := new_rec.player_id;
   old_act.players_nk1 := old_rec.players_nk1;
   new_act.players_nk1 := new_rec.players_nk1;
   old_act.players_nk2 := old_rec.players_nk2;
   new_act.players_nk2 := new_rec.players_nk2;
   old_act.players_nk3 := old_rec.players_nk3;
   new_act.players_nk3 := new_rec.players_nk3;
   old_act.seq := old_rec.seq;
   new_act.seq := new_rec.seq;
   old_act.resolved := old_rec.resolved;
   new_act.resolved := new_rec.resolved;
   -- Run the update
   old_act.actions_sub_type := 'revelation';
   new_act.actions_sub_type := 'revelation';
   actions_dml.upd(old_act, new_act, upd_vals_in);
   if upd_vals_in then
      new_rec.id := new_act.id;
      new_rec.player_id := new_act.player_id;
      new_rec.players_nk1 := new_act.players_nk1;
      new_rec.players_nk2 := new_act.players_nk2;
      new_rec.players_nk3 := new_act.players_nk3;
      new_rec.seq := new_act.seq;
      new_rec.resolved := new_act.resolved;
   end if;
   return;
   util.trc_time_interval('revelation_dml.upd(trigger) ID:' || old_rec.id, start_tstamp);
end upd;
----------
function upd
      (old_rec  in  revelation_act%ROWTYPE
      ,new_rec  in out nocopy  revelation_act%ROWTYPE
      ,upd_vals_in  in  boolean default FALSE
      ) return varchar2
is
begin
   upd(old_rec, new_rec, upd_vals_in);
   return '';
exception when others then return sqlerrm;
end upd;
--------------------------------------------
-- Update a revelation ACTIVE View Record
procedure upd
      (new_rec  in out nocopy  revelation_act%ROWTYPE
      ,upd_vals_in  in  boolean default TRUE
      )
is
   new_act  actions_act%ROWTYPE;
   start_tstamp  timestamp := systimestamp;
begin
      new_act.id := new_rec.id;
      new_act.player_id := new_rec.player_id;
      new_act.players_nk1 := new_rec.players_nk1;
      new_act.players_nk2 := new_rec.players_nk2;
      new_act.players_nk3 := new_rec.players_nk3;
      new_act.seq := new_rec.seq;
      new_act.resolved := new_rec.resolved;
   new_act.actions_sub_type := 'revelation';
   actions_dml.upd(new_act, upd_vals_in);
   if upd_vals_in then
      new_rec.id := new_act.id;
      new_rec.player_id := new_act.player_id;
      new_rec.players_nk1 := new_act.players_nk1;
      new_rec.players_nk2 := new_act.players_nk2;
      new_rec.players_nk3 := new_act.players_nk3;
      new_rec.seq := new_act.seq;
      new_rec.resolved := new_act.resolved;
   end if;
   return;
   util.trc_time_interval('revelation_dml.upd(act rec) ID:' || new_rec.id, start_tstamp);
end upd;
----------
function upd
      (new_rec  in out nocopy  revelation_act%ROWTYPE
      ,upd_vals_in  in  boolean default TRUE
      ) return varchar2
is
begin
   upd(new_rec, upd_vals_in);
   return '';
exception when others then return sqlerrm;
end upd;
--------------------------------------------
-- Update a revelation Table Record
procedure upd
      (new_tab  in out nocopy  revelation%ROWTYPE
      ,upd_vals_in  in  boolean default FALSE
      )
is
   new_base  actions%ROWTYPE;
   start_tstamp  timestamp := systimestamp;
begin
   new_base.id := new_tab.id;
   new_base.player_id := new_tab.player_id;
   new_base.seq := new_tab.seq;
   new_base.resolved := new_tab.resolved;
   new_base.actions_sub_type := 'revelation';
   actions_dml.upd(new_base);
   if upd_vals_in then
      new_tab.id := new_base.id;
      new_tab.player_id := new_base.player_id;
      new_tab.seq := new_base.seq;
      new_tab.resolved := new_base.resolved;
   end if;
   return;
   util.trc_time_interval('revelation_dml.upd(tab rec) ID:' || new_tab.id, start_tstamp);
end upd;
----------
function upd
      (new_tab  in out nocopy  revelation%ROWTYPE
      ,upd_vals_in  in  boolean default FALSE
      ) return varchar2
is
begin
   upd(new_tab, upd_vals_in);
   return '';
exception when others then return sqlerrm;
end upd;
--------------------------------------------
-- Update columns for revelation ACTIVE View
procedure upd
      (id_in  in  NUMBER default null
      ,player_id_in  in  NUMBER default null
      ,players_nk1_in  in  VARCHAR2 default null
      ,players_nk2_in  in  VARCHAR2 default null
      ,players_nk3_in  in  VARCHAR2 default null
      ,seq_in  in  NUMBER default null
      ,resolved_in  in  VARCHAR2 default null
      )
is
   new_rec  actions_act%ROWTYPE;
   start_tstamp  timestamp := systimestamp;
begin
   new_rec.id := id_in;
   new_rec.player_id := player_id_in;
   new_rec.players_nk1 := players_nk1_in;
   new_rec.players_nk2 := players_nk2_in;
   new_rec.players_nk3 := players_nk3_in;
   new_rec.seq := seq_in;
   new_rec.resolved := resolved_in;
   new_rec.actions_sub_type := 'revelation';
   actions_dml.upd(new_rec, FALSE);
   return;
   util.trc_time_interval('revelation_dml.upd(act col) ID:' || id_in, start_tstamp);
end upd;
----------
function upd
      (id_in  in  NUMBER default null
      ,player_id_in  in  NUMBER default null
      ,players_nk1_in  in  VARCHAR2 default null
      ,players_nk2_in  in  VARCHAR2 default null
      ,players_nk3_in  in  VARCHAR2 default null
      ,seq_in  in  NUMBER default null
      ,resolved_in  in  VARCHAR2 default null
      ) return varchar2
is
begin
   upd
      (id_in
      ,player_id_in
      ,players_nk1_in
      ,players_nk2_in
      ,players_nk3_in
      ,seq_in
      ,resolved_in
      );
   return '';
exception when others then return sqlerrm;
end upd;
--------------------------------------------
-- Update columns for revelation ACTIVE View
procedure upd2
      (id_io  in out nocopy  NUMBER
      ,player_id_io  in out nocopy  NUMBER
      ,players_nk1_io  in out nocopy  VARCHAR2
      ,players_nk2_io  in out nocopy  VARCHAR2
      ,players_nk3_io  in out nocopy  VARCHAR2
      ,seq_io  in out nocopy  NUMBER
      ,resolved_io  in out nocopy  VARCHAR2
      )
is
   new_rec  actions_act%ROWTYPE;
   start_tstamp  timestamp := systimestamp;
begin
   new_rec.id := id_io;
   new_rec.player_id := player_id_io;
   new_rec.players_nk1 := players_nk1_io;
   new_rec.players_nk2 := players_nk2_io;
   new_rec.players_nk3 := players_nk3_io;
   new_rec.seq := seq_io;
   new_rec.resolved := resolved_io;
   new_rec.actions_sub_type := 'revelation';
   --
   actions_dml.upd(new_rec, TRUE);
   --
   id_io := new_rec.id;
   player_id_io := new_rec.player_id;
   players_nk1_io := new_rec.players_nk1;
   players_nk2_io := new_rec.players_nk2;
   players_nk3_io := new_rec.players_nk3;
   seq_io := new_rec.seq;
   resolved_io := new_rec.resolved;
   return;
   util.trc_time_interval('revelation_dmlupd2(act col) ID:' || id_io, start_tstamp);
end upd2;
----------
function upd2
      (id_io  in out nocopy  NUMBER
      ,player_id_io  in out nocopy  NUMBER
      ,players_nk1_io  in out nocopy  VARCHAR2
      ,players_nk2_io  in out nocopy  VARCHAR2
      ,players_nk3_io  in out nocopy  VARCHAR2
      ,seq_io  in out nocopy  NUMBER
      ,resolved_io  in out nocopy  VARCHAR2
      ) return varchar2
is
begin
   upd2
      (id_io
      ,player_id_io
      ,players_nk1_io
      ,players_nk2_io
      ,players_nk3_io
      ,seq_io
      ,resolved_io
      );
   return '';
exception when others then return sqlerrm;
end upd2;
--------------------------------------------
-- Update columns for revelation Table
procedure upd2
      (id_io  in out nocopy  NUMBER
      ,player_id_io  in out nocopy  NUMBER
      ,seq_io  in out nocopy  NUMBER
      ,resolved_io  in out nocopy  VARCHAR2
      )
is
   new_rec  actions%ROWTYPE;
   start_tstamp  timestamp := systimestamp;
begin
   new_rec.id := id_io;
   new_rec.player_id := player_id_io;
   new_rec.seq := seq_io;
   new_rec.resolved := resolved_io;
   new_rec.actions_sub_type := 'revelation';
   --
   actions_dml.upd(new_rec);
   --
   id_io := new_rec.id;
   player_id_io := new_rec.player_id;
   seq_io := new_rec.seq;
   resolved_io := new_rec.resolved;
   return;
   util.trc_time_interval('revelation_dmlupd2(tab col) ID:' || id_io, start_tstamp);
end upd2;
----------
function upd2
      (id_io  in out nocopy  NUMBER
      ,player_id_io  in out nocopy  NUMBER
      ,seq_io  in out nocopy  NUMBER
      ,resolved_io  in out nocopy  VARCHAR2
      ) return varchar2
is
begin
   upd2
      (id_io
      ,player_id_io
      ,seq_io
      ,resolved_io
      );
   return '';
exception when others then return sqlerrm;
end upd2;
----------------------------------------
-- Application Delete procedure without updated parameters
procedure del
      (id_in  in  NUMBER default null
      ,player_id_in  in  NUMBER default null
      ,players_nk1_in  in  VARCHAR2 default null
      ,players_nk2_in  in  VARCHAR2 default null
      ,players_nk3_in  in  VARCHAR2 default null
      ,seq_in  in  NUMBER default null
      )
is
   start_tstamp  timestamp := systimestamp;
begin
   actions_dml.del
      (id_in
      ,player_id_in
      ,players_nk1_in
      ,players_nk2_in
      ,players_nk3_in
      ,seq_in
      );
   return;
   util.trc_time_interval('revelation_dml.del ID:' || id_in, start_tstamp);
end del;
----------
function del
      (id_in  in  NUMBER default null
      ,player_id_in  in  NUMBER default null
      ,players_nk1_in  in  VARCHAR2 default null
      ,players_nk2_in  in  VARCHAR2 default null
      ,players_nk3_in  in  VARCHAR2 default null
      ,seq_in  in  NUMBER default null
      ) return varchar2
is
begin
   del
      (id_in
      ,player_id_in
      ,players_nk1_in
      ,players_nk2_in
      ,players_nk3_in
      ,seq_in
      );
   return '';
exception when others then return sqlerrm;
end del;
----------------------------------------
-- Application Delete procedure with updated parameters
procedure del2
      (id_io  in out nocopy  NUMBER
      ,player_id_in  in  NUMBER default null
      ,players_nk1_in  in  VARCHAR2 default null
      ,players_nk2_in  in  VARCHAR2 default null
      ,players_nk3_in  in  VARCHAR2 default null
      ,seq_in  in  NUMBER default null
      )
is
   start_tstamp  timestamp := systimestamp;
begin
   actions_dml.del2
      (id_io
      ,player_id_in
      ,players_nk1_in
      ,players_nk2_in
      ,players_nk3_in
      ,seq_in
      );
   return;
   util.trc_time_interval('revelation_dml.del2 ID:' || id_io, start_tstamp);
end del2;
----------
function del2
      (id_io  in out nocopy  NUMBER
      ,player_id_in  in  NUMBER default null
      ,players_nk1_in  in  VARCHAR2 default null
      ,players_nk2_in  in  VARCHAR2 default null
      ,players_nk3_in  in  VARCHAR2 default null
      ,seq_in  in  NUMBER default null
      ) return varchar2
is
begin
   del2
      (id_io
      ,player_id_in
      ,players_nk1_in
      ,players_nk2_in
      ,players_nk3_in
      ,seq_in
      );
   return '';
exception when others then return sqlerrm;
end del2;
--------------------------------------------
-- Special Data Warehouse Dimension Function
procedure load_dim
      (dim_tab  in out nocopy  revelation%ROWTYPE
      )
is
   new_rec  actions%ROWTYPE;
   start_tstamp  timestamp := systimestamp;
begin
   new_rec.id := dim_tab.id;
   new_rec.player_id := dim_tab.player_id;
   new_rec.seq := dim_tab.seq;
   new_rec.resolved := dim_tab.resolved;
   new_rec.actions_sub_type := 'revelation';
   --
   actions_dml.load_dim(new_rec);
   return;
   util.trc_time_interval('revelation_dmlload_dim ID:' || dim_tab.id, start_tstamp);
end load_dim;
----------
function load_dim
      (dim_tab  in out nocopy  revelation%ROWTYPE
      ) return varchar2
is
begin
   load_dim(dim_tab);
   return '';
exception when others then return sqlerrm;
end load_dim;
--------------------------------------------

end revelation_dml;
/

set define on
