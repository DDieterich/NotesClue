
--
--  Create CLUE.PCARD_ACTIONS_TAB Package Body
--

set define off


--DBMS_METADATA:CLUE.PCARD_ACTIONS_TAB

  CREATE OR REPLACE EDITIONABLE PACKAGE BODY "CLUE"."PCARD_ACTIONS_TAB" 
is

-- Package Body Pcard_Actions_Tab
--    Table functions and integrity checks)

   -- Application: Clue Notes For Oracle
   -- Generated by DTGen (http://dmstex.com/services/dtgen)
   -- December  16, 2013  11:32:29 AM

   --
   --
   -- ? Duane.Dieterich@DMSTEX.com 2013
   --
   -- All Rights Reserved
   --
   -- No part of this software may be reproduced, copied, modified or adapted,
   -- without the prior written consent of the author, unless otherwise
   -- indicated for stand-alone materials.
   --
   -- You may quote extracts from this software with attribution to
   -- Duane.Dieterich@DMSTEX.com
   --
   -- For any other mode of sharing, please contact Duane.Dieterich@DMSTEX.com.
   --
   -- Commercial use and distribution of this software is not allowed without
   -- express and prior written consent of the author.
   --
   -- THE SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
   -- INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY
   -- AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL
   -- THE COPYRIGHT HOLDER OR DMSTEX BUSINESS SOLUTIONS LLC, ITS MEMBERS,
   -- MANAGERS, OR EMPLOYEES BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
   -- SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
   -- TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
   -- PROFITS; CORRUPTION OF DATA, OR BUSINESS INTERRUPTION) HOWEVER CAUSED
   -- AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
   -- OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF
   -- THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH
   -- DAMAGE.
   --
   --


----------------------------------------
procedure check_rec
      (id  in  NUMBER
      ,card_id  in out nocopy  NUMBER
      ,disposition  in out nocopy  VARCHAR2
      ,player_id  in out nocopy  NUMBER
      ,action_id  in out nocopy  NUMBER
      )
is
begin
   -- 1) Set Default Values as Needed
   -- 2) Check for NOT NULL
   if card_id is null then
      raise_application_error(-20004, 'pcard_actions_tab.check_rec(): card_id cannot be null.');
   end if;
   if disposition is null then
      raise_application_error(-20004, 'pcard_actions_tab.check_rec(): disposition cannot be null.');
   end if;
   if player_id is null then
      raise_application_error(-20004, 'pcard_actions_tab.check_rec(): player_id cannot be null.');
   end if;
   if action_id is null then
      raise_application_error(-20004, 'pcard_actions_tab.check_rec(): action_id cannot be null.');
   end if;
   -- 3) Sub-type NULL checks
   -- 4) Compress Spaces, as needed
   -- 5) Custom Data Handling
   -- 6) Fold the case, as needed
   if util.get_fold_strings then
      disposition := upper(disposition);
   else
      if disposition is not null
      then
         if disposition != upper(disposition) then
            raise_application_error(-20003, 'pcard_actions_tab.check_rec(): disposition must be upper case.');
         end if;
      end if;
   end if;
   -- 7) Check for Domain Values
   if disposition is not null
      and not Dispositions_dom.includes(disposition)
   then
      raise_application_error(-20005, 'pcard_actions_tab.check_rec(): disposition must be one of ("HREV", "LREV", "LPAS", "HDED", "LELT", "LELP").');
   end if;
   -- 8) Custom Constraint Checks
   -- These constraints must be written to account for sub-types
   -- 9) Set eff_beg_dtm, if needed
   -- 10) Set aud_beg_usr and aud_beg_dtm
end check_rec;
----------------------------------------
-- Check Constraints for a pcard_actions Record
function rec_status
      (id_in  in NUMBER
      )  return varchar2
is
   fs_save    boolean  := util.get_fold_strings;
   ud_save    boolean  := util.get_use_defaults;
   old_tab  pcard_actions%ROWTYPE;
   new_tab  pcard_actions%ROWTYPE;
begin
   select * into old_tab from pcard_actions where id = id_in;
   new_tab := old_tab;
   util.set_fold_strings(FALSE);
   util.set_use_defaults(FALSE);
   check_rec (id  =>  new_tab.id
             ,card_id  =>  new_tab.card_id
             ,disposition  =>  new_tab.disposition
             ,player_id  =>  new_tab.player_id
             ,action_id  =>  new_tab.action_id
             );
   if not util.is_equal(old_tab.id, new_tab.id) then
      return 'Data Storage Error on id';
   end if;
   if not util.is_equal(old_tab.card_id, new_tab.card_id) then
      return 'Data Storage Error on card_id';
   end if;
   if not util.is_equal(old_tab.disposition, new_tab.disposition) then
      return 'Data Storage Error on disposition';
   end if;
   if not util.is_equal(old_tab.player_id, new_tab.player_id) then
      return 'Data Storage Error on player_id';
   end if;
   if not util.is_equal(old_tab.action_id, new_tab.action_id) then
      return 'Data Storage Error on action_id';
   end if;
   util.set_use_defaults(ud_save);
   util.set_fold_strings(fs_save);
   return 'OK';
exception
   when others then
      util.set_use_defaults(ud_save);
      util.set_fold_strings(fs_save);
      return sqlerrm;
end rec_status;
----------------------------------------
function get_id
      (pcard_actions_nk1  in  VARCHAR2
      ,pcard_actions_nk2  in  VARCHAR2
      ,pcard_actions_nk3  in  VARCHAR2
      ,pcard_actions_nk4  in  VARCHAR2
      ,pcard_actions_nk5  in  VARCHAR2
      ,pcard_actions_nk6  in  VARCHAR2
      ,pcard_actions_nk7  in  VARCHAR2
      ,pcard_actions_nk8  in  VARCHAR2
      ,pcard_actions_nk9  in  VARCHAR2
      ,pcard_actions_nk10  in  VARCHAR2
      ,pcard_actions_nk11  in  NUMBER
      ) return NUMBER
   -- For all the Natural Key Columns, Return an ID
is
   retid  NUMBER(38);
begin
   select id
    into  retid
    from  pcard_actions  PCA
    where PCA.card_id = cards_tab.get_id
             (pcard_actions_nk1
             ,pcard_actions_nk2
             ,pcard_actions_nk3
             )
     and  PCA.disposition = pcard_actions_nk4
     and  PCA.player_id = players_tab.get_id
             (pcard_actions_nk5
             ,pcard_actions_nk6
             ,pcard_actions_nk7
             )
     and  PCA.action_id = actions_tab.get_id
             (pcard_actions_nk8
             ,pcard_actions_nk9
             ,pcard_actions_nk10
             ,pcard_actions_nk11
             )
    ;
   return retid;
exception when no_data_found then return null;
end get_id;
----------------------------------------
function get_nk
      (id_in  in  NUMBER)
   return VARCHAR2
   -- For an ID, return a delimited list of Natural Key Values
is
   rtxt  VARCHAR2(4000);
begin
   select substr(   cards_tab.get_nk(PCA.card_id)
    || util.nk_sep || PCA.disposition
    || util.nk_sep || players_tab.get_nk(PCA.player_id)
    || util.nk_sep || actions_tab.get_nk(PCA.action_id)
                         ,1 ,4000)
    into  rtxt
    from  pcard_actions PCA
    where PCA.id = id_in;
   return rtxt;
exception when no_data_found then return null;
end get_nk;
----------------------------------------
-- Should be called exclusively by the BI Trigger
--   or the "ins" procedure below
procedure ins_bi_trigger
      (n_id  in out nocopy  NUMBER
      ,n_card_id  in out nocopy  NUMBER
      ,n_disposition  in out nocopy  VARCHAR2
      ,n_player_id  in out nocopy  NUMBER
      ,n_action_id  in out nocopy  NUMBER
      )
is
begin
   -- BI Trigger will have run_tab = TRUE, otherwise FALSE
   -- Set n_id, if needed
   if n_id is null then
      select pcard_actions_seq.nextval
       into  n_id from dual;
   elsif n_id = 0 then
      raise_application_error(-20019, 'ID of zero is not allowed');
   end if;
   check_rec (id  =>  n_id
             ,card_id  =>  n_card_id
             ,disposition  =>  n_disposition
             ,player_id  =>  n_player_id
             ,action_id  =>  n_action_id
             );
end ins_bi_trigger;
----------------------------------------
-- Can be called from anywhere, except the BI Trigger
procedure ins
      (n_rec  in out nocopy  pcard_actions%ROWTYPE
      )
is
begin
   run_tab := FALSE;
   ins_bi_trigger (n_id  =>  n_rec.id
       ,n_card_id  =>  n_rec.card_id
       ,n_disposition  =>  n_rec.disposition
       ,n_player_id  =>  n_rec.player_id
       ,n_action_id  =>  n_rec.action_id
       );
   insert into pcard_actions
         (id
         ,card_id
         ,disposition
         ,player_id
         ,action_id
         )
   values
         (n_rec.id
         ,n_rec.card_id
         ,n_rec.disposition
         ,n_rec.player_id
         ,n_rec.action_id
         );
   run_tab := TRUE;
exception
   when others then
      run_tab := TRUE;
      raise;
end ins;
----------------------------------------
-- Should be called exclusively by the BU Trigger
--   or the "upd" procedure below
-- Note: the OLD values must be provided to check ignore_no_change
-- Note2:  Select for Update Lock is assumed on old values row
procedure upd_bu_trigger
      (o_id  in  NUMBER
      ,o_card_id  in  NUMBER
      ,n_card_id  in out nocopy  NUMBER
      ,o_disposition  in  VARCHAR2
      ,n_disposition  in out nocopy  VARCHAR2
      ,o_player_id  in  NUMBER
      ,n_player_id  in out nocopy  NUMBER
      ,o_action_id  in  NUMBER
      ,n_action_id  in out nocopy  NUMBER
      ,run_update  out  boolean
      )
is
begin
   run_update := TRUE;
   -- BU Trigger will have run_tab = TRUE, otherwise FALSE
   if     o_card_id = n_card_id
     and  o_disposition = n_disposition
     and  o_player_id = n_player_id
     and  o_action_id = n_action_id
   then
      if util.get_ignore_no_change then
         run_update := FALSE;
         return;
      end if;
      raise_application_error(-20008, 'pcard_actions_tab.upd(): Must update one of'
            || ' card_id'
            || ', disposition'
            || ', player_id'
            || ', action_id'
            || '.');
   end if;
   check_rec (id  =>  o_id
             ,card_id  =>  n_card_id
             ,disposition  =>  n_disposition
             ,player_id  =>  n_player_id
             ,action_id  =>  n_action_id
             );
end upd_bu_trigger;
----------------------------------------
-- Can be called from anywhere, except the BU Trigger
-- Note: the OLD values must be provided to set new_rec values
procedure upd
      (o_rec  in             pcard_actions%ROWTYPE
      ,n_rec  in out nocopy  pcard_actions%ROWTYPE
      )
is
   c_rec    pcard_actions%ROWTYPE;  -- Current Row Data
   run_upd  boolean;
begin
   if o_rec.id is null then return; end if;
   run_tab := FALSE;
   select * into c_rec from pcard_actions t1
    where t1.id = o_rec.id FOR UPDATE;
   -- If old and new match, then replace new with current
   --   because there was no original intent to change new
   if o_rec.card_id = n_rec.card_id then
      n_rec.card_id := c_rec.card_id;
   end if;
   if o_rec.disposition = n_rec.disposition then
      n_rec.disposition := c_rec.disposition;
   end if;
   if o_rec.player_id = n_rec.player_id then
      n_rec.player_id := c_rec.player_id;
   end if;
   if o_rec.action_id = n_rec.action_id then
      n_rec.action_id := c_rec.action_id;
   end if;
   -- Update the new data based on the current data
   upd_bu_trigger (o_id  =>  c_rec.id
      ,o_card_id  =>  c_rec.card_id
      ,n_card_id  =>  n_rec.card_id
      ,o_disposition  =>  c_rec.disposition
      ,n_disposition  =>  n_rec.disposition
      ,o_player_id  =>  c_rec.player_id
      ,n_player_id  =>  n_rec.player_id
      ,o_action_id  =>  c_rec.action_id
      ,n_action_id  =>  n_rec.action_id
      ,run_update  =>  run_upd
      );
   if run_upd then
      update pcard_actions
        set  card_id = n_rec.card_id
            ,disposition = n_rec.disposition
            ,player_id = n_rec.player_id
            ,action_id = n_rec.action_id
       where id = o_rec.id;
   end if;
   run_tab := TRUE;
exception
   when others then
      run_tab := TRUE;
      raise;
end upd;
----------------------------------------
-- Can be called from anywhere, except the BU Trigger
-- Note: the OLD values must be provided to check ignore_no_change
procedure upd
      (n_rec  in out nocopy  pcard_actions%ROWTYPE
      )
is
   c_rec    pcard_actions%ROWTYPE;  -- Current Row Data
   run_upd  boolean;
begin
   if n_rec.id is null then return; end if;
   run_tab := FALSE;
   select * into c_rec from pcard_actions t1
    where t1.id = n_rec.id FOR UPDATE;
   upd_bu_trigger (o_id  =>  c_rec.id
      ,o_card_id  =>  c_rec.card_id
      ,n_card_id  =>  n_rec.card_id
      ,o_disposition  =>  c_rec.disposition
      ,n_disposition  =>  n_rec.disposition
      ,o_player_id  =>  c_rec.player_id
      ,n_player_id  =>  n_rec.player_id
      ,o_action_id  =>  c_rec.action_id
      ,n_action_id  =>  n_rec.action_id
      ,run_update  =>  run_upd
      );
   if run_upd then
      update pcard_actions
        set  card_id = n_rec.card_id
            ,disposition = n_rec.disposition
            ,player_id = n_rec.player_id
            ,action_id = n_rec.action_id
       where id = c_rec.id;
   end if;
   run_tab := TRUE;
exception
   when others then
      run_tab := TRUE;
      raise;
end upd;
----------------------------------------
-- There is no delete trigger for this table
----------------------------------------
-- Can be called from anywhere, except the BD Trigger
procedure del
      (o_id  in  NUMBER
      )
is
begin
   -- NOTE: there is no delete trigger for this table
   if o_id is null then return; end if;
   run_tab := FALSE;
   delete from pcard_actions PCA
    where PCA.id = o_id;
   run_tab := TRUE;
end del;
----------------------------------------
end pcard_actions_tab;
/

set define on
