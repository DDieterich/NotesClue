
--
--  Create CLUE.UTIL Package Body
--

set define off


--DBMS_METADATA:CLUE.UTIL

  CREATE OR REPLACE EDITIONABLE PACKAGE BODY "CLUE"."UTIL" 
is

-- Package Body Util
--    Utility settings and functions

   -- Application: Clue Notes For Oracle
   -- Generated by DTGen (http://dmstex.com/services/dtgen)
   -- December  16, 2013  11:32:28 AM

   --
   --
   -- ? Duane.Dieterich@DMSTEX.com 2013
   --
   -- All Rights Reserved
   --
   -- No part of this software may be reproduced, copied, modified or adapted,
   -- without the prior written consent of the author, unless otherwise
   -- indicated for stand-alone materials.
   --
   -- You may quote extracts from this software with attribution to
   -- Duane.Dieterich@DMSTEX.com
   --
   -- For any other mode of sharing, please contact Duane.Dieterich@DMSTEX.com.
   --
   -- Commercial use and distribution of this software is not allowed without
   -- express and prior written consent of the author.
   --
   -- THE SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
   -- INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY
   -- AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL
   -- THE COPYRIGHT HOLDER OR DMSTEX BUSINESS SOLUTIONS LLC, ITS MEMBERS,
   -- MANAGERS, OR EMPLOYEES BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
   -- SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
   -- TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
   -- PROFITS; CORRUPTION OF DATA, OR BUSINESS INTERRUPTION) HOWEVER CAUSED
   -- AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
   -- OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF
   -- THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH
   -- DAMAGE.
   --
   --


-- Current User for Audit
current_usr           VARCHAR2(30);
-- Indicates that trace output should be performed, when called
no_trace_keys         boolean := true;

st_lockhandle         varchar2(128);  -- Single Threaded DBMS_LOCK
st_lockname           varchar2(128);  -- Single Threaded DBMS_LOCK

lo_context      BINARY_INTEGER;  -- DBMS_APPLICATION.set_session_longops
lo_op_name      varchar2(64);    -- DBMS_APPLICATION.set_session_longops
lo_rindex       BINARY_INTEGER;  -- DBMS_APPLICATION.set_session_longops
lo_slno         BINARY_INTEGER;  -- DBMS_APPLICATION.set_session_longops
lo_sofar        number;          -- DBMS_APPLICATION.set_session_longops
lo_totalwork    number;          -- DBMS_APPLICATION.set_session_longops
lo_target       BINARY_INTEGER;  -- DBMS_APPLICATION.set_session_longops
lo_target_desc  varchar2(32);    -- DBMS_APPLICATION.set_session_longops
lo_units        varchar2(32);    -- DBMS_APPLICATION.set_session_longops

----------------------------------------
-- Current Source Code Version
function get_version
   return varchar2
is
begin
   return version;
end get_version;
----------------------------------------
-- Defalt min/max date/time values
function get_first_dtm
   return timestamp with time zone
is
begin
   return first_dtm;
end get_first_dtm;
----------------------------------------
-- Defalt min/max date/time values
function get_last_dtm
      return timestamp with time zone
is
begin
   return last_dtm;
end get_last_dtm;
----------------------------------------
-- Centralized Current date/time
function get_dtm
      return timestamp with local time zone
is
begin
   return systimestamp;
end get_dtm;
----------------------------------------
-- Centralized date/time for ASOF views
procedure set_asof_dtm
      (asof_dtm_in  in  timestamp with time zone)
is
begin
   asof_dtm := asof_dtm_in;
end set_asof_dtm;
----------------------------------------
-- Centralized date/time for ASOF views
function get_asof_dtm
   return timestamp with time zone
is
begin
   return asof_dtm;
end get_asof_dtm;
----------------------------------------
-- Current User for Audit
procedure set_usr
      (usr_in  in  VARCHAR2)
is
begin
   current_usr := substr(usr_in,1,30);
end set_usr;
----------------------------------------
-- Current User for Audit
function get_usr
   return VARCHAR2
is
begin
   if current_usr is null
   then
      raise_application_error(-20002, 'Current User has not been set in the Util Package.');
   end if;
   return current_usr;
end get_usr;
----------------------------------------
-- Separates values within a set of Natural Keys
procedure set_nk_sep
         (nk_sep_in  in  varchar2)
is
begin
   nk_sep := nk_sep_in;
end set_nk_sep;
----------------------------------------
-- Separates values within a set of Natural Keys
function get_nk_sep
      return varchar2
is
begin
  return nk_sep;
end get_nk_sep;
----------------------------------------
-- Hierarchial Path Seperator
procedure set_path_sep
         (path_sep_in  in  varchar2)
is
begin
   path_sep := path_sep_in;
end set_path_sep;
----------------------------------------
-- Hierarchial Path Seperator
function get_path_sep
      return varchar2
is
begin
  return path_sep;
end get_path_sep;
----------------------------------------
-- Indicates whether to fold strings or return an error
procedure set_fold_strings
      (bool_in  in  boolean)
is
begin
   fold_strings := bool_in;
end set_fold_strings;
----------------------------------------
-- Indicates whether to fold strings or return an error
function get_fold_strings
      return boolean
is
begin
   return fold_strings;
end get_fold_strings;
----------------------------------------
-- Indicates whether to compress spaces in a string or return an error
procedure set_compress_spaces
      (bool_in  in  boolean)
is
begin
   compress_spaces := bool_in;
end set_compress_spaces;
----------------------------------------
-- Indicates whether to compress spaces in a string or return an error
function get_compress_spaces
      return boolean
is
begin
   return compress_spaces;
end get_compress_spaces;
----------------------------------------
-- Indicates whether to return an error if an UPDATE is called with no data changes
procedure set_ignore_no_change
      (bool_in  in  boolean)
is
begin
   ignore_no_change := bool_in;
end set_ignore_no_change;
----------------------------------------
-- Indicates whether to return an error if an UPDATE is called with no data changes
function get_ignore_no_change
      return boolean
is
begin
   return ignore_no_change;
end get_ignore_no_change;
----------------------------------------
-- Indicates whether to enforce temporal continuity on foreign keys
procedure set_temporal_continuity
      (bool_in  in  boolean)
is
begin
   temporal_continuity := bool_in;
end set_temporal_continuity;
----------------------------------------
-- Indicates whether to enforce temporal continuity on foreign keys
function get_temporal_continuity
      return boolean
is
begin
   return temporal_continuity;
end get_temporal_continuity;
----------------------------------------
-- Indicates whether to use the default value provided for a column
procedure set_use_defaults
      (bool_in  in  boolean)
is
begin
   use_defaults := bool_in;
end set_use_defaults;
----------------------------------------
-- Indicates whether to use the default value provided for a column
function get_use_defaults
      return boolean
is
begin
   return use_defaults;
end get_use_defaults;
----------------------------------------
-- Indicates whether to include hex or decimal encodings
procedure set_include_unknown_ascii
      (bool_in  in  boolean)
is
begin
   include_unknown_ascii := bool_in;
end set_include_unknown_ascii;
----------------------------------------
-- Indicates whether to include hex or decimal encodings
function get_include_unknown_ascii
      return boolean
is
begin
   return include_unknown_ascii;
end get_include_unknown_ascii;
----------------------------------------
-- Indicates whether to set columns to NULL
procedure set_fix_non_null_sub_types
      (bool_in  in  boolean)
is
begin
   fix_non_null_sub_types := bool_in;
end set_fix_non_null_sub_types;
----------------------------------------
-- Indicates whether to set columns to NULL
function get_fix_non_null_sub_types
      return boolean
is
begin
   return fix_non_null_sub_types;
end get_fix_non_null_sub_types;
----------------------------------------
-- Centralized function GLOBAL lock handles
function allocate_lock
      (lockname_in  in  varchar2
      ,exp_secs_in  in  number  default 43200)
   return varchar2
is
   PRAGMA AUTONOMOUS_TRANSACTION;
   ret_txt  varchar2(128);
begin
   dbms_lock.allocate_unique(lockname        => lockname_in
                            ,lockhandle      => ret_txt
                            ,expiration_secs => exp_secs_in);
   return ret_txt;
end allocate_lock;
----------------------------------------
-- Centralized Multi-locks, used for Unique Key Temporal Continuity Constraints
function get_multi_lock
      (lhandle_in  in  varchar2
      ,timeout_in  in  INTEGER  default DBMS_LOCK.MAXWAIT)
   return  varchar2
is
   retcd   number;
begin
   -- These locks will slow a bulk insert/update.
   -- Commits should be done about every 100 records.
   retcd := dbms_lock.request(lockhandle        => lhandle_in
                             ,lockmode          => DBMS_LOCK.X_MODE
                             ,timeout           => timeout_in
                             ,release_on_commit => TRUE);
   case retcd
   when 0 then return 'SUCCESS';
   when 1 then return 'TIMEOUT';
   when 2 then return 'DEADLOCK';
   when 3 then return 'PARAMETER ERROR';
   when 4 then return 'ALREADY LOCKED';
   when 5 then return 'ILLEGAL LOCKNAME';
          else return 'UNKNOWN: ' || retcd;
   end case;
end get_multi_lock;
----------------------------------------
-- Centralized procedures GLOBAL locks
function request_lock
      (lockname_in  in  varchar2
      ,timeout_in   in  INTEGER  default null)
   return varchar2
is
begin
   if st_lockname is not null AND st_lockname != lockname_in then
      return 'RELEASE ONLY';
   end if;
   st_lockname   := substr(lockname_in,1,128);
   st_lockhandle := allocate_lock(st_lockname);
   return get_multi_lock(st_lockhandle);
end request_lock;
----------------------------------------
-- Centralized procedure GLOBAL locks
function release_lock
   return varchar2
is
   retcd INTEGER;
begin
   if st_lockname is null then return 'SUCCESS'; end if;
   retcd := dbms_lock.release(lockhandle => st_lockhandle);
   st_lockname := null;
   case retcd
   when 0 then return 'SUCCESS';
   when 3 then return 'PARAMETER ERROR';
   when 4 then return 'SUCCESS'; -- This session doesn't own the lock
   when 5 then return 'ILLEGAL LOCKNAME';
          else return 'UNKNOWN: ' || retcd;
   end case;
end release_lock;
----------------------------------------
-- Wait/Delay Procedure
procedure wait
         (seconds_in  in  number default null)
is
begin
   dbms_lock.sleep(nvl(seconds_in,0.01));
end wait;
----------------------------------------
-- Comparison with NULL handling
function is_equal
      (t1_in  in  varchar2
      ,t2_in  in  varchar2
      )  return boolean
is
begin
   if t1_in = t2_in or (t1_in is null and t2_in is null)
   then return TRUE;
   else return FALSE;
   end if;
end is_equal;
----------------------------------------
-- Comparison with NULL handling
function is_equal
      (n1_in  in  number
      ,n2_in  in  number
      )  return boolean
is
begin
   if n1_in = n2_in or (n1_in is null and n2_in is null)
   then return TRUE;
   else return FALSE;
   end if;
end is_equal;
----------------------------------------
-- Comparison with NULL handling
function is_equal
      (b1_in  in  blob
      ,b2_in  in  blob
      )  return boolean
is
   ret_num  number;
begin
   if b1_in is null and b2_in is null then return TRUE; end if;
   if b1_in is null or b2_in is null then return FALSE; end if;
   ret_num := dbms_lob.compare(b1_in, b2_in);
   if ret_num is not null and ret_num = 0 then return TRUE; end if;
   return FALSE;
end is_equal;
----------------------------------------
-- Comparison with NULL handling
function is_equal
      (x1_in  in  xmltype
      ,x2_in  in  xmltype
      )  return boolean
is
   diff_len  number;
begin
   if x1_in is null and x2_in is null then return TRUE; end if;
   if x1_in is null or x2_in is null then return FALSE; end if;
   select length(diff_val) into diff_len
      from xmltable(xmlnamespaces(default 'http://xmlns.oracle.com/xdb/xdiff.xsd')
                   ,'/'
                    passing xmldiff(x1_in, x2_in, 0, 'XMLDF_FL_ALGORITHM_LOCAL')
            columns diff_val clob path '/xdiff');
   if diff_len = 0 then return TRUE; end if;
   return FALSE;
end is_equal;
----------------------------------------
-- Comparison with NULL handling
function is_equal
      (g1_in   in  sdo_geometry
      ,g2_in   in  sdo_geometry
      ,tol_in  in  number default 0.05
      )  return boolean
is
   ret_str  varchar2(100);
begin
   if g1_in is null and g2_in is null then return TRUE; end if;
   if g1_in is null or g2_in is null then return FALSE; end if;
   ret_str := sdo_geom.relate(g1_in, 'EQUAL', g2_in, tol_in);
   if ret_str = 'EQUAL' then return TRUE; end if;
   return FALSE;
end is_equal;
----------------------------------------
-- Boolean Conversion Functions
function conv_bool
      (str_in  in  varchar2
      ) return boolean
is
begin
   if upper(substr(str_in,1,1)) = 'T'
   then return TRUE;
   else return FALSE;
   end if;
end conv_bool;
----------------------------------------
-- Boolean Conversion Functions
function conv_bool
      (bool_in   in  boolean
      ,true_in   in  varchar2
      ,false_in  in  varchar2
      ) return varchar2
is
begin
   if bool_in then return true_in;
              else return false_in;
   end if;
end conv_bool;
----------------------------------------
-- Boolean Conversion Functions
function conv_bool
      (bool_in   in  boolean
      ,true_in   in  number
      ,false_in  in  number
      ) return number
is
begin
   if bool_in then return true_in;
              else return false_in;
   end if;
end conv_bool;
----------------------------------------
-- Spatial Data Option Geometry Conversion Functions
function get_srid
      (geo_in  in  sdo_geometry
      ) return number
is
begin
   return geo_in.sdo_srid;
end get_srid;
----------------------------------------
-- Spatial Data Option Geometry Conversion Functions
function get_xcrd
      (geo_in  in  sdo_geometry
      ) return number
is
begin
   return geo_in.sdo_point.x;
end get_xcrd;
----------------------------------------
-- Spatial Data Option Geometry Conversion Functions
function get_ycrd
      (geo_in  in  sdo_geometry
      ) return number
is
begin
   return geo_in.sdo_point.y;
end get_ycrd;
----------------------------------------
-- Spatial Data Option Geometry Conversion Functions
function get_geom_2dpt
      (xcrd_in  in  number
      ,ycrd_in  in  number
      ,srid_in  in  number
      ) return sdo_geometry
is
begin
   if xcrd_in is null or ycrd_in is null then return null; end if;
   return sdo_geometry(2001, srid_in
                           , sdo_point_type(xcrd_in, ycrd_in, null)
                           , null, null );
end get_geom_2dpt;
----------------------------------------
-- Convert string to US7ASCII characters (the characters
--   that are commonly available on your keyboard
function ascii_conv
         (str_in   in  varchar2)
   return varchar2
is
   char_val  number;
   i_char    varchar2(8);
   ret_str   varchar2(32767) := '';
   procedure add_hex_rep is begin
      if include_unknown_ascii then
         -- Add a Hexadecimal Representative of the character
         ret_str := ret_str || '&#x' || substr(i_char,2) || ';';
      end if;
   end add_hex_rep;
begin
   for i in 1 .. length(str_in) loop
      -- Extract each character from the string and
      --   convert it to UTF-16 encoding
      i_char := asciistr(substr(str_in,i,1));
      if length(i_char) = 1 then
         char_val := ascii(i_char);
         if char_val between 9 and 12 or  -- [:space:] is 9, 10, 11, 12, and 32
            char_val between 32 and 126
         then
            -- This is a US7ASCII Printable Character, add it
            ret_str := ret_str || i_char;
         elsif include_unknown_ascii then
            -- This is a US7ASCII Non-Printable Character
            ret_str := ret_str || '&#' || char_val || ';';
         end if;
      elsif substr(i_char,1,1) != '\' then
         if include_unknown_ascii then
            -- Add a NULL place holder for the character
            ret_str := ret_str || '&#0;';
         end if;
      -- Change commonly used UTF-16 characters to ASCII-7
      --   This was formerly implemented as an associative array.
      --   The "case" statement may execute slower, but loads "statically"
      --   Static loading is prefered for APEX page processing
      elsif substr(i_char,2,2) = '00' then
         case substr(i_char,4,1)
         when 'A' then
            case substr(i_char,5)           -- \00A*
            when '0' then ret_str := ret_str || '  ';
            when '1' then ret_str := ret_str || '!';
            when '2' then ret_str := ret_str || 'c';
            when '3' then ret_str := ret_str || 'L';
            when '5' then ret_str := ret_str || 'Y';
            when '6' then ret_str := ret_str || '|';
            when '7' then ret_str := ret_str || 'S';
            when '8' then ret_str := ret_str || '..';
            when '9' then ret_str := ret_str || '(c)';
            when 'A' then ret_str := ret_str || '^a';
            when 'B' then ret_str := ret_str || '<<';
            when 'C' then ret_str := ret_str || '-not-';
            when 'D' then ret_str := ret_str || '-';
            when 'E' then ret_str := ret_str || '(R)';
            else add_hex_rep;
            end case;
         when 'B' then
            case substr(i_char,5)           -- \00B*
            when '0' then ret_str := ret_str || 'Deg';
            when '1' then ret_str := ret_str || '+/-';
            when '2' then ret_str := ret_str || '^2';
            when '3' then ret_str := ret_str || '^3';
            when '4' then ret_str := ret_str || '''';
            when '5' then ret_str := ret_str || 'u';
            when '6' then ret_str := ret_str || '(P)';
            when '7' then ret_str := ret_str || '-';
            when '9' then ret_str := ret_str || '^1';
            when 'A' then ret_str := ret_str || '^o';
            when 'B' then ret_str := ret_str || '>>';
            when 'C' then ret_str := ret_str || '1/4';
            when 'D' then ret_str := ret_str || '1/2';
            when 'E' then ret_str := ret_str || '3/4';
            when 'F' then ret_str := ret_str || '?';
            else add_hex_rep;
            end case;
         when 'C' then
            case substr(i_char,5)           -- \00C*
            when '0' then ret_str := ret_str || 'A';
            when '1' then ret_str := ret_str || 'A';
            when '2' then ret_str := ret_str || 'A';
            when '3' then ret_str := ret_str || 'A';
            when '4' then ret_str := ret_str || 'A';
            when '5' then ret_str := ret_str || 'A';
            when '6' then ret_str := ret_str || 'AE';
            when '7' then ret_str := ret_str || 'C';
            when '8' then ret_str := ret_str || 'E';
            when '9' then ret_str := ret_str || 'E';
            when 'A' then ret_str := ret_str || 'E';
            when 'B' then ret_str := ret_str || 'E';
            when 'C' then ret_str := ret_str || 'I';
            when 'D' then ret_str := ret_str || 'I';
            when 'E' then ret_str := ret_str || 'I';
            when 'F' then ret_str := ret_str || 'I';
            else add_hex_rep;
            end case;
         when 'D' then
            case substr(i_char,5)           -- \00D*
            when '0' then ret_str := ret_str || 'D';
            when '1' then ret_str := ret_str || 'N';
            when '2' then ret_str := ret_str || 'O';
            when '3' then ret_str := ret_str || 'O';
            when '4' then ret_str := ret_str || 'O';
            when '5' then ret_str := ret_str || 'O';
            when '6' then ret_str := ret_str || 'O';
            when '7' then ret_str := ret_str || '*';
            when '8' then ret_str := ret_str || 'OE';
            when '9' then ret_str := ret_str || 'U';
            when 'A' then ret_str := ret_str || 'U';
            when 'B' then ret_str := ret_str || 'U';
            when 'C' then ret_str := ret_str || 'U';
            when 'D' then ret_str := ret_str || 'Y';
            when 'E' then ret_str := ret_str || 'TH';
            when 'F' then ret_str := ret_str || 'B';
            else add_hex_rep;
            end case;
         when 'E' then
            case substr(i_char,5)           -- \00E*
            when '0' then ret_str := ret_str || 'a';
            when '1' then ret_str := ret_str || 'a';
            when '2' then ret_str := ret_str || 'a';
            when '3' then ret_str := ret_str || 'a';
            when '4' then ret_str := ret_str || 'a';
            when '5' then ret_str := ret_str || 'a';
            when '6' then ret_str := ret_str || 'ae';
            when '7' then ret_str := ret_str || 'c';
            when '8' then ret_str := ret_str || 'e';
            when '9' then ret_str := ret_str || 'e';
            when 'A' then ret_str := ret_str || 'e';
            when 'B' then ret_str := ret_str || 'e';
            when 'C' then ret_str := ret_str || 'i';
            when 'D' then ret_str := ret_str || 'i';
            when 'E' then ret_str := ret_str || 'i';
            when 'F' then ret_str := ret_str || 'i';
            else add_hex_rep;
            end case;
         when 'F' then
            case substr(i_char,5)           -- \00F*
            when '0' then ret_str := ret_str || 'd';
            when '1' then ret_str := ret_str || 'n';
            when '2' then ret_str := ret_str || '0';
            when '3' then ret_str := ret_str || '0';
            when '4' then ret_str := ret_str || '0';
            when '5' then ret_str := ret_str || '0';
            when '6' then ret_str := ret_str || '0';
            when '7' then ret_str := ret_str || '/';
            when '8' then ret_str := ret_str || 'oe';
            when '9' then ret_str := ret_str || 'u';
            when 'A' then ret_str := ret_str || 'u';
            when 'B' then ret_str := ret_str || 'u';
            when 'C' then ret_str := ret_str || 'u';
            when 'D' then ret_str := ret_str || 'u';
            when 'E' then ret_str := ret_str || 'th';
            when 'F' then ret_str := ret_str || 'y';
            else add_hex_rep;
            end case;
         else add_hex_rep;
         end case;
      else
         case substr(i_char,2,1)
         when '0' then
            case substr(i_char,3)             -- \0*
            when '142' then ret_str := ret_str || 'Z';
            when '152' then ret_str := ret_str || 'CE';
            when '153' then ret_str := ret_str || 'ce';
            when '158' then ret_str := ret_str || 'z';
            when '160' then ret_str := ret_str || 'S';
            when '161' then ret_str := ret_str || 's';
            when '178' then ret_str := ret_str || 'Y';
            when '192' then ret_str := ret_str || 'f';
            when '2C6' then ret_str := ret_str || '^';
            when '2DC' then ret_str := ret_str || '~';
            else add_hex_rep;
            end case;
         when '2' then
            case substr(i_char,3)             -- \2*
            when '013' then ret_str := ret_str || '-';
            when '014' then ret_str := ret_str || '--';
            when '018' then ret_str := ret_str || '''';
            when '019' then ret_str := ret_str || '''';
            when '01A' then ret_str := ret_str || '''';
            when '01C' then ret_str := ret_str || '"';
            when '01D' then ret_str := ret_str || '"';
            when '01E' then ret_str := ret_str || '"';
            when '020' then ret_str := ret_str || '+';
            when '021' then ret_str := ret_str || '++';
            when '022' then ret_str := ret_str || '*)';
            when '026' then ret_str := ret_str || '...';
            when '030' then ret_str := ret_str || '0/00';
            when '039' then ret_str := ret_str || '<';
            when '03A' then ret_str := ret_str || '>';
            when '0AC' then ret_str := ret_str || 'EU';
            when '122' then ret_str := ret_str || '(TM)';
            else add_hex_rep;
            end case;
         else add_hex_rep;
         end case;
      end if;
   end loop;
   return ret_str;
end ascii_conv;
----------------------------------------
-- Remove leading and trailing spaces, reduce multiple spaces to 1
function comp_spc
         (str_in   in  varchar2)
   return varchar2
is
begin
   return regexp_replace(
             regexp_replace(
                regexp_replace(str_in
                              ,'^[[:space:]]+', '', 1, 1)  -- Replace 1st occurance at beg
                           ,'[[:space:]]+$', '', 1, 1)  -- Replace 1st occurance at end
                        ,'[[:space:]]+', ' ', 1, 0)  -- Replace ALL occurances
                        ;
end comp_spc;
----------------------------------------
-- Long Operations Logging Procedures
procedure init_longops
      (opname_in       in  varchar2
      ,totalwork_in    in  number
      ,target_desc_in  in  varchar2
      ,units_in        in  varchar2)
is
begin
   if lo_rindex = dbms_application_info.set_session_longops_nohint then
      lo_slno        := null;
      lo_op_name     := opname_in;
      lo_target      := 0;
      lo_context     := 0;
      lo_sofar       := 0;
      lo_totalwork   := totalwork_in;
      lo_target_desc := target_desc_in;
      lo_units       := units_in;
      dbms_application_info.set_session_longops
         (lo_rindex, lo_slno, lo_op_name, lo_target, lo_context,
          lo_sofar, lo_totalwork, lo_target_desc, lo_units);
   end if;
end init_longops;
----------------------------------------
-- Long Operations Logging Procedures
procedure add_longops
      (add_sofar_in  in  number)
is
begin
   if lo_rindex <> dbms_application_info.set_session_longops_nohint then
      lo_sofar := lo_sofar + add_sofar_in;
      dbms_application_info.set_session_longops
         (lo_rindex, lo_slno, lo_op_name, lo_target, lo_context,
          lo_sofar, lo_totalwork, lo_target_desc, lo_units);
   end if;
end add_longops;
----------------------------------------
-- Long Operations Logging Procedures
procedure end_longops
is
begin
   if lo_rindex <> dbms_application_info.set_session_longops_nohint then
      lo_sofar := lo_totalwork;
      dbms_application_info.set_session_longops
         (lo_rindex, lo_slno, lo_op_name, lo_target, lo_context,
          lo_sofar, lo_totalwork, lo_target_desc, lo_units);
      lo_rindex := dbms_application_info.set_session_longops_nohint;
   end if;
end end_longops;
----------------------------------------
-- Logging, Tracing, and Error Procedures
procedure log
      (txt_in  in  varchar2
      ,loc_in  in  varchar2 default null
      )
is
/*  Sample output from DBMS_UTILITY.FORMAT_CALL_STACK:
----- PL/SQL Call Stack -----
  object      line  object
  handle    number  name
A4A6A840        76  package body GEN2.UTIL
AA345744         6  anonymous block
AA345744        16  anonymous block
*/
   PRAGMA AUTONOMOUS_TRANSACTION;
   usr_buff  VARCHAR2(30);
   fcs_txt  varchar2(2000);
   log_txt  varchar2(4000);  -- Required for Multi-byte Character CLOB Conversion
begin
   -- pragma restrict_references(format_call_stack,WNDS);
   -- WNDS Asserts that the subprogram writes no database state
   --      (does not modify database tables).
   -- DBMS_UTILITY.FORMAT_CALL_STACK returns up to 2000 characters
   fcs_txt := DBMS_UTILITY.FORMAT_CALL_STACK;
   usr_buff := nvl(current_usr, USER);
   log_txt := substrb(txt_in,1,4000);
   insert into util_log
         (dtm
         ,usr
         ,sid
         ,txt
         ,loc
         )
      values
         (systimestamp
         ,usr_buff
         ,sys_context('USERENV', 'SID')
         ,log_txt
         ,nvl(substr(loc_in,1,4000), fcs_txt)
         );
   -- DO NOT dbms_output.put_line(txt_in || fcs_txt);
   commit;
end log;
----------------------------------------
-- Re-Check for trace keys
procedure set_no_trace_keys
is
   PRAGMA AUTONOMOUS_TRANSACTION;
   cursor loc_curs is select loc from util_trc;
   loc_buff  loc_curs%ROWTYPE;
begin
   open loc_curs; fetch loc_curs into loc_buff;
   no_trace_keys := loc_curs%NOTFOUND; close loc_curs;
end set_no_trace_keys;
----------------------------------------
-- Logging, Tracing, and Error Procedures
procedure trc
      (key_in  in  varchar2
      ,txt_in  in  varchar2
      )
is
   cursor c_trc (loc_in varchar2
                ,usr_in VARCHAR2
                ,sid_in number)
   is
      select 'X' from util_trc
       where (loc = '%' or loc_in like loc)
        and  (txt = '%' or txt_in like txt)
        and  (usr = '%' or usr_in like usr)
        and  (sid =  0  or sid_in =    sid);
   loc_buff  util_trc.loc%TYPE;
   usr_buff  VARCHAR2(30);
   jnk       varchar2(1);
begin
   if no_trace_keys then return; end if;
   set_no_trace_keys;
   if no_trace_keys then return; end if;
   loc_buff := 'KEY=' || substr(key_in,1,                     128) ||
             ', ACT=' || sys_context('USERENV', 'ACTION',      32) ||
             ', MOD=' || sys_context('USERENV', 'MODULE',      48) ||
             ', CI='  || sys_context('USERENV', 'CLIENT_INFO', 64) ||
             ', HST=' || sys_context('USERENV', 'HOST',        64) ||
             ', TRM=' || sys_context('USERENV', 'TERMINAL',    32) ||
             ', OU='  || sys_context('USERENV', 'OS_USER',     32);
   usr_buff := nvl(current_usr, USER);
   open c_trc (loc_buff
              ,usr_buff
              ,sys_context('USERENV', 'SID'));
   fetch c_trc into jnk;
   if c_trc%FOUND then log(txt_in, loc_buff); end if;
   close c_trc;
end trc;
----------------------------------------
-- Logging, Tracing, and Error Procedures
procedure err
      (txt_in  in  varchar2
      )
is
   fcs_txt  varchar2(2000) := DBMS_UTILITY.FORMAT_ERROR_BACKTRACE;
   retstr   varchar2(100);
begin
   log (txt_in, fcs_txt);
   end_longops;
   retstr := release_lock;
end err;
----------------------------------------
-- Logging, Tracing, and Error Procedures
procedure trc_time_interval
      (key_in  in  varchar2
      ,tst_in  in  timestamp
      )
is
   tstr   varchar2(100);
begin
   if no_trace_keys then return; end if;
   --  NOTE: "to_char" format does not seem to work
   --        tstr = '+000000000 00:00:00.000000000'
   tstr := to_char(systimestamp - tst_in);
   trc('TI ' || key_in, substr(tstr, instr(tstr, ' ')+1));
end trc_time_interval;
----------------------------------------
-- Fix the Name portion of a Name-Value Pair
function fix_nvp_name
         (name_in   in  varchar2)
   return varchar2
is
begin
   return upper
            (regexp_replace
               (regexp_replace
                  (regexp_replace
                     (ascii_conv(name_in)
                     ,'^[[:space:]]+', '', 1, 1)  -- Replace 1st occurance at beg
                  ,'[[:space:]]+$', '', 1, 1)  -- Replace 1st occurance at end
               ,'[[:space:]]+', ' ', 1, 0)  -- Replace ALL occurances
            );
end fix_nvp_name;
----------------------------------------
-- Save a Name-Value Pair in the Database
procedure set_nvp
         (name_in   in  varchar2
         ,value_in  in  varchar2
         ,descr_in  in  varchar2 default null
         )
is
   fixed_name  varchar2(30);
begin
   fixed_name := fix_nvp_name(name_in);
   insert into util_nvp (name, value, description)
      values (fixed_name, value_in, descr_in);
exception
   when DUP_VAL_ON_INDEX then
      update util_nvp set value = value_in, description = descr_in
       where name = fixed_name;
end set_nvp;
----------------------------------------
-- Retreive a Name-Value Pair from the Database
function get_nvp
         (name_in  in  varchar2
         ) return varchar2
is
   fixed_name  varchar2(30);
   retval  varchar2(4000);
begin
   fixed_name := fix_nvp_name(name_in);
   select value into retval from util_nvp where name = fixed_name;
   return retval;
exception when NO_DATA_FOUND then return null;
end get_nvp;
----------------------------------------
-- Clear a Name-Value Pair in the Database
procedure clr_nvp
         (name_in   in  varchar2
         )
is
   fixed_name  varchar2(30);
begin
   fixed_name := fix_nvp_name(name_in);
   delete from util_nvp where name = fixed_name;
end clr_nvp;
----------------------------------------
-- Return the Special OMNI ID
function get_omni_id
      (id_in   in  number
      ,key_in  in  number
      ,dtm_in  in  TIMESTAMP WITH LOCAL TIME ZONE
      ) return number deterministic
is
begin
   return to_number(id_in || '.' || key_in ||
                    to_char(dtm_in, 'fmFF9fmSSSSSfmDDDfmYY') );
end get_omni_id;
----------------------------------------
begin
   st_lockname := null;
   lo_rindex := dbms_application_info.set_session_longops_nohint;
   set_no_trace_keys;
   asof_dtm  := systimestamp;
end util;
/

set define on
