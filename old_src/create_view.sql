
select '=== CLUE create_view ===' as SCRIPT_NAME from dual;

-- Script File "create_view"
--    Create Active View and DML Package

   -- Application: Clue Notes For Oracle
   -- Generated by DTGen (http://dmstex.com/services/dtgen)
   -- December  16, 2013  11:32:31 AM

   --
   --
   -- © Duane.Dieterich@DMSTEX.com 2013
   --
   -- All Rights Reserved
   --
   -- No part of this software may be reproduced, copied, modified or adapted,
   -- without the prior written consent of the author, unless otherwise
   -- indicated for stand-alone materials.
   --
   -- You may quote extracts from this software with attribution to
   -- Duane.Dieterich@DMSTEX.com
   --
   -- For any other mode of sharing, please contact Duane.Dieterich@DMSTEX.com.
   --
   -- Commercial use and distribution of this software is not allowed without
   -- express and prior written consent of the author.
   --
   -- THE SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
   -- INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY
   -- AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL
   -- THE COPYRIGHT HOLDER OR DMSTEX BUSINESS SOLUTIONS LLC, ITS MEMBERS,
   -- MANAGERS, OR EMPLOYEES BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
   -- SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
   -- TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
   -- PROFITS; CORRUPTION OF DATA, OR BUSINESS INTERRUPTION) HOWEVER CAUSED
   -- AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
   -- OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF
   -- THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH
   -- DAMAGE.
   --
   --




create view users_act
      (id
      ,name
      )
   as select
       USR.id
      ,USR.name
 from             users USR
/
select 'USERS_ACT' as "View:"
 from  user_errors
 where name  = 'USERS_ACT'
  and  type  = 'VIEW'
  and  rownum = 1
/
select '('||line||'/'||position||') '||text as error
 from  user_errors
 where name = 'USERS_ACT'
  and  type = 'VIEW'
 order by sequence
/

comment on table users_act is 'Registered Users'
/

comment on column users_act.id is 'Surrogate Primary Key for these users'
/
comment on column users_act.name is 'Clue Notes User Name'
/

alter view users_act add constraint users_act_pk
   primary key (id) disable
/


CREATE type users_vobj
is
   -- Users Active View (Virtual) Record Type
object
   (id  NUMBER(38)
   ,name  VARCHAR2(320)
   )
/
select 'USERS_VOBJ' as "Type:"
 from  user_errors
 where name  = 'USERS_VOBJ'
  and  type  = 'TYPE'
  and  rownum = 1
/
select '('||line||'/'||position||') '||text as error
 from  user_errors
 where name = 'USERS_VOBJ'
  and  type = 'TYPE'
 order by sequence
/

CREATE type users_vtab
is
   -- Users Active View (Virtual) Table Type
table of users_vobj
/
select 'USERS_VTAB' as "Type:"
 from  user_errors
 where name  = 'USERS_VTAB'
  and  type  = 'TYPE'
  and  rownum = 1
/
select '('||line||'/'||position||') '||text as error
 from  user_errors
 where name = 'USERS_VTAB'
  and  type = 'TYPE'
 order by sequence
/

create package users_dml
is

   -- Package Users_Dml
   -- (Data Manipulation Language, Foreign Key and Path Lookup)

   -- Application: Clue Notes For Oracle
   -- Generated by DTGen (http://dmstex.com/services/dtgen)
   -- December  16, 2013  11:32:31 AM

   --
   --
   -- © Duane.Dieterich@DMSTEX.com 2013
   --
   -- All Rights Reserved
   --
   -- No part of this software may be reproduced, copied, modified or adapted,
   -- without the prior written consent of the author, unless otherwise
   -- indicated for stand-alone materials.
   --
   -- You may quote extracts from this software with attribution to
   -- Duane.Dieterich@DMSTEX.com
   --
   -- For any other mode of sharing, please contact Duane.Dieterich@DMSTEX.com.
   --
   -- Commercial use and distribution of this software is not allowed without
   -- express and prior written consent of the author.
   --
   -- THE SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
   -- INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY
   -- AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL
   -- THE COPYRIGHT HOLDER OR DMSTEX BUSINESS SOLUTIONS LLC, ITS MEMBERS,
   -- MANAGERS, OR EMPLOYEES BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
   -- SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
   -- TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
   -- PROFITS; CORRUPTION OF DATA, OR BUSINESS INTERRUPTION) HOWEVER CAUSED
   -- AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
   -- OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF
   -- THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH
   -- DAMAGE.
   --
   --


   -- Return the next Surrogate Key ID for users
   function get_next_id
      return NUMBER;
   -- Return the current Surrogate Key ID for users
   --   NOTE: This will return an ERROR if get_next_id has not been called
   function get_curr_id
      return NUMBER;

   -- Return the next Surrogate Key ID for the Natural Keys of users
   function get_id
      (name  in  VARCHAR2
      ) return NUMBER;
   -- Return a concatenated string of Natural Keys for a users id
   function get_nk
      (id_in  in  NUMBER
      ) return VARCHAR2;

   -- Set a "table" record to null
   -- NOTE: users_act%ROWTYPE is identical to users%ROWTYPE
   procedure clear
      (n_tab  in out nocopy  users%ROWTYPE
      );
   -- This function traps and returns any error message from the clear procedure
   function clear
      (n_tab  in out nocopy  users%ROWTYPE
      ) return varchar2;

   -- Set a "table" record from a users ID
   -- NOTE: users_act%ROWTYPE is identical to users%ROWTYPE
   procedure get_rec_by_id
      (n_tab  in out nocopy  users%ROWTYPE
      );
   -- This function traps and returns any error message from the get_rec_by_id procedure
   function get_rec_by_id
      (n_tab  in out nocopy  users%ROWTYPE
      ) return varchar2;

   -- NOTE: All INS procedures will run faster with a null ID
   --       because it avoids a history search for duplicate IDs
   --
   -- Insert a users Table Record
   -- NOTE: users_act%ROWTYPE is identical to users%ROWTYPE
   --  (Fastest insert procedure and returned data is always valid)
   procedure ins
      (new_tab  in out nocopy  users%ROWTYPE
      );
   -- This function traps and returns any error message from the ins procedure
   function ins
      (new_tab  in out nocopy  users%ROWTYPE
      ) return varchar2;
   -- Insert columns for users ACTIVE View
   --   without returning updated data in each column
   procedure ins
      (id_in  in  NUMBER default null
      ,name_in  in  VARCHAR2 default null
      );
   -- This function traps and returns any error message from the ins procedure
   function ins
      (id_in  in  NUMBER default null
      ,name_in  in  VARCHAR2 default null
      ) return varchar2;
   -- Insert columns for users Table
   --   with updated data returned in each column
   procedure ins2
      (id_io  in out nocopy  NUMBER
      ,name_io  in out nocopy  VARCHAR2
      );
   -- This function traps and returns any error message from the ins2 procedure
   function ins2
      (id_io  in out nocopy  NUMBER
      ,name_io  in out nocopy  VARCHAR2
      ) return varchar2;

   -- Special Use Update for Specific Column Updates.
   --   Only differences between old and new data will be updated.
   --   Set upd_val_in TRUE to get updated data in new_rec
   procedure upd
      (old_tab  in  users%ROWTYPE
      ,new_tab  in out nocopy  users%ROWTYPE
      );
   -- This function traps and returns any error message from the upd procedure
   function upd
      (old_tab  in  users%ROWTYPE
      ,new_tab  in out nocopy  users%ROWTYPE
      ) return varchar2;
   -- Update a users Table Record
   -- NOTE: users_act%ROWTYPE is identical to users%ROWTYPE
   --  (Fastest update procedure and returned data is always valid)
   -- NOTE: usersID must be supplied (NK lookup will not be performed)
   procedure upd
      (new_tab  in out nocopy  users%ROWTYPE
      );
   -- This function traps and returns any error message from the upd procedure
   function upd
      (new_tab  in out nocopy  users%ROWTYPE
      ) return varchar2;
   -- Update columns for users ACTIVE View
   --   without returning updated data in each column
   procedure upd
      (id_in  in  NUMBER default null
      ,name_in  in  VARCHAR2 default null
      );
   -- This function traps and returns any error message from the upd procedure
   function upd
      (id_in  in  NUMBER default null
      ,name_in  in  VARCHAR2 default null
      ) return varchar2;
   -- Update columns for users Table
   --   with updated data returned in each column
   procedure upd2
      (id_io  in out nocopy  NUMBER
      ,name_io  in out nocopy  VARCHAR2
      );
   -- This function traps and returns any error message from the upd2 procedure
   function upd2
      (id_io  in out nocopy  NUMBER
      ,name_io  in out nocopy  VARCHAR2
      ) return varchar2;

   -- Application Delete procedure without updated parameters
   procedure del
      (id_in  in  NUMBER default null
      ,name_in  in  VARCHAR2 default null
      );
   -- This function traps and returns any error message from the del procedure
   function del
      (id_in  in  NUMBER default null
      ,name_in  in  VARCHAR2 default null
      ) return varchar2;
   -- Application Delete procedure with updated parameters
   procedure del2
      (id_io  in out nocopy  NUMBER
      ,name_in  in VARCHAR2 default null
      );
   -- This function traps and returns any error message from the del2 procedure
   function del2
      (id_io  in out nocopy  NUMBER
      ,name_in  in VARCHAR2 default null
      ) return varchar2;

   -- Special Data Warehouse Dimension Function
   --   Attempts to find matching record based on natural keys
   --   If found, performs updates on non-NK columns that changed
   --   If not found, inserts new record
   --   Returns ID of record
   procedure load_dim
      (dim_tab  in out nocopy  users%ROWTYPE
      );
   -- This function traps and returns any error message from the load_dim procedure
   function load_dim
      (dim_tab  in out nocopy  users%ROWTYPE
      ) return varchar2;

end users_dml;
/
select 'USERS_DML' as "Package:"
 from  user_errors
 where name  = 'USERS_DML'
  and  type  = 'PACKAGE'
  and  rownum = 1
/
select '('||line||'/'||position||') '||text as error
 from  user_errors
 where name = 'USERS_DML'
  and  type = 'PACKAGE'
 order by sequence
/

create package body users_dml
is

 -- Package Body Users_Dml
 -- (Data Manipulation Language, Foreign Key and Path Lookup)

   -- Application: Clue Notes For Oracle
   -- Generated by DTGen (http://dmstex.com/services/dtgen)
   -- December  16, 2013  11:32:31 AM

   --
   --
   -- © Duane.Dieterich@DMSTEX.com 2013
   --
   -- All Rights Reserved
   --
   -- No part of this software may be reproduced, copied, modified or adapted,
   -- without the prior written consent of the author, unless otherwise
   -- indicated for stand-alone materials.
   --
   -- You may quote extracts from this software with attribution to
   -- Duane.Dieterich@DMSTEX.com
   --
   -- For any other mode of sharing, please contact Duane.Dieterich@DMSTEX.com.
   --
   -- Commercial use and distribution of this software is not allowed without
   -- express and prior written consent of the author.
   --
   -- THE SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
   -- INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY
   -- AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL
   -- THE COPYRIGHT HOLDER OR DMSTEX BUSINESS SOLUTIONS LLC, ITS MEMBERS,
   -- MANAGERS, OR EMPLOYEES BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
   -- SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
   -- TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
   -- PROFITS; CORRUPTION OF DATA, OR BUSINESS INTERRUPTION) HOWEVER CAUSED
   -- AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
   -- OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF
   -- THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH
   -- DAMAGE.
   --
   --


----------------------------------------
function get_next_id
      return NUMBER
is
   retid  NUMBER;
begin
   select users_seq.nextval
    into  retid from dual;
   return retid;
end get_next_id;
----------------------------------------
function get_curr_id
      return NUMBER
is
   retid  NUMBER;
begin
   select users_seq.currval
    into  retid from dual;
   return retid;
end get_curr_id;
----------------------------------------
function get_id
      (name  in  VARCHAR2
      ) return number
   -- For all the Natural Key Columns, Return an ID
is
begin
   return users_tab.get_id
      (name
      );
end get_id;
----------------------------------------
function get_nk
      (id_in  in  NUMBER)
   return VARCHAR2
   -- For an ID, return a delimited list of Natural Key Values
is
begin
   return users_tab.get_nk(id_in);
end get_nk;
----------------------------------------
procedure clear
      (n_tab  in out nocopy  users%ROWTYPE
      )
is
begin
   n_tab.id := null;
   n_tab.name := null;
end clear;
----------
function clear
      (n_tab  in out nocopy  users%ROWTYPE
      ) return varchar2
is
begin
   clear(n_tab);
   return '';
exception when others then return sqlerrm;
end clear;
----------------------------------------
procedure get_rec_by_id
      (n_tab  in out nocopy  users%ROWTYPE
      )
is
   start_tstamp  timestamp := systimestamp;
begin
   if n_tab.id is null then
      clear(n_tab);
   else
      select * into n_tab from users
       where id = n_tab.id;
   end if;
   return;
   util.trc_time_interval('users_dml.get_rec_by_id(tab rec) ID:' || n_tab.id, start_tstamp);
end get_rec_by_id;
----------
function get_rec_by_id
      (n_tab  in out nocopy  users%ROWTYPE
      ) return varchar2
is
begin
   get_rec_by_id(n_tab);
   return '';
exception when others then return sqlerrm;
end get_rec_by_id;
----------------------------------------
-- Insert a users Table Record
procedure ins
      (new_tab   in out nocopy  users%ROWTYPE
      )
is
   start_tstamp  timestamp := systimestamp;
begin
   users_tab.ins(new_tab);
   return;
   util.trc_time_interval('users_dml.ins(tab rec) ID:' || new_tab.id, start_tstamp);
end ins;
----------
function ins
      (new_tab   in out nocopy  users%ROWTYPE
      ) return varchar2
is
begin
   ins(new_tab);
   return '';
exception when others then return sqlerrm;
end ins;
----------------------------------------
-- Insert columns for users ACTIVE View
--   without returning updated data in each column
procedure ins
      (id_in  in  NUMBER default null
      ,name_in  in  VARCHAR2 default null
      )
is
   new_rec  users_act%ROWTYPE;
   start_tstamp  timestamp := systimestamp;
begin
   new_rec.id := id_in;
   new_rec.name := name_in;
   users_tab.ins(new_rec);
   return;
   util.trc_time_interval('users_dml.ins(tab col) ID:' || id_in, start_tstamp);
end ins;
----------
function ins
      (id_in  in  NUMBER default null
      ,name_in  in  VARCHAR2 default null
      ) return varchar2
is
begin
   ins
      (id_in
      ,name_in
      );
   return '';
exception when others then return sqlerrm;
end ins;
----------------------------------------
-- Insert columns for users Table
--   with updated data returned in each column
procedure ins2
      (id_io  in out nocopy  NUMBER
      ,name_io  in out nocopy  VARCHAR2
      )
is
   new_rec  users%ROWTYPE;
   start_tstamp  timestamp := systimestamp;
begin
   new_rec.id := id_io;
   new_rec.name := name_io;
   --
   users_tab.ins(new_rec);
   --
   id_io := new_rec.id;
   name_io := new_rec.name;
   return;
   util.trc_time_interval('users_dml.ins2(tab col) ID:' || id_io, start_tstamp);
end ins2;
----------
function ins2
      (id_io  in out nocopy  NUMBER
      ,name_io  in out nocopy  VARCHAR2
      ) return varchar2
is
begin
   ins2
      (id_io
      ,name_io
      );
   return '';
exception when others then return sqlerrm;
end ins2;
----------------------------------------
-- Special Use Update for Specific Column Updates.
--   Only differences between old and new data will be updated.
--   Set upd_val_in TRUE to get updated data in new_rec
procedure upd
      (old_tab  in  users%ROWTYPE
      ,new_tab  in out nocopy  users%ROWTYPE
      )
is
   start_tstamp  timestamp := systimestamp;
begin
   if old_tab.id is null then
      raise_application_error (-20023, 'ID is null');
   end if;
   -- Run the update
   users_tab.upd(old_tab, new_tab);
   return;
   util.trc_time_interval('users_dml.upd(trigger) ID:' || old_tab.id, start_tstamp);
end upd;
----------
function upd
      (old_tab  in  users%ROWTYPE
      ,new_tab  in out nocopy  users%ROWTYPE
      ) return varchar2
is
begin
   upd(old_tab, new_tab);
   return '';
exception when others then return sqlerrm;
end upd;
----------------------------------------
-- Update a users Table Record
procedure upd
      (new_tab   in out nocopy  users%ROWTYPE
      )
is
   start_tstamp  timestamp := systimestamp;
begin
   if new_tab.id is null then
      if    new_tab.name is not null
      then
         begin
            select id into new_tab.id from users
             where name = new_tab.name
               ;
         exception when NO_DATA_FOUND then new_tab.id := null;
         end;
      end if;
   end if;
   if new_tab.id is null then
      raise_application_error (-20023, 'ID is null and could not be found from Natural Keys');
   end if;
   users_tab.upd(new_tab);
   return;
   util.trc_time_interval('users_dml.upd(tab rec) ID:' || new_tab.id, start_tstamp);
end upd;
----------
function upd
      (new_tab   in out nocopy  users%ROWTYPE
      ) return varchar2
is
begin
   upd(new_tab);
   return '';
exception when others then return sqlerrm;
end upd;
----------------------------------------
-- Update columns for users ACTIVE View
--   without returning updated data in each column
procedure upd
      (id_in  in  NUMBER default null
      ,name_in  in  VARCHAR2 default null
      )
is
   new_rec  users_act%ROWTYPE;
   start_tstamp  timestamp := systimestamp;
begin
   new_rec.id := id_in;
   new_rec.name := name_in;
   -- Make corrections when ID is supplied, but NK is missing
   if    new_rec.ID is not null
     and new_rec.name is null
   then
      select USR.name
       into  new_rec.name
       from  users_act  USR
       where USR.id = new_rec.ID;
   end if;
   upd(new_rec);
   return;
   util.trc_time_interval('users_dml.upd(act col) ID:' || id_in, start_tstamp);
end upd;
----------
function upd
      (id_in  in  NUMBER default null
      ,name_in  in  VARCHAR2 default null
      ) return varchar2
is
begin
   upd
      (id_in
      ,name_in
      );
   return '';
exception when others then return sqlerrm;
end upd;
----------------------------------------
-- Update columns for users Table
--   with updated data returned in each column
procedure upd2
      (id_io  in out nocopy  NUMBER
      ,name_io  in out nocopy  VARCHAR2
      )
is
   new_rec  users%ROWTYPE;
   start_tstamp  timestamp := systimestamp;
begin
   if id_io is null then
      if    name_io is not null
      then
         begin
            select id into id_io from users
             where name = name_io
               ;
         exception when NO_DATA_FOUND then id_io := null;
         end;
      end if;
   end if;
   if id_io is null then
      raise_application_error (-20023, 'ID is null and could not be found from Natural Keys');
   end if;
   new_rec.id := id_io;
   new_rec.name := name_io;
   --
   users_tab.upd(new_rec);
   --
   id_io := new_rec.id;
   name_io := new_rec.name;
   return;
   util.trc_time_interval('users_dml.upd2(tab col) ID:' || id_io, start_tstamp);
end upd2;
----------
function upd2
      (id_io  in out nocopy  NUMBER
      ,name_io  in out nocopy  VARCHAR2
      ) return varchar2
is
begin
    upd2
      (id_io
      ,name_io
      );
   return '';
exception when others then return sqlerrm;
end upd2;

----------------------------------------
-- Application Delete procedure without updated parameters
procedure del
      (id_in  in  NUMBER default null
      ,name_in  in  VARCHAR2 default null
      )
is
   start_tstamp  timestamp := systimestamp;
   tmp_id  NUMBER;
begin
   tmp_id := id_in;
   if tmp_id is null then
      if    name_in is not null
      then
         tmp_id := users_tab.get_id
            (name_in
            );
      end if;
   end if;
   if tmp_id is null then
      raise_application_error (-20023, 'ID is null and could not be found from Natural Keys');
   end if;
   users_tab.del(tmp_id);
   return;
   util.trc_time_interval('users_dml.del ID:' || id_in, start_tstamp);
end del;
----------
function del
      (id_in  in  NUMBER default null
      ,name_in  in  VARCHAR2 default null
      ) return varchar2
is
begin
   del
      (id_in
      ,name_in
      );
   return '';
exception when others then return sqlerrm;
end del;
----------------------------------------
-- Application Delete procedure with updated parameters
procedure del2
      (id_io  in out nocopy  NUMBER
      ,name_in  in  VARCHAR2 default null
      )
is
   start_tstamp  timestamp := systimestamp;
begin
   if id_io is null then
      if    name_in is not null
      then
         id_io := users_tab.get_id
            (name_in
            );
      end if;
   end if;
   if id_io is null then
      raise_application_error (-20023, 'ID is null and could not be found from Natural Keys');
   end if;
   users_tab.del(id_io);
   return;
   util.trc_time_interval('users_dml.del2 ID:' || id_io, start_tstamp);
end del2;
----------
function del2
      (id_io  in out nocopy  NUMBER
      ,name_in  in  VARCHAR2 default null
      ) return varchar2
is
begin
   del2
      (id_io
      ,name_in
      );
   return '';
exception when others then return sqlerrm;
end del2;
----------------------------------------
procedure load_dim
      (dim_tab  in out nocopy  users%ROWTYPE
      )
is
   -- Special Data Warehouse Dimension Function
   start_tstamp  timestamp := systimestamp;
   procedure private_upd is
      saved_inc  boolean := util.get_ignore_no_change;
   begin
      util.set_ignore_no_change(TRUE);
      upd (dim_tab);
      util.set_ignore_no_change(saved_inc);
   exception
      when others then
         util.set_ignore_no_change(saved_inc);
         raise;
   end private_upd;
begin
   -- Attempt to find matching record based on natural keys
   if dim_tab.id is null then
      begin
         select id
          into  dim_tab.id
          from  users
          where name = dim_tab.name
           and  name = dim_tab.name
         ;
      exception
         when NO_DATA_FOUND then dim_tab.id := null;
      end;
   end if;
   if dim_tab.id is not null then
      -- If found, perform update on non-NK columns that changed
      private_upd;
      return;
      util.trc_time_interval('users_dml.load_dimE ID:' || dim_tab.id, start_tstamp);
   end if;
   -- If not found, insert new record
   begin
      ins(dim_tab);
   exception
      when DUP_VAL_ON_INDEX then
         -- Since this can run multi-threaded, another thread
         --   may have already populated this value.
         private_upd;
   end;
   return;
   util.trc_time_interval('users_dml.load_dim ID:' || dim_tab.id, start_tstamp);
end load_dim;
----------
function load_dim
      (dim_tab  in out nocopy  users%ROWTYPE
      ) return varchar2
is
begin
   load_dim(dim_tab);
   return '';
exception when others then return sqlerrm;
end load_dim;
----------------------------------------
end users_dml;
/
select 'USERS_DML' as "Package Body:"
 from  user_errors
 where name  = 'USERS_DML'
  and  type  = 'PACKAGE BODY'
  and  rownum = 1
/
select '('||line||'/'||position||') '||text as error
 from  user_errors
 where name = 'USERS_DML'
  and  type = 'PACKAGE BODY'
 order by sequence
/

create TRIGGER users_act_ioi
   instead of insert on users_act
   for each row
declare

   -- Trigger Users_Act_Ioi

   -- Application: Clue Notes For Oracle
   -- Generated by DTGen (http://dmstex.com/services/dtgen)
   -- December  16, 2013  11:32:31 AM

   --
   --
   -- © Duane.Dieterich@DMSTEX.com 2013
   --
   -- All Rights Reserved
   --
   -- No part of this software may be reproduced, copied, modified or adapted,
   -- without the prior written consent of the author, unless otherwise
   -- indicated for stand-alone materials.
   --
   -- You may quote extracts from this software with attribution to
   -- Duane.Dieterich@DMSTEX.com
   --
   -- For any other mode of sharing, please contact Duane.Dieterich@DMSTEX.com.
   --
   -- Commercial use and distribution of this software is not allowed without
   -- express and prior written consent of the author.
   --
   -- THE SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
   -- INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY
   -- AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL
   -- THE COPYRIGHT HOLDER OR DMSTEX BUSINESS SOLUTIONS LLC, ITS MEMBERS,
   -- MANAGERS, OR EMPLOYEES BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
   -- SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
   -- TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
   -- PROFITS; CORRUPTION OF DATA, OR BUSINESS INTERRUPTION) HOWEVER CAUSED
   -- AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
   -- OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF
   -- THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH
   -- DAMAGE.
   --
   --


   new_rec  users_act%ROWTYPE;
   start_tstamp  timestamp := systimestamp;
begin
   new_rec.id := :new.id;
   new_rec.name := :new.name;
   users_tab.ins(new_rec);
   util.trc_time_interval('users_act_ioi trigger ID:' || :new.id, start_tstamp);
end users_act_ioi;
/
select 'USERS_ACT_IOI' as "Trigger:"
 from  user_errors
 where name  = 'USERS_ACT_IOI'
  and  type  = 'TRIGGER'
  and  rownum = 1
/
select '('||line||'/'||position||') '||text as error
 from  user_errors
 where name = 'USERS_ACT_IOI'
  and  type = 'TRIGGER'
 order by sequence
/

create TRIGGER users_act_iou
   instead of update on users_act
   for each row
declare

   -- Trigger Users_Act_Iou

   -- Application: Clue Notes For Oracle
   -- Generated by DTGen (http://dmstex.com/services/dtgen)
   -- December  16, 2013  11:32:31 AM

   --
   --
   -- © Duane.Dieterich@DMSTEX.com 2013
   --
   -- All Rights Reserved
   --
   -- No part of this software may be reproduced, copied, modified or adapted,
   -- without the prior written consent of the author, unless otherwise
   -- indicated for stand-alone materials.
   --
   -- You may quote extracts from this software with attribution to
   -- Duane.Dieterich@DMSTEX.com
   --
   -- For any other mode of sharing, please contact Duane.Dieterich@DMSTEX.com.
   --
   -- Commercial use and distribution of this software is not allowed without
   -- express and prior written consent of the author.
   --
   -- THE SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
   -- INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY
   -- AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL
   -- THE COPYRIGHT HOLDER OR DMSTEX BUSINESS SOLUTIONS LLC, ITS MEMBERS,
   -- MANAGERS, OR EMPLOYEES BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
   -- SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
   -- TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
   -- PROFITS; CORRUPTION OF DATA, OR BUSINESS INTERRUPTION) HOWEVER CAUSED
   -- AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
   -- OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF
   -- THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH
   -- DAMAGE.
   --
   --


   old_rec  users_act%ROWTYPE;
   new_rec  users_act%ROWTYPE;
   start_tstamp  timestamp := systimestamp;
begin
   -- NOTE: Column Specified Update DML works without this lock
   --select btab.id into new_rec.id from users btab
   -- where btab.id = :old.id for update;
   old_rec.id := :old.id;
   new_rec.id := :new.id;
   old_rec.name := :old.name;
   new_rec.name := :new.name;
   users_tab.upd(old_rec, new_rec);
   util.trc_time_interval('users_act_iou trigger ID:' || :old.id, start_tstamp);
end users_act_iou;
/
select 'USERS_ACT_IOU' as "Trigger:"
 from  user_errors
 where name  = 'USERS_ACT_IOU'
  and  type  = 'TRIGGER'
  and  rownum = 1
/
select '('||line||'/'||position||') '||text as error
 from  user_errors
 where name = 'USERS_ACT_IOU'
  and  type = 'TRIGGER'
 order by sequence
/

create TRIGGER users_act_iod
   instead of delete on users_act
   for each row
declare

   -- Trigger Users_Act_Iod

   -- Application: Clue Notes For Oracle
   -- Generated by DTGen (http://dmstex.com/services/dtgen)
   -- December  16, 2013  11:32:31 AM

   --
   --
   -- © Duane.Dieterich@DMSTEX.com 2013
   --
   -- All Rights Reserved
   --
   -- No part of this software may be reproduced, copied, modified or adapted,
   -- without the prior written consent of the author, unless otherwise
   -- indicated for stand-alone materials.
   --
   -- You may quote extracts from this software with attribution to
   -- Duane.Dieterich@DMSTEX.com
   --
   -- For any other mode of sharing, please contact Duane.Dieterich@DMSTEX.com.
   --
   -- Commercial use and distribution of this software is not allowed without
   -- express and prior written consent of the author.
   --
   -- THE SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
   -- INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY
   -- AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL
   -- THE COPYRIGHT HOLDER OR DMSTEX BUSINESS SOLUTIONS LLC, ITS MEMBERS,
   -- MANAGERS, OR EMPLOYEES BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
   -- SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
   -- TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
   -- PROFITS; CORRUPTION OF DATA, OR BUSINESS INTERRUPTION) HOWEVER CAUSED
   -- AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
   -- OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF
   -- THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH
   -- DAMAGE.
   --
   --


   start_tstamp  timestamp := systimestamp;
begin
   users_tab.del(:old.id);
   util.trc_time_interval('users_act_iod trigger ID:' || :old.id, start_tstamp);
end users_act_iod;
/
select 'USERS_ACT_IOD' as "Trigger:"
 from  user_errors
 where name  = 'USERS_ACT_IOD'
  and  type  = 'TRIGGER'
  and  rownum = 1
/
select '('||line||'/'||position||') '||text as error
 from  user_errors
 where name = 'USERS_ACT_IOD'
  and  type = 'TRIGGER'
 order by sequence
/


create view card_types_act
      (id
      ,user_id
      ,users_nk1
      ,name
      ,sort_ord
      )
   as select
       CTYPE.id
      ,CTYPE.user_id
      ,USR.name
      ,CTYPE.name
      ,CTYPE.sort_ord
 from             card_types CTYPE
       inner join users_act USR on USR.id = CTYPE.user_id
/
select 'CARD_TYPES_ACT' as "View:"
 from  user_errors
 where name  = 'CARD_TYPES_ACT'
  and  type  = 'VIEW'
  and  rownum = 1
/
select '('||line||'/'||position||') '||text as error
 from  user_errors
 where name = 'CARD_TYPES_ACT'
  and  type = 'VIEW'
 order by sequence
/

comment on table card_types_act is 'Players for each User''s Game'
/

comment on column card_types_act.id is 'Surrogate Primary Key for these card_types'
/
comment on column card_types_act.user_id is 'User for this Card Type'
/
comment on column card_types_act.users_nk1 is 'USERS Natural Key 1: Clue Notes User Name'
/
comment on column card_types_act.name is 'Card Type Name'
/
comment on column card_types_act.sort_ord is 'Sort Order for Card Types'
/

alter view card_types_act add constraint card_types_act_pk
   primary key (id) disable
/

alter view card_types_act add constraint card_types_act_fk1
   foreign key (user_id) references users_act (id) disable
/

CREATE type card_types_vobj
is
   -- Card_Types Active View (Virtual) Record Type
object
   (id  NUMBER(38)
   ,user_id  NUMBER(38)
   ,users_nk1  VARCHAR2(320)
   ,name  VARCHAR2(15)
   ,sort_ord  NUMBER(2)
   )
/
select 'CARD_TYPES_VOBJ' as "Type:"
 from  user_errors
 where name  = 'CARD_TYPES_VOBJ'
  and  type  = 'TYPE'
  and  rownum = 1
/
select '('||line||'/'||position||') '||text as error
 from  user_errors
 where name = 'CARD_TYPES_VOBJ'
  and  type = 'TYPE'
 order by sequence
/

CREATE type card_types_vtab
is
   -- Card_Types Active View (Virtual) Table Type
table of card_types_vobj
/
select 'CARD_TYPES_VTAB' as "Type:"
 from  user_errors
 where name  = 'CARD_TYPES_VTAB'
  and  type  = 'TYPE'
  and  rownum = 1
/
select '('||line||'/'||position||') '||text as error
 from  user_errors
 where name = 'CARD_TYPES_VTAB'
  and  type = 'TYPE'
 order by sequence
/

create package card_types_dml
is

   -- Package Card_Types_Dml
   -- (Data Manipulation Language, Foreign Key and Path Lookup)

   -- Application: Clue Notes For Oracle
   -- Generated by DTGen (http://dmstex.com/services/dtgen)
   -- December  16, 2013  11:32:31 AM

   --
   --
   -- © Duane.Dieterich@DMSTEX.com 2013
   --
   -- All Rights Reserved
   --
   -- No part of this software may be reproduced, copied, modified or adapted,
   -- without the prior written consent of the author, unless otherwise
   -- indicated for stand-alone materials.
   --
   -- You may quote extracts from this software with attribution to
   -- Duane.Dieterich@DMSTEX.com
   --
   -- For any other mode of sharing, please contact Duane.Dieterich@DMSTEX.com.
   --
   -- Commercial use and distribution of this software is not allowed without
   -- express and prior written consent of the author.
   --
   -- THE SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
   -- INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY
   -- AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL
   -- THE COPYRIGHT HOLDER OR DMSTEX BUSINESS SOLUTIONS LLC, ITS MEMBERS,
   -- MANAGERS, OR EMPLOYEES BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
   -- SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
   -- TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
   -- PROFITS; CORRUPTION OF DATA, OR BUSINESS INTERRUPTION) HOWEVER CAUSED
   -- AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
   -- OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF
   -- THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH
   -- DAMAGE.
   --
   --


   -- Return the next Surrogate Key ID for card_types
   function get_next_id
      return NUMBER;
   -- Return the current Surrogate Key ID for card_types
   --   NOTE: This will return an ERROR if get_next_id has not been called
   function get_curr_id
      return NUMBER;

   -- Return the next Surrogate Key ID for the Natural Keys of card_types
   --   NOTE: The fields used in this function are the Natural Keys for card_types
   --         Alternatively, the Natural Key IDs for card_types are:
   --            -) user_id
   --            -) name
   function get_id
      (users_nk1  in  VARCHAR2
      ,name  in  VARCHAR2
      ) return NUMBER;
   -- For all the Natural Key Column IDs, Return an ID
   function get_id2
      (user_id_in  in  NUMBER
      ,name_in  in  VARCHAR2
      ) return NUMBER;
   -- Return a concatenated string of Natural Keys for a card_types id
   function get_nk
      (id_in  in  NUMBER
      ) return VARCHAR2;

   -- Set a "view" record to null
   procedure clear
      (n_rec  in out nocopy  card_types_ACT%ROWTYPE
      );
   -- This function traps and returns any error message from the clear procedure
   function clear
      (n_rec  in out nocopy  card_types_ACT%ROWTYPE
      ) return varchar2;
   -- Set a "table" record to null
   procedure clear
      (n_tab  in out nocopy  card_types%ROWTYPE
      );
   -- This function traps and returns any error message from the clear procedure
   function clear
      (n_tab  in out nocopy  card_types%ROWTYPE
      ) return varchar2;

   -- Set a "view" record from a card_types ID
   procedure get_rec_by_id
      (n_rec  in out nocopy  card_types_ACT%ROWTYPE
      );
   -- This function traps and returns any error message from the get_rec_by_id procedure
   function get_rec_by_id
      (n_rec  in out nocopy  card_types_ACT%ROWTYPE
      ) return varchar2;
   -- Set a "table" record from a card_types ID
   procedure get_rec_by_id
      (n_tab  in out nocopy  card_types%ROWTYPE
      );
   -- This function traps and returns any error message from the get_rec_by_id procedure
   function get_rec_by_id
      (n_tab  in out nocopy  card_types%ROWTYPE
      ) return varchar2;

   -- NOTE: All INS procedures will run faster with a null ID
   --       because it avoids a history search for duplicate IDs
   --
   -- Insert a card_types ACTIVE View Record
   -- NOTE: If UPD_VALS_IN is set to FALSE, the function will run faster,
   --       but the returned record may contain invalid data
   procedure ins
      (new_rec  in out nocopy  card_types_act%ROWTYPE
      ,upd_vals_in  in  boolean default TRUE
      );
   -- This function traps and returns any error message from the ins procedure
   function ins
      (new_rec  in out nocopy  card_types_act%ROWTYPE
      ,upd_vals_in  in  boolean default TRUE
      ) return varchar2;
   -- Insert a card_types Table Record
   --  (Fastest insert procedure and returned data is always valid)
   procedure ins
      (new_tab  in out nocopy  card_types%ROWTYPE
      );
   -- This function traps and returns any error message from the ins procedure
   function ins
      (new_tab  in out nocopy  card_types%ROWTYPE
      ) return varchar2;
   -- Insert columns for card_types ACTIVE View
   --   without returning updated data in each column
   procedure ins
      (id_in  in  NUMBER default null
      ,user_id_in  in  NUMBER default null
      ,users_nk1_in  in  VARCHAR2 default null
      ,name_in  in  VARCHAR2 default null
      ,sort_ord_in  in  NUMBER default null
      );
   -- This function traps and returns any error message from the ins procedure
   function ins
      (id_in  in  NUMBER default null
      ,user_id_in  in  NUMBER default null
      ,users_nk1_in  in  VARCHAR2 default null
      ,name_in  in  VARCHAR2 default null
      ,sort_ord_in  in  NUMBER default null
      ) return varchar2;
   -- Insert columns for card_types ACTIVE View
   --   with updated data returned in each column
   procedure ins2
      (id_io  in out nocopy  NUMBER
      ,user_id_io  in out nocopy  NUMBER
      ,users_nk1_io  in out nocopy  VARCHAR2
      ,name_io  in out nocopy  VARCHAR2
      ,sort_ord_io  in out nocopy  NUMBER
      );
   -- This function traps and returns any error message from the ins2 procedure
   function ins2
      (id_io  in out nocopy  NUMBER
      ,user_id_io  in out nocopy  NUMBER
      ,users_nk1_io  in out nocopy  VARCHAR2
      ,name_io  in out nocopy  VARCHAR2
      ,sort_ord_io  in out nocopy  NUMBER
      ) return varchar2;
   -- Insert columns for card_types Table
   --   with updated data returned in each column
   procedure ins2
      (id_io  in out nocopy  NUMBER
      ,user_id_io  in out nocopy  NUMBER
      ,name_io  in out nocopy  VARCHAR2
      ,sort_ord_io  in out nocopy  NUMBER
      );
   -- This function traps and returns any error message from the ins2 procedure
   function ins2
      (id_io  in out nocopy  NUMBER
      ,user_id_io  in out nocopy  NUMBER
      ,name_io  in out nocopy  VARCHAR2
      ,sort_ord_io  in out nocopy  NUMBER
      ) return varchar2;

   -- Special Use Update for Specific Column Updates.
   --   Only differences between old and new data will be updated.
   --   Set upd_val_in TRUE to get updated data in new_rec
   procedure upd
      (old_rec  in  card_types_act%ROWTYPE
      ,new_rec  in out nocopy  card_types_act%ROWTYPE
      ,upd_vals_in  in  boolean default FALSE
      );
   -- This function traps and returns any error message from the upd procedure
   function upd
      (old_rec  in  card_types_act%ROWTYPE
      ,new_rec  in out nocopy  card_types_act%ROWTYPE
      ,upd_vals_in  in  boolean default FALSE
      ) return varchar2;
   -- Special Use Update for Specific Column Updates.
   --   Only differences between old and new data will be updated.
   --   Set upd_val_in TRUE to get updated data in new_rec
   procedure upd
      (old_tab  in  card_types%ROWTYPE
      ,new_tab  in out nocopy  card_types%ROWTYPE
      );
   -- This function traps and returns any error message from the upd procedure
   function upd
      (old_tab  in  card_types%ROWTYPE
      ,new_tab  in out nocopy  card_types%ROWTYPE
      ) return varchar2;
   -- Update a card_types ACTIVE View Record
   -- NOTE: If UPD_VALS_IN is set to FALSE, the returned record
   --       may contain invalid data
   -- NOTE: Only FK NKs that are part of this NK will be used to find
   --       this ID from its NKs (FK IDs will be ignored)
   procedure upd
      (new_rec  in out nocopy  card_types_act%ROWTYPE
      ,upd_vals_in  in  boolean default TRUE
      );
   -- This function traps and returns any error message from the upd procedure
   function upd
      (new_rec  in out nocopy  card_types_act%ROWTYPE
      ,upd_vals_in  in  boolean default TRUE
      ) return varchar2;
   -- Update a card_types Table Record
   --  (Fastest update procedure and returned data is always valid)
   -- NOTE: card_typesID must be supplied (NK lookup will not be performed)
   procedure upd
      (new_tab  in out nocopy  card_types%ROWTYPE
      );
   -- This function traps and returns any error message from the upd procedure
   function upd
      (new_tab  in out nocopy  card_types%ROWTYPE
      ) return varchar2;
   -- Update columns for card_types ACTIVE View
   --   without returning updated data in each column
   procedure upd
      (id_in  in  NUMBER default null
      ,user_id_in  in  NUMBER default null
      ,users_nk1_in  in  VARCHAR2 default null
      ,name_in  in  VARCHAR2 default null
      ,sort_ord_in  in  NUMBER default null
      );
   -- This function traps and returns any error message from the upd procedure
   function upd
      (id_in  in  NUMBER default null
      ,user_id_in  in  NUMBER default null
      ,users_nk1_in  in  VARCHAR2 default null
      ,name_in  in  VARCHAR2 default null
      ,sort_ord_in  in  NUMBER default null
      ) return varchar2;
   -- Update columns for card_types ACTIVE View
   --   with updated data returned in each column
   procedure upd2
      (id_io  in out nocopy  NUMBER
      ,user_id_io  in out nocopy  NUMBER
      ,users_nk1_io  in out nocopy  VARCHAR2
      ,name_io  in out nocopy  VARCHAR2
      ,sort_ord_io  in out nocopy  NUMBER
      );
   -- This function traps and returns any error message from the upd2 procedure
   function upd2
      (id_io  in out nocopy  NUMBER
      ,user_id_io  in out nocopy  NUMBER
      ,users_nk1_io  in out nocopy  VARCHAR2
      ,name_io  in out nocopy  VARCHAR2
      ,sort_ord_io  in out nocopy  NUMBER
      ) return varchar2;
   -- Update columns for card_types Table
   --   with updated data returned in each column
   procedure upd2
      (id_io  in out nocopy  NUMBER
      ,user_id_io  in out nocopy  NUMBER
      ,name_io  in out nocopy  VARCHAR2
      ,sort_ord_io  in out nocopy  NUMBER
      );
   -- This function traps and returns any error message from the upd2 procedure
   function upd2
      (id_io  in out nocopy  NUMBER
      ,user_id_io  in out nocopy  NUMBER
      ,name_io  in out nocopy  VARCHAR2
      ,sort_ord_io  in out nocopy  NUMBER
      ) return varchar2;

   -- Application Delete procedure without updated parameters
   procedure del
      (id_in  in  NUMBER default null
      ,user_id_in  in  NUMBER default null
      ,users_nk1_in  in  VARCHAR2 default null
      ,name_in  in  VARCHAR2 default null
      );
   -- This function traps and returns any error message from the del procedure
   function del
      (id_in  in  NUMBER default null
      ,user_id_in  in  NUMBER default null
      ,users_nk1_in  in  VARCHAR2 default null
      ,name_in  in  VARCHAR2 default null
      ) return varchar2;
   -- Application Delete procedure with updated parameters
   procedure del2
      (id_io  in out nocopy  NUMBER
      ,user_id_in  in NUMBER default null
      ,users_nk1_in  in VARCHAR2 default null
      ,name_in  in VARCHAR2 default null
      );
   -- This function traps and returns any error message from the del2 procedure
   function del2
      (id_io  in out nocopy  NUMBER
      ,user_id_in  in NUMBER default null
      ,users_nk1_in  in VARCHAR2 default null
      ,name_in  in VARCHAR2 default null
      ) return varchar2;

   -- Special Data Warehouse Dimension Function
   --   Attempts to find matching record based on natural keys
   --   If found, performs updates on non-NK columns that changed
   --   If not found, inserts new record
   --   Returns ID of record
   procedure load_dim
      (dim_tab  in out nocopy  card_types%ROWTYPE
      );
   -- This function traps and returns any error message from the load_dim procedure
   function load_dim
      (dim_tab  in out nocopy  card_types%ROWTYPE
      ) return varchar2;

end card_types_dml;
/
select 'CARD_TYPES_DML' as "Package:"
 from  user_errors
 where name  = 'CARD_TYPES_DML'
  and  type  = 'PACKAGE'
  and  rownum = 1
/
select '('||line||'/'||position||') '||text as error
 from  user_errors
 where name = 'CARD_TYPES_DML'
  and  type = 'PACKAGE'
 order by sequence
/

create package body card_types_dml
is

 -- Package Body Card_Types_Dml
 -- (Data Manipulation Language, Foreign Key and Path Lookup)

   -- Application: Clue Notes For Oracle
   -- Generated by DTGen (http://dmstex.com/services/dtgen)
   -- December  16, 2013  11:32:31 AM

   --
   --
   -- © Duane.Dieterich@DMSTEX.com 2013
   --
   -- All Rights Reserved
   --
   -- No part of this software may be reproduced, copied, modified or adapted,
   -- without the prior written consent of the author, unless otherwise
   -- indicated for stand-alone materials.
   --
   -- You may quote extracts from this software with attribution to
   -- Duane.Dieterich@DMSTEX.com
   --
   -- For any other mode of sharing, please contact Duane.Dieterich@DMSTEX.com.
   --
   -- Commercial use and distribution of this software is not allowed without
   -- express and prior written consent of the author.
   --
   -- THE SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
   -- INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY
   -- AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL
   -- THE COPYRIGHT HOLDER OR DMSTEX BUSINESS SOLUTIONS LLC, ITS MEMBERS,
   -- MANAGERS, OR EMPLOYEES BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
   -- SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
   -- TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
   -- PROFITS; CORRUPTION OF DATA, OR BUSINESS INTERRUPTION) HOWEVER CAUSED
   -- AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
   -- OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF
   -- THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH
   -- DAMAGE.
   --
   --


----------------------------------------
function get_next_id
      return NUMBER
is
   retid  NUMBER;
begin
   select card_types_seq.nextval
    into  retid from dual;
   return retid;
end get_next_id;
----------------------------------------
function get_curr_id
      return NUMBER
is
   retid  NUMBER;
begin
   select card_types_seq.currval
    into  retid from dual;
   return retid;
end get_curr_id;
----------------------------------------
function get_id
      (users_nk1  in  VARCHAR2
      ,name  in  VARCHAR2
      ) return number
   -- For all the Natural Key Columns, Return an ID
is
begin
   return card_types_tab.get_id
      (users_nk1
      ,name
      );
end get_id;
----------------------------------------
-- For all the Natural Key Column IDs, Return an ID
function get_id2
      (user_id_in  in  NUMBER
      ,name_in  in  VARCHAR2
      ) return NUMBER
is
   retid  NUMBER(38);
begin
   select id
    into  retid
    from  card_types  CTYPE
    where user_id_in = CTYPE.user_id
     and  name_in = CTYPE.name
    ;
   return retid;
exception when no_data_found then return null;
end get_id2;
----------------------------------------
function get_nk
      (id_in  in  NUMBER)
   return VARCHAR2
   -- For an ID, return a delimited list of Natural Key Values
is
begin
   return card_types_tab.get_nk(id_in);
end get_nk;
----------------------------------------
procedure clear
      (n_rec  in out nocopy  card_types_act%ROWTYPE
      )
is
begin
   n_rec.id := null;
   n_rec.user_id := null;
   n_rec.users_nk1 := null;
   n_rec.name := null;
   n_rec.sort_ord := null;
end clear;
----------
function clear
      (n_rec  in out nocopy  card_types_act%ROWTYPE
      ) return varchar2
is
begin
   clear(n_rec);
   return '';
exception when others then return sqlerrm;
end clear;
----------------------------------------
procedure clear
      (n_tab  in out nocopy  card_types%ROWTYPE
      )
is
begin
   n_tab.id := null;
   n_tab.user_id := null;
   n_tab.name := null;
   n_tab.sort_ord := null;
end clear;
----------
function clear
      (n_tab  in out nocopy  card_types%ROWTYPE
      ) return varchar2
is
begin
   clear(n_tab);
   return '';
exception when others then return sqlerrm;
end clear;
----------------------------------------
procedure get_rec_by_id
      (n_rec  in out nocopy  card_types_act%ROWTYPE
      )
is
   start_tstamp  timestamp := systimestamp;
begin
   if n_rec.id is null then
      clear(n_rec);
   else
      select * into n_rec from card_types_act
       where id = n_rec.id;
   end if;
   return;
   util.trc_time_interval('card_types_dml.get_rec_by_id(act rec) ID:' || n_rec.id, start_tstamp);
end get_rec_by_id;
----------
function get_rec_by_id
      (n_rec  in out nocopy  card_types_act%ROWTYPE
      ) return varchar2
is
begin
   get_rec_by_id(n_rec);
   return '';
exception when others then return sqlerrm;
end get_rec_by_id;
----------------------------------------
procedure get_rec_by_id
      (n_tab  in out nocopy  card_types%ROWTYPE
      )
is
   start_tstamp  timestamp := systimestamp;
begin
   if n_tab.id is null then
      clear(n_tab);
   else
      select * into n_tab from card_types
       where id = n_tab.id;
   end if;
   return;
   util.trc_time_interval('card_types_dml.get_rec_by_id(tab rec) ID:' || n_tab.id, start_tstamp);
end get_rec_by_id;
----------
function get_rec_by_id
      (n_tab  in out nocopy  card_types%ROWTYPE
      ) return varchar2
is
begin
   get_rec_by_id(n_tab);
   return '';
exception when others then return sqlerrm;
end get_rec_by_id;
----------------------------------------
-- Insert a card_types ACTIVE View Record
procedure ins
      (new_rec  in out nocopy  card_types_act%ROWTYPE
      ,upd_vals_in  in  boolean default TRUE
      )
is
   new_tab  card_types%ROWTYPE;
   start_tstamp  timestamp := systimestamp;
begin
   -- Set new_rec.user_id, if needed
   if new_rec.user_id is null then
      if    new_rec.users_nk1 is not null
      then
         new_rec.user_id := users_tab.get_id
            (new_rec.users_nk1
            );
         if new_rec.user_id is null then
            raise_application_error(-20020, 'Null ID was returned from users_tab.get_id');
         end if;
      end if;
   end if;
   new_tab.id := new_rec.id;
   new_tab.user_id := new_rec.user_id;
   new_tab.name := new_rec.name;
   new_tab.sort_ord := new_rec.sort_ord;
   card_types_tab.ins(new_tab);
   if upd_vals_in then
      -- card_types_tab.ins returns a new ID, if needed
      select * into new_rec from card_types_act
       where id = new_tab.id;
   end if;
   return;
   util.trc_time_interval('card_types_dml.ins(act rec) ID:' || new_rec.id, start_tstamp);
end ins;
----------
function ins
      (new_rec  in out nocopy  card_types_act%ROWTYPE
      ,upd_vals_in  in  boolean default TRUE
      ) return varchar2
is
begin
   ins(new_rec, upd_vals_in);
   return '';
exception when others then return sqlerrm;
end ins;
----------------------------------------
-- Insert a card_types Table Record
procedure ins
      (new_tab   in out nocopy  card_types%ROWTYPE
      )
is
   start_tstamp  timestamp := systimestamp;
begin
   card_types_tab.ins(new_tab);
   return;
   util.trc_time_interval('card_types_dml.ins(tab rec) ID:' || new_tab.id, start_tstamp);
end ins;
----------
function ins
      (new_tab   in out nocopy  card_types%ROWTYPE
      ) return varchar2
is
begin
   ins(new_tab);
   return '';
exception when others then return sqlerrm;
end ins;
----------------------------------------
-- Insert columns for card_types ACTIVE View
--   without returning updated data in each column
procedure ins
      (id_in  in  NUMBER default null
      ,user_id_in  in  NUMBER default null
      ,users_nk1_in  in  VARCHAR2 default null
      ,name_in  in  VARCHAR2 default null
      ,sort_ord_in  in  NUMBER default null
      )
is
   new_rec  card_types_act%ROWTYPE;
   start_tstamp  timestamp := systimestamp;
begin
   new_rec.id := id_in;
   new_rec.user_id := user_id_in;
   new_rec.users_nk1 := users_nk1_in;
   new_rec.name := name_in;
   new_rec.sort_ord := sort_ord_in;
   ins(new_rec, FALSE);
   return;
   util.trc_time_interval('card_types_dml.ins(tab col) ID:' || id_in, start_tstamp);
end ins;
----------
function ins
      (id_in  in  NUMBER default null
      ,user_id_in  in  NUMBER default null
      ,users_nk1_in  in  VARCHAR2 default null
      ,name_in  in  VARCHAR2 default null
      ,sort_ord_in  in  NUMBER default null
      ) return varchar2
is
begin
   ins
      (id_in
      ,user_id_in
      ,users_nk1_in
      ,name_in
      ,sort_ord_in
      );
   return '';
exception when others then return sqlerrm;
end ins;
----------------------------------------
-- Insert columns for card_types ACTIVE View
--   with updated data returned in each column
procedure ins2
      (id_io  in out nocopy  NUMBER
      ,user_id_io  in out nocopy  NUMBER
      ,users_nk1_io  in out nocopy  VARCHAR2
      ,name_io  in out nocopy  VARCHAR2
      ,sort_ord_io  in out nocopy  NUMBER
      )
is
   new_rec  card_types_act%ROWTYPE;
   start_tstamp  timestamp := systimestamp;
begin
   new_rec.id := id_io;
   new_rec.user_id := user_id_io;
   new_rec.users_nk1 := users_nk1_io;
   new_rec.name := name_io;
   new_rec.sort_ord := sort_ord_io;
   --
   ins(new_rec);
   --
   id_io := new_rec.id;
   user_id_io := new_rec.user_id;
   users_nk1_io := new_rec.users_nk1;
   name_io := new_rec.name;
   sort_ord_io := new_rec.sort_ord;
   return;
   util.trc_time_interval('card_types_dml.ins2(tab col) ID:' || id_io, start_tstamp);
end ins2;
----------
function ins2
      (id_io  in out nocopy  NUMBER
      ,user_id_io  in out nocopy  NUMBER
      ,users_nk1_io  in out nocopy  VARCHAR2
      ,name_io  in out nocopy  VARCHAR2
      ,sort_ord_io  in out nocopy  NUMBER
      ) return varchar2
is
begin
   ins2
      (id_io
      ,user_id_io
      ,users_nk1_io
      ,name_io
      ,sort_ord_io
      );
   return '';
exception when others then return sqlerrm;
end ins2;
----------------------------------------
-- Insert columns for card_types Table
--   with updated data returned in each column
procedure ins2
      (id_io  in out nocopy  NUMBER
      ,user_id_io  in out nocopy  NUMBER
      ,name_io  in out nocopy  VARCHAR2
      ,sort_ord_io  in out nocopy  NUMBER
      )
is
   new_rec  card_types%ROWTYPE;
   start_tstamp  timestamp := systimestamp;
begin
   new_rec.id := id_io;
   new_rec.user_id := user_id_io;
   new_rec.name := name_io;
   new_rec.sort_ord := sort_ord_io;
   --
   card_types_tab.ins(new_rec);
   --
   id_io := new_rec.id;
   user_id_io := new_rec.user_id;
   name_io := new_rec.name;
   sort_ord_io := new_rec.sort_ord;
   return;
   util.trc_time_interval('card_types_dml.ins2(tab col) ID:' || id_io, start_tstamp);
end ins2;
----------
function ins2
      (id_io  in out nocopy  NUMBER
      ,user_id_io  in out nocopy  NUMBER
      ,name_io  in out nocopy  VARCHAR2
      ,sort_ord_io  in out nocopy  NUMBER
      ) return varchar2
is
begin
   ins2
      (id_io
      ,user_id_io
      ,name_io
      ,sort_ord_io
      );
   return '';
exception when others then return sqlerrm;
end ins2;
----------------------------------------
-- Special Use Update for Specific Column Updates.
--   Only differences between old and new data will be updated.
--   Set upd_val_in TRUE to get updated data in new_rec
procedure upd
      (old_rec  in  card_types_act%ROWTYPE
      ,new_rec  in out nocopy  card_types_act%ROWTYPE
      ,upd_vals_in  in  boolean default FALSE
      )
is
   old_tab  card_types%ROWTYPE;
   new_tab  card_types%ROWTYPE;
   start_tstamp  timestamp := systimestamp;
begin
   if old_rec.id is null then
      raise_application_error (-20023, 'ID is null');
   end if;
   -- Set new_rec.user_id, if needed
   if new_rec.user_id is null then
      if    new_rec.users_nk1 is not null
      then
         new_rec.user_id := users_tab.get_id
            (new_rec.users_nk1
            );
         if new_rec.user_id is null then
            raise_application_error(-20020, 'Null ID was returned from users_tab.get_id');
         end if;
      end if;
   end if;
   -- Set new_rec.user_id, if needed
   if new_rec.user_id = old_rec.user_id then
      if    not (new_rec.users_nk1 = old_rec.users_nk1)
      then
         new_rec.user_id := users_tab.get_id
            (new_rec.users_nk1
            );
         if new_rec.user_id is null then
            raise_application_error(-20020, 'Null ID was returned from users_tab.get_id');
         end if;
      end if;
   end if;
   -- Load the Table Record from the View Record
   old_tab.id := old_rec.id;
   new_tab.id := new_rec.id;
   old_tab.user_id := old_rec.user_id;
   new_tab.user_id := new_rec.user_id;
   old_tab.name := old_rec.name;
   new_tab.name := new_rec.name;
   old_tab.sort_ord := old_rec.sort_ord;
   new_tab.sort_ord := new_rec.sort_ord;
   -- Run the update
   card_types_tab.upd(old_tab, new_tab);
   if upd_vals_in then
      -- Load the View Record from the Returned (new) Table Record
      -- card_types_tab.upd should have set new ID = old ID
      select * into new_rec from card_types_act
       where id = old_tab.id;
   end if;
   return;
   util.trc_time_interval('card_types_dml.upd(trigger) ID:' || old_tab.id, start_tstamp);
end upd;
----------
function upd
      (old_rec  in  card_types_act%ROWTYPE
      ,new_rec  in out nocopy  card_types_act%ROWTYPE
      ,upd_vals_in  in  boolean default FALSE
      ) return varchar2
is
begin
   upd(old_rec, new_rec, upd_vals_in);
   return '';
exception when others then return sqlerrm;
end upd;
----------------------------------------
-- Special Use Update for Specific Column Updates.
--   Only differences between old and new data will be updated.
--   Set upd_val_in TRUE to get updated data in new_rec
procedure upd
      (old_tab  in  card_types%ROWTYPE
      ,new_tab  in out nocopy  card_types%ROWTYPE
      )
is
   start_tstamp  timestamp := systimestamp;
begin
   if old_tab.id is null then
      raise_application_error (-20023, 'ID is null');
   end if;
   -- Run the update
   card_types_tab.upd(old_tab, new_tab);
   return;
   util.trc_time_interval('card_types_dml.upd(trigger) ID:' || old_tab.id, start_tstamp);
end upd;
----------
function upd
      (old_tab  in  card_types%ROWTYPE
      ,new_tab  in out nocopy  card_types%ROWTYPE
      ) return varchar2
is
begin
   upd(old_tab, new_tab);
   return '';
exception when others then return sqlerrm;
end upd;
----------------------------------------
-- Update a card_types ACTIVE View Record
procedure upd
      (new_rec  in out nocopy  card_types_act%ROWTYPE
      ,upd_vals_in  in  boolean default TRUE
      )
is
   old_rec  card_types_act%ROWTYPE;
   start_tstamp  timestamp := systimestamp;
begin
   if new_rec.id is null then
      if    new_rec.users_nk1 is not null
        and new_rec.name is not null
      then
         new_rec.id := card_types_tab.get_id
            (new_rec.users_nk1
            ,new_rec.name
            );
      end if;
   end if;
   if new_rec.id is null then
      if    new_rec.user_id is not null
        and new_rec.name is not null
      then
         begin
            select id into new_rec.id from card_types
             where user_id = new_rec.user_id
              and  name = new_rec.name
               ;
         exception when NO_DATA_FOUND then new_rec.id := null;
         end;
      end if;
   end if;
   if new_rec.id is null then
      raise_application_error (-20023, 'ID is null and could not be found from Natural Keys');
   end if;
   select * into old_rec from card_types_act
    where id = new_rec.id;
   upd(old_rec, new_rec, upd_vals_in);
   return;
   util.trc_time_interval('card_types_dml.upd(act rec) ID:' || new_rec.id, start_tstamp);
end upd;
----------
function upd
      (new_rec  in out nocopy  card_types_act%ROWTYPE
      ,upd_vals_in  in  boolean default TRUE
      ) return varchar2
is
begin
   upd(new_rec, upd_vals_in);
   return '';
exception when others then return sqlerrm;
end upd;
----------------------------------------
-- Update a card_types Table Record
procedure upd
      (new_tab   in out nocopy  card_types%ROWTYPE
      )
is
   start_tstamp  timestamp := systimestamp;
begin
   if new_tab.id is null then
      if    new_tab.user_id is not null
        and new_tab.name is not null
      then
         begin
            select id into new_tab.id from card_types
             where user_id = new_tab.user_id
              and  name = new_tab.name
               ;
         exception when NO_DATA_FOUND then new_tab.id := null;
         end;
      end if;
   end if;
   if new_tab.id is null then
      raise_application_error (-20023, 'ID is null and could not be found from Natural Keys');
   end if;
   card_types_tab.upd(new_tab);
   return;
   util.trc_time_interval('card_types_dml.upd(tab rec) ID:' || new_tab.id, start_tstamp);
end upd;
----------
function upd
      (new_tab   in out nocopy  card_types%ROWTYPE
      ) return varchar2
is
begin
   upd(new_tab);
   return '';
exception when others then return sqlerrm;
end upd;
----------------------------------------
-- Update columns for card_types ACTIVE View
--   without returning updated data in each column
procedure upd
      (id_in  in  NUMBER default null
      ,user_id_in  in  NUMBER default null
      ,users_nk1_in  in  VARCHAR2 default null
      ,name_in  in  VARCHAR2 default null
      ,sort_ord_in  in  NUMBER default null
      )
is
   new_rec  card_types_act%ROWTYPE;
   start_tstamp  timestamp := systimestamp;
begin
   new_rec.id := id_in;
   new_rec.user_id := user_id_in;
   new_rec.users_nk1 := users_nk1_in;
   new_rec.name := name_in;
   new_rec.sort_ord := sort_ord_in;
   -- Make corrections when ID is supplied, but NK is missing
   if    new_rec.ID is not null
     and new_rec.users_nk1 is null
     and new_rec.name is null
   then
      select CTYPE.users_nk1
            ,CTYPE.name
       into  new_rec.users_nk1
            ,new_rec.name
       from  card_types_act  CTYPE
       where CTYPE.id = new_rec.ID;
   end if;
   -- Make corrections when user_id is supplied, but the Natural Key is missing
   if    new_rec.user_id is not null
     and new_rec.users_nk1 is null
   then
      select USR.name
       into  new_rec.users_nk1
       from  users_act  USR
       where USR.id = new_rec.user_id;
   end if;
   upd(new_rec, FALSE);
   return;
   util.trc_time_interval('card_types_dml.upd(act col) ID:' || id_in, start_tstamp);
end upd;
----------
function upd
      (id_in  in  NUMBER default null
      ,user_id_in  in  NUMBER default null
      ,users_nk1_in  in  VARCHAR2 default null
      ,name_in  in  VARCHAR2 default null
      ,sort_ord_in  in  NUMBER default null
      ) return varchar2
is
begin
   upd
      (id_in
      ,user_id_in
      ,users_nk1_in
      ,name_in
      ,sort_ord_in
      );
   return '';
exception when others then return sqlerrm;
end upd;
----------------------------------------
-- Update columns for card_types ACTIVE View
--   with updated data returned in each column
procedure upd2
      (id_io  in out nocopy  NUMBER
      ,user_id_io  in out nocopy  NUMBER
      ,users_nk1_io  in out nocopy  VARCHAR2
      ,name_io  in out nocopy  VARCHAR2
      ,sort_ord_io  in out nocopy  NUMBER
      )
is
   new_rec  card_types_act%ROWTYPE;
   start_tstamp  timestamp := systimestamp;
begin
   new_rec.id := id_io;
   new_rec.user_id := user_id_io;
   new_rec.users_nk1 := users_nk1_io;
   new_rec.name := name_io;
   new_rec.sort_ord := sort_ord_io;
   --
   --  upd(new_rec) will set new_rec.id as needed
   upd(new_rec);
   --
   id_io := new_rec.id;
   user_id_io := new_rec.user_id;
   users_nk1_io := new_rec.users_nk1;
   name_io := new_rec.name;
   sort_ord_io := new_rec.sort_ord;
   return;
   util.trc_time_interval('card_types_dml.upd2(act col) ID:' || id_io, start_tstamp);
end upd2;
----------
function upd2
      (id_io  in out nocopy  NUMBER
      ,user_id_io  in out nocopy  NUMBER
      ,users_nk1_io  in out nocopy  VARCHAR2
      ,name_io  in out nocopy  VARCHAR2
      ,sort_ord_io  in out nocopy  NUMBER
      ) return varchar2
is
begin
   upd2
      (id_io
      ,user_id_io
      ,users_nk1_io
      ,name_io
      ,sort_ord_io
      );
   return '';
exception when others then return sqlerrm;
end upd2;
----------------------------------------
-- Update columns for card_types Table
--   with updated data returned in each column
procedure upd2
      (id_io  in out nocopy  NUMBER
      ,user_id_io  in out nocopy  NUMBER
      ,name_io  in out nocopy  VARCHAR2
      ,sort_ord_io  in out nocopy  NUMBER
      )
is
   new_rec  card_types%ROWTYPE;
   start_tstamp  timestamp := systimestamp;
begin
   if id_io is null then
      if    user_id_io is not null
        and name_io is not null
      then
         begin
            select id into id_io from card_types
             where user_id = user_id_io
              and  name = name_io
               ;
         exception when NO_DATA_FOUND then id_io := null;
         end;
      end if;
   end if;
   if id_io is null then
      raise_application_error (-20023, 'ID is null and could not be found from Natural Keys');
   end if;
   new_rec.id := id_io;
   new_rec.user_id := user_id_io;
   new_rec.name := name_io;
   new_rec.sort_ord := sort_ord_io;
   --
   card_types_tab.upd(new_rec);
   --
   id_io := new_rec.id;
   user_id_io := new_rec.user_id;
   name_io := new_rec.name;
   sort_ord_io := new_rec.sort_ord;
   return;
   util.trc_time_interval('card_types_dml.upd2(tab col) ID:' || id_io, start_tstamp);
end upd2;
----------
function upd2
      (id_io  in out nocopy  NUMBER
      ,user_id_io  in out nocopy  NUMBER
      ,name_io  in out nocopy  VARCHAR2
      ,sort_ord_io  in out nocopy  NUMBER
      ) return varchar2
is
begin
    upd2
      (id_io
      ,user_id_io
      ,name_io
      ,sort_ord_io
      );
   return '';
exception when others then return sqlerrm;
end upd2;

----------------------------------------
-- Application Delete procedure without updated parameters
procedure del
      (id_in  in  NUMBER default null
      ,user_id_in  in  NUMBER default null
      ,users_nk1_in  in  VARCHAR2 default null
      ,name_in  in  VARCHAR2 default null
      )
is
   start_tstamp  timestamp := systimestamp;
   tmp_id  NUMBER;
begin
   tmp_id := id_in;
   if tmp_id is null then
      if    users_nk1_in is not null
        and name_in is not null
      then
         tmp_id := card_types_tab.get_id
            (users_nk1_in
            ,name_in
            );
      end if;
   end if;
   if tmp_id is null then
      if    user_id_in is not null
        and name_in is not null
      then
         begin
            select id into tmp_id from card_types
             where user_id = user_id_in
              and  name = name_in
               ;
         exception when NO_DATA_FOUND then tmp_id := null;
         end;
      end if;
   end if;
   if tmp_id is null then
      raise_application_error (-20023, 'ID is null and could not be found from Natural Keys');
   end if;
   card_types_tab.del(tmp_id);
   return;
   util.trc_time_interval('card_types_dml.del ID:' || id_in, start_tstamp);
end del;
----------
function del
      (id_in  in  NUMBER default null
      ,user_id_in  in  NUMBER default null
      ,users_nk1_in  in  VARCHAR2 default null
      ,name_in  in  VARCHAR2 default null
      ) return varchar2
is
begin
   del
      (id_in
      ,user_id_in
      ,users_nk1_in
      ,name_in
      );
   return '';
exception when others then return sqlerrm;
end del;
----------------------------------------
-- Application Delete procedure with updated parameters
procedure del2
      (id_io  in out nocopy  NUMBER
      ,user_id_in  in  NUMBER default null
      ,users_nk1_in  in  VARCHAR2 default null
      ,name_in  in  VARCHAR2 default null
      )
is
   start_tstamp  timestamp := systimestamp;
begin
   if id_io is null then
      if    users_nk1_in is not null
        and name_in is not null
      then
         id_io := card_types_tab.get_id
            (users_nk1_in
            ,name_in
            );
      end if;
   end if;
   if id_io is null then
      if    user_id_in is not null
        and name_in is not null
      then
         begin
            select id into id_io from card_types
             where user_id = user_id_in
              and  name = name_in
               ;
         exception when NO_DATA_FOUND then id_io := null;
         end;
      end if;
   end if;
   if id_io is null then
      raise_application_error (-20023, 'ID is null and could not be found from Natural Keys');
   end if;
   card_types_tab.del(id_io);
   return;
   util.trc_time_interval('card_types_dml.del2 ID:' || id_io, start_tstamp);
end del2;
----------
function del2
      (id_io  in out nocopy  NUMBER
      ,user_id_in  in  NUMBER default null
      ,users_nk1_in  in  VARCHAR2 default null
      ,name_in  in  VARCHAR2 default null
      ) return varchar2
is
begin
   del2
      (id_io
      ,user_id_in
      ,users_nk1_in
      ,name_in
      );
   return '';
exception when others then return sqlerrm;
end del2;
----------------------------------------
procedure load_dim
      (dim_tab  in out nocopy  card_types%ROWTYPE
      )
is
   -- Special Data Warehouse Dimension Function
   start_tstamp  timestamp := systimestamp;
   procedure private_upd is
      saved_inc  boolean := util.get_ignore_no_change;
   begin
      util.set_ignore_no_change(TRUE);
      upd (dim_tab);
      util.set_ignore_no_change(saved_inc);
   exception
      when others then
         util.set_ignore_no_change(saved_inc);
         raise;
   end private_upd;
begin
   -- Attempt to find matching record based on natural keys
   if dim_tab.id is null then
      begin
         select id
          into  dim_tab.id
          from  card_types
          where user_id = dim_tab.user_id
           and  user_id = dim_tab.user_id
           and  name = dim_tab.name
         ;
      exception
         when NO_DATA_FOUND then dim_tab.id := null;
      end;
   end if;
   if dim_tab.id is not null then
      -- If found, perform update on non-NK columns that changed
      private_upd;
      return;
      util.trc_time_interval('card_types_dml.load_dimE ID:' || dim_tab.id, start_tstamp);
   end if;
   -- If not found, insert new record
   begin
      ins(dim_tab);
   exception
      when DUP_VAL_ON_INDEX then
         -- Since this can run multi-threaded, another thread
         --   may have already populated this value.
         private_upd;
   end;
   return;
   util.trc_time_interval('card_types_dml.load_dim ID:' || dim_tab.id, start_tstamp);
end load_dim;
----------
function load_dim
      (dim_tab  in out nocopy  card_types%ROWTYPE
      ) return varchar2
is
begin
   load_dim(dim_tab);
   return '';
exception when others then return sqlerrm;
end load_dim;
----------------------------------------
end card_types_dml;
/
select 'CARD_TYPES_DML' as "Package Body:"
 from  user_errors
 where name  = 'CARD_TYPES_DML'
  and  type  = 'PACKAGE BODY'
  and  rownum = 1
/
select '('||line||'/'||position||') '||text as error
 from  user_errors
 where name = 'CARD_TYPES_DML'
  and  type = 'PACKAGE BODY'
 order by sequence
/

create TRIGGER card_types_act_ioi
   instead of insert on card_types_act
   for each row
declare

   -- Trigger Card_Types_Act_Ioi

   -- Application: Clue Notes For Oracle
   -- Generated by DTGen (http://dmstex.com/services/dtgen)
   -- December  16, 2013  11:32:31 AM

   --
   --
   -- © Duane.Dieterich@DMSTEX.com 2013
   --
   -- All Rights Reserved
   --
   -- No part of this software may be reproduced, copied, modified or adapted,
   -- without the prior written consent of the author, unless otherwise
   -- indicated for stand-alone materials.
   --
   -- You may quote extracts from this software with attribution to
   -- Duane.Dieterich@DMSTEX.com
   --
   -- For any other mode of sharing, please contact Duane.Dieterich@DMSTEX.com.
   --
   -- Commercial use and distribution of this software is not allowed without
   -- express and prior written consent of the author.
   --
   -- THE SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
   -- INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY
   -- AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL
   -- THE COPYRIGHT HOLDER OR DMSTEX BUSINESS SOLUTIONS LLC, ITS MEMBERS,
   -- MANAGERS, OR EMPLOYEES BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
   -- SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
   -- TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
   -- PROFITS; CORRUPTION OF DATA, OR BUSINESS INTERRUPTION) HOWEVER CAUSED
   -- AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
   -- OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF
   -- THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH
   -- DAMAGE.
   --
   --


   new_rec  card_types_act%ROWTYPE;
   start_tstamp  timestamp := systimestamp;
begin
   new_rec.id := :new.id;
   new_rec.user_id := :new.user_id;
   new_rec.users_nk1 := :new.users_nk1;
   new_rec.name := :new.name;
   new_rec.sort_ord := :new.sort_ord;
   card_types_dml.ins(new_rec, FALSE);
   util.trc_time_interval('card_types_act_ioi trigger ID:' || :new.id, start_tstamp);
end card_types_act_ioi;
/
select 'CARD_TYPES_ACT_IOI' as "Trigger:"
 from  user_errors
 where name  = 'CARD_TYPES_ACT_IOI'
  and  type  = 'TRIGGER'
  and  rownum = 1
/
select '('||line||'/'||position||') '||text as error
 from  user_errors
 where name = 'CARD_TYPES_ACT_IOI'
  and  type = 'TRIGGER'
 order by sequence
/

create TRIGGER card_types_act_iou
   instead of update on card_types_act
   for each row
declare

   -- Trigger Card_Types_Act_Iou

   -- Application: Clue Notes For Oracle
   -- Generated by DTGen (http://dmstex.com/services/dtgen)
   -- December  16, 2013  11:32:31 AM

   --
   --
   -- © Duane.Dieterich@DMSTEX.com 2013
   --
   -- All Rights Reserved
   --
   -- No part of this software may be reproduced, copied, modified or adapted,
   -- without the prior written consent of the author, unless otherwise
   -- indicated for stand-alone materials.
   --
   -- You may quote extracts from this software with attribution to
   -- Duane.Dieterich@DMSTEX.com
   --
   -- For any other mode of sharing, please contact Duane.Dieterich@DMSTEX.com.
   --
   -- Commercial use and distribution of this software is not allowed without
   -- express and prior written consent of the author.
   --
   -- THE SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
   -- INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY
   -- AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL
   -- THE COPYRIGHT HOLDER OR DMSTEX BUSINESS SOLUTIONS LLC, ITS MEMBERS,
   -- MANAGERS, OR EMPLOYEES BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
   -- SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
   -- TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
   -- PROFITS; CORRUPTION OF DATA, OR BUSINESS INTERRUPTION) HOWEVER CAUSED
   -- AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
   -- OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF
   -- THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH
   -- DAMAGE.
   --
   --


   old_rec  card_types_act%ROWTYPE;
   new_rec  card_types_act%ROWTYPE;
   start_tstamp  timestamp := systimestamp;
begin
   -- NOTE: Column Specified Update DML works without this lock
   --select btab.id into new_rec.id from card_types btab
   -- where btab.id = :old.id for update;
   old_rec.id := :old.id;
   new_rec.id := :new.id;
   old_rec.user_id := :old.user_id;
   new_rec.user_id := :new.user_id;
   old_rec.users_nk1 := :old.users_nk1;
   new_rec.users_nk1 := :new.users_nk1;
   old_rec.name := :old.name;
   new_rec.name := :new.name;
   old_rec.sort_ord := :old.sort_ord;
   new_rec.sort_ord := :new.sort_ord;
   card_types_dml.upd(old_rec, new_rec);
   util.trc_time_interval('card_types_act_iou trigger ID:' || :old.id, start_tstamp);
end card_types_act_iou;
/
select 'CARD_TYPES_ACT_IOU' as "Trigger:"
 from  user_errors
 where name  = 'CARD_TYPES_ACT_IOU'
  and  type  = 'TRIGGER'
  and  rownum = 1
/
select '('||line||'/'||position||') '||text as error
 from  user_errors
 where name = 'CARD_TYPES_ACT_IOU'
  and  type = 'TRIGGER'
 order by sequence
/

create TRIGGER card_types_act_iod
   instead of delete on card_types_act
   for each row
declare

   -- Trigger Card_Types_Act_Iod

   -- Application: Clue Notes For Oracle
   -- Generated by DTGen (http://dmstex.com/services/dtgen)
   -- December  16, 2013  11:32:31 AM

   --
   --
   -- © Duane.Dieterich@DMSTEX.com 2013
   --
   -- All Rights Reserved
   --
   -- No part of this software may be reproduced, copied, modified or adapted,
   -- without the prior written consent of the author, unless otherwise
   -- indicated for stand-alone materials.
   --
   -- You may quote extracts from this software with attribution to
   -- Duane.Dieterich@DMSTEX.com
   --
   -- For any other mode of sharing, please contact Duane.Dieterich@DMSTEX.com.
   --
   -- Commercial use and distribution of this software is not allowed without
   -- express and prior written consent of the author.
   --
   -- THE SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
   -- INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY
   -- AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL
   -- THE COPYRIGHT HOLDER OR DMSTEX BUSINESS SOLUTIONS LLC, ITS MEMBERS,
   -- MANAGERS, OR EMPLOYEES BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
   -- SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
   -- TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
   -- PROFITS; CORRUPTION OF DATA, OR BUSINESS INTERRUPTION) HOWEVER CAUSED
   -- AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
   -- OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF
   -- THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH
   -- DAMAGE.
   --
   --


   start_tstamp  timestamp := systimestamp;
begin
   card_types_tab.del(:old.id);
   util.trc_time_interval('card_types_act_iod trigger ID:' || :old.id, start_tstamp);
end card_types_act_iod;
/
select 'CARD_TYPES_ACT_IOD' as "Trigger:"
 from  user_errors
 where name  = 'CARD_TYPES_ACT_IOD'
  and  type  = 'TRIGGER'
  and  rownum = 1
/
select '('||line||'/'||position||') '||text as error
 from  user_errors
 where name = 'CARD_TYPES_ACT_IOD'
  and  type = 'TRIGGER'
 order by sequence
/


create view games_act
      (id
      ,user_id
      ,users_nk1
      ,name
      ,last_act_num
      ,completed
      ,hide_undo
      ,hide_accuse
      ,hide_missing
      ,hide_my_sugg
      ,hide_pcards
      ,hide_sugg_hist
      )
   as select
       GAM.id
      ,GAM.user_id
      ,USR.name
      ,GAM.name
      ,GAM.last_act_num
      ,GAM.completed
      ,GAM.hide_undo
      ,GAM.hide_accuse
      ,GAM.hide_missing
      ,GAM.hide_my_sugg
      ,GAM.hide_pcards
      ,GAM.hide_sugg_hist
 from             games GAM
       inner join users_act USR on USR.id = GAM.user_id
/
select 'GAMES_ACT' as "View:"
 from  user_errors
 where name  = 'GAMES_ACT'
  and  type  = 'VIEW'
  and  rownum = 1
/
select '('||line||'/'||position||') '||text as error
 from  user_errors
 where name = 'GAMES_ACT'
  and  type = 'VIEW'
 order by sequence
/

comment on table games_act is 'Individual User''s Games'
/

comment on column games_act.id is 'Surrogate Primary Key for these games'
/
comment on column games_act.user_id is 'User for this Game'
/
comment on column games_act.users_nk1 is 'USERS Natural Key 1: Clue Notes User Name'
/
comment on column games_act.name is 'User''s Game Name'
/
comment on column games_act.last_act_num is 'Number of Last Actions to Display in User''s Game'
/
comment on column games_act.completed is 'Flag indicating the Game is complete'
/
comment on column games_act.hide_undo is 'Flag indicating to hide the Accusations Report in Users'' Game'
/
comment on column games_act.hide_accuse is 'Flag indicating to hide the Accusations Report in Users'' Game'
/
comment on column games_act.hide_missing is 'Flag indicating to hide the Missing Cards Report in Users'' Game'
/
comment on column games_act.hide_my_sugg is 'Flag indicating to hide the My Suggestions Report in Users'' Game'
/
comment on column games_act.hide_pcards is 'Flag indicating to hide the Player Cards Report in Users'' Game'
/
comment on column games_act.hide_sugg_hist is 'Flag indicating to hide the Suggestion History Report in Users'' Game'
/

alter view games_act add constraint games_act_pk
   primary key (id) disable
/

alter view games_act add constraint games_act_fk1
   foreign key (user_id) references users_act (id) disable
/

CREATE type games_vobj
is
   -- Games Active View (Virtual) Record Type
object
   (id  NUMBER(38)
   ,user_id  NUMBER(38)
   ,users_nk1  VARCHAR2(320)
   ,name  VARCHAR2(320)
   ,last_act_num  NUMBER(2)
   ,completed  VARCHAR2(1)
   ,hide_undo  VARCHAR2(1)
   ,hide_accuse  VARCHAR2(1)
   ,hide_missing  VARCHAR2(1)
   ,hide_my_sugg  VARCHAR2(1)
   ,hide_pcards  VARCHAR2(1)
   ,hide_sugg_hist  VARCHAR2(1)
   )
/
select 'GAMES_VOBJ' as "Type:"
 from  user_errors
 where name  = 'GAMES_VOBJ'
  and  type  = 'TYPE'
  and  rownum = 1
/
select '('||line||'/'||position||') '||text as error
 from  user_errors
 where name = 'GAMES_VOBJ'
  and  type = 'TYPE'
 order by sequence
/

CREATE type games_vtab
is
   -- Games Active View (Virtual) Table Type
table of games_vobj
/
select 'GAMES_VTAB' as "Type:"
 from  user_errors
 where name  = 'GAMES_VTAB'
  and  type  = 'TYPE'
  and  rownum = 1
/
select '('||line||'/'||position||') '||text as error
 from  user_errors
 where name = 'GAMES_VTAB'
  and  type = 'TYPE'
 order by sequence
/

create package games_dml
is

   -- Package Games_Dml
   -- (Data Manipulation Language, Foreign Key and Path Lookup)

   -- Application: Clue Notes For Oracle
   -- Generated by DTGen (http://dmstex.com/services/dtgen)
   -- December  16, 2013  11:32:31 AM

   --
   --
   -- © Duane.Dieterich@DMSTEX.com 2013
   --
   -- All Rights Reserved
   --
   -- No part of this software may be reproduced, copied, modified or adapted,
   -- without the prior written consent of the author, unless otherwise
   -- indicated for stand-alone materials.
   --
   -- You may quote extracts from this software with attribution to
   -- Duane.Dieterich@DMSTEX.com
   --
   -- For any other mode of sharing, please contact Duane.Dieterich@DMSTEX.com.
   --
   -- Commercial use and distribution of this software is not allowed without
   -- express and prior written consent of the author.
   --
   -- THE SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
   -- INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY
   -- AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL
   -- THE COPYRIGHT HOLDER OR DMSTEX BUSINESS SOLUTIONS LLC, ITS MEMBERS,
   -- MANAGERS, OR EMPLOYEES BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
   -- SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
   -- TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
   -- PROFITS; CORRUPTION OF DATA, OR BUSINESS INTERRUPTION) HOWEVER CAUSED
   -- AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
   -- OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF
   -- THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH
   -- DAMAGE.
   --
   --


   -- Return the next Surrogate Key ID for games
   function get_next_id
      return NUMBER;
   -- Return the current Surrogate Key ID for games
   --   NOTE: This will return an ERROR if get_next_id has not been called
   function get_curr_id
      return NUMBER;

   -- Return the next Surrogate Key ID for the Natural Keys of games
   --   NOTE: The fields used in this function are the Natural Keys for games
   --         Alternatively, the Natural Key IDs for games are:
   --            -) user_id
   --            -) name
   function get_id
      (users_nk1  in  VARCHAR2
      ,name  in  VARCHAR2
      ) return NUMBER;
   -- For all the Natural Key Column IDs, Return an ID
   function get_id2
      (user_id_in  in  NUMBER
      ,name_in  in  VARCHAR2
      ) return NUMBER;
   -- Return a concatenated string of Natural Keys for a games id
   function get_nk
      (id_in  in  NUMBER
      ) return VARCHAR2;

   -- Set a "view" record to null
   procedure clear
      (n_rec  in out nocopy  games_ACT%ROWTYPE
      );
   -- This function traps and returns any error message from the clear procedure
   function clear
      (n_rec  in out nocopy  games_ACT%ROWTYPE
      ) return varchar2;
   -- Set a "table" record to null
   procedure clear
      (n_tab  in out nocopy  games%ROWTYPE
      );
   -- This function traps and returns any error message from the clear procedure
   function clear
      (n_tab  in out nocopy  games%ROWTYPE
      ) return varchar2;

   -- Set a "view" record from a games ID
   procedure get_rec_by_id
      (n_rec  in out nocopy  games_ACT%ROWTYPE
      );
   -- This function traps and returns any error message from the get_rec_by_id procedure
   function get_rec_by_id
      (n_rec  in out nocopy  games_ACT%ROWTYPE
      ) return varchar2;
   -- Set a "table" record from a games ID
   procedure get_rec_by_id
      (n_tab  in out nocopy  games%ROWTYPE
      );
   -- This function traps and returns any error message from the get_rec_by_id procedure
   function get_rec_by_id
      (n_tab  in out nocopy  games%ROWTYPE
      ) return varchar2;

   -- NOTE: All INS procedures will run faster with a null ID
   --       because it avoids a history search for duplicate IDs
   --
   -- Insert a games ACTIVE View Record
   -- NOTE: If UPD_VALS_IN is set to FALSE, the function will run faster,
   --       but the returned record may contain invalid data
   procedure ins
      (new_rec  in out nocopy  games_act%ROWTYPE
      ,upd_vals_in  in  boolean default TRUE
      );
   -- This function traps and returns any error message from the ins procedure
   function ins
      (new_rec  in out nocopy  games_act%ROWTYPE
      ,upd_vals_in  in  boolean default TRUE
      ) return varchar2;
   -- Insert a games Table Record
   --  (Fastest insert procedure and returned data is always valid)
   procedure ins
      (new_tab  in out nocopy  games%ROWTYPE
      );
   -- This function traps and returns any error message from the ins procedure
   function ins
      (new_tab  in out nocopy  games%ROWTYPE
      ) return varchar2;
   -- Insert columns for games ACTIVE View
   --   without returning updated data in each column
   procedure ins
      (id_in  in  NUMBER default null
      ,user_id_in  in  NUMBER default null
      ,users_nk1_in  in  VARCHAR2 default null
      ,name_in  in  VARCHAR2 default null
      ,last_act_num_in  in  NUMBER default null
      ,completed_in  in  VARCHAR2 default null
      ,hide_undo_in  in  VARCHAR2 default null
      ,hide_accuse_in  in  VARCHAR2 default null
      ,hide_missing_in  in  VARCHAR2 default null
      ,hide_my_sugg_in  in  VARCHAR2 default null
      ,hide_pcards_in  in  VARCHAR2 default null
      ,hide_sugg_hist_in  in  VARCHAR2 default null
      );
   -- This function traps and returns any error message from the ins procedure
   function ins
      (id_in  in  NUMBER default null
      ,user_id_in  in  NUMBER default null
      ,users_nk1_in  in  VARCHAR2 default null
      ,name_in  in  VARCHAR2 default null
      ,last_act_num_in  in  NUMBER default null
      ,completed_in  in  VARCHAR2 default null
      ,hide_undo_in  in  VARCHAR2 default null
      ,hide_accuse_in  in  VARCHAR2 default null
      ,hide_missing_in  in  VARCHAR2 default null
      ,hide_my_sugg_in  in  VARCHAR2 default null
      ,hide_pcards_in  in  VARCHAR2 default null
      ,hide_sugg_hist_in  in  VARCHAR2 default null
      ) return varchar2;
   -- Insert columns for games ACTIVE View
   --   with updated data returned in each column
   procedure ins2
      (id_io  in out nocopy  NUMBER
      ,user_id_io  in out nocopy  NUMBER
      ,users_nk1_io  in out nocopy  VARCHAR2
      ,name_io  in out nocopy  VARCHAR2
      ,last_act_num_io  in out nocopy  NUMBER
      ,completed_io  in out nocopy  VARCHAR2
      ,hide_undo_io  in out nocopy  VARCHAR2
      ,hide_accuse_io  in out nocopy  VARCHAR2
      ,hide_missing_io  in out nocopy  VARCHAR2
      ,hide_my_sugg_io  in out nocopy  VARCHAR2
      ,hide_pcards_io  in out nocopy  VARCHAR2
      ,hide_sugg_hist_io  in out nocopy  VARCHAR2
      );
   -- This function traps and returns any error message from the ins2 procedure
   function ins2
      (id_io  in out nocopy  NUMBER
      ,user_id_io  in out nocopy  NUMBER
      ,users_nk1_io  in out nocopy  VARCHAR2
      ,name_io  in out nocopy  VARCHAR2
      ,last_act_num_io  in out nocopy  NUMBER
      ,completed_io  in out nocopy  VARCHAR2
      ,hide_undo_io  in out nocopy  VARCHAR2
      ,hide_accuse_io  in out nocopy  VARCHAR2
      ,hide_missing_io  in out nocopy  VARCHAR2
      ,hide_my_sugg_io  in out nocopy  VARCHAR2
      ,hide_pcards_io  in out nocopy  VARCHAR2
      ,hide_sugg_hist_io  in out nocopy  VARCHAR2
      ) return varchar2;
   -- Insert columns for games Table
   --   with updated data returned in each column
   procedure ins2
      (id_io  in out nocopy  NUMBER
      ,user_id_io  in out nocopy  NUMBER
      ,name_io  in out nocopy  VARCHAR2
      ,last_act_num_io  in out nocopy  NUMBER
      ,completed_io  in out nocopy  VARCHAR2
      ,hide_undo_io  in out nocopy  VARCHAR2
      ,hide_accuse_io  in out nocopy  VARCHAR2
      ,hide_missing_io  in out nocopy  VARCHAR2
      ,hide_my_sugg_io  in out nocopy  VARCHAR2
      ,hide_pcards_io  in out nocopy  VARCHAR2
      ,hide_sugg_hist_io  in out nocopy  VARCHAR2
      );
   -- This function traps and returns any error message from the ins2 procedure
   function ins2
      (id_io  in out nocopy  NUMBER
      ,user_id_io  in out nocopy  NUMBER
      ,name_io  in out nocopy  VARCHAR2
      ,last_act_num_io  in out nocopy  NUMBER
      ,completed_io  in out nocopy  VARCHAR2
      ,hide_undo_io  in out nocopy  VARCHAR2
      ,hide_accuse_io  in out nocopy  VARCHAR2
      ,hide_missing_io  in out nocopy  VARCHAR2
      ,hide_my_sugg_io  in out nocopy  VARCHAR2
      ,hide_pcards_io  in out nocopy  VARCHAR2
      ,hide_sugg_hist_io  in out nocopy  VARCHAR2
      ) return varchar2;

   -- Special Use Update for Specific Column Updates.
   --   Only differences between old and new data will be updated.
   --   Set upd_val_in TRUE to get updated data in new_rec
   procedure upd
      (old_rec  in  games_act%ROWTYPE
      ,new_rec  in out nocopy  games_act%ROWTYPE
      ,upd_vals_in  in  boolean default FALSE
      );
   -- This function traps and returns any error message from the upd procedure
   function upd
      (old_rec  in  games_act%ROWTYPE
      ,new_rec  in out nocopy  games_act%ROWTYPE
      ,upd_vals_in  in  boolean default FALSE
      ) return varchar2;
   -- Special Use Update for Specific Column Updates.
   --   Only differences between old and new data will be updated.
   --   Set upd_val_in TRUE to get updated data in new_rec
   procedure upd
      (old_tab  in  games%ROWTYPE
      ,new_tab  in out nocopy  games%ROWTYPE
      );
   -- This function traps and returns any error message from the upd procedure
   function upd
      (old_tab  in  games%ROWTYPE
      ,new_tab  in out nocopy  games%ROWTYPE
      ) return varchar2;
   -- Update a games ACTIVE View Record
   -- NOTE: If UPD_VALS_IN is set to FALSE, the returned record
   --       may contain invalid data
   -- NOTE: Only FK NKs that are part of this NK will be used to find
   --       this ID from its NKs (FK IDs will be ignored)
   procedure upd
      (new_rec  in out nocopy  games_act%ROWTYPE
      ,upd_vals_in  in  boolean default TRUE
      );
   -- This function traps and returns any error message from the upd procedure
   function upd
      (new_rec  in out nocopy  games_act%ROWTYPE
      ,upd_vals_in  in  boolean default TRUE
      ) return varchar2;
   -- Update a games Table Record
   --  (Fastest update procedure and returned data is always valid)
   -- NOTE: gamesID must be supplied (NK lookup will not be performed)
   procedure upd
      (new_tab  in out nocopy  games%ROWTYPE
      );
   -- This function traps and returns any error message from the upd procedure
   function upd
      (new_tab  in out nocopy  games%ROWTYPE
      ) return varchar2;
   -- Update columns for games ACTIVE View
   --   without returning updated data in each column
   procedure upd
      (id_in  in  NUMBER default null
      ,user_id_in  in  NUMBER default null
      ,users_nk1_in  in  VARCHAR2 default null
      ,name_in  in  VARCHAR2 default null
      ,last_act_num_in  in  NUMBER default null
      ,completed_in  in  VARCHAR2 default null
      ,hide_undo_in  in  VARCHAR2 default null
      ,hide_accuse_in  in  VARCHAR2 default null
      ,hide_missing_in  in  VARCHAR2 default null
      ,hide_my_sugg_in  in  VARCHAR2 default null
      ,hide_pcards_in  in  VARCHAR2 default null
      ,hide_sugg_hist_in  in  VARCHAR2 default null
      );
   -- This function traps and returns any error message from the upd procedure
   function upd
      (id_in  in  NUMBER default null
      ,user_id_in  in  NUMBER default null
      ,users_nk1_in  in  VARCHAR2 default null
      ,name_in  in  VARCHAR2 default null
      ,last_act_num_in  in  NUMBER default null
      ,completed_in  in  VARCHAR2 default null
      ,hide_undo_in  in  VARCHAR2 default null
      ,hide_accuse_in  in  VARCHAR2 default null
      ,hide_missing_in  in  VARCHAR2 default null
      ,hide_my_sugg_in  in  VARCHAR2 default null
      ,hide_pcards_in  in  VARCHAR2 default null
      ,hide_sugg_hist_in  in  VARCHAR2 default null
      ) return varchar2;
   -- Update columns for games ACTIVE View
   --   with updated data returned in each column
   procedure upd2
      (id_io  in out nocopy  NUMBER
      ,user_id_io  in out nocopy  NUMBER
      ,users_nk1_io  in out nocopy  VARCHAR2
      ,name_io  in out nocopy  VARCHAR2
      ,last_act_num_io  in out nocopy  NUMBER
      ,completed_io  in out nocopy  VARCHAR2
      ,hide_undo_io  in out nocopy  VARCHAR2
      ,hide_accuse_io  in out nocopy  VARCHAR2
      ,hide_missing_io  in out nocopy  VARCHAR2
      ,hide_my_sugg_io  in out nocopy  VARCHAR2
      ,hide_pcards_io  in out nocopy  VARCHAR2
      ,hide_sugg_hist_io  in out nocopy  VARCHAR2
      );
   -- This function traps and returns any error message from the upd2 procedure
   function upd2
      (id_io  in out nocopy  NUMBER
      ,user_id_io  in out nocopy  NUMBER
      ,users_nk1_io  in out nocopy  VARCHAR2
      ,name_io  in out nocopy  VARCHAR2
      ,last_act_num_io  in out nocopy  NUMBER
      ,completed_io  in out nocopy  VARCHAR2
      ,hide_undo_io  in out nocopy  VARCHAR2
      ,hide_accuse_io  in out nocopy  VARCHAR2
      ,hide_missing_io  in out nocopy  VARCHAR2
      ,hide_my_sugg_io  in out nocopy  VARCHAR2
      ,hide_pcards_io  in out nocopy  VARCHAR2
      ,hide_sugg_hist_io  in out nocopy  VARCHAR2
      ) return varchar2;
   -- Update columns for games Table
   --   with updated data returned in each column
   procedure upd2
      (id_io  in out nocopy  NUMBER
      ,user_id_io  in out nocopy  NUMBER
      ,name_io  in out nocopy  VARCHAR2
      ,last_act_num_io  in out nocopy  NUMBER
      ,completed_io  in out nocopy  VARCHAR2
      ,hide_undo_io  in out nocopy  VARCHAR2
      ,hide_accuse_io  in out nocopy  VARCHAR2
      ,hide_missing_io  in out nocopy  VARCHAR2
      ,hide_my_sugg_io  in out nocopy  VARCHAR2
      ,hide_pcards_io  in out nocopy  VARCHAR2
      ,hide_sugg_hist_io  in out nocopy  VARCHAR2
      );
   -- This function traps and returns any error message from the upd2 procedure
   function upd2
      (id_io  in out nocopy  NUMBER
      ,user_id_io  in out nocopy  NUMBER
      ,name_io  in out nocopy  VARCHAR2
      ,last_act_num_io  in out nocopy  NUMBER
      ,completed_io  in out nocopy  VARCHAR2
      ,hide_undo_io  in out nocopy  VARCHAR2
      ,hide_accuse_io  in out nocopy  VARCHAR2
      ,hide_missing_io  in out nocopy  VARCHAR2
      ,hide_my_sugg_io  in out nocopy  VARCHAR2
      ,hide_pcards_io  in out nocopy  VARCHAR2
      ,hide_sugg_hist_io  in out nocopy  VARCHAR2
      ) return varchar2;

   -- Application Delete procedure without updated parameters
   procedure del
      (id_in  in  NUMBER default null
      ,user_id_in  in  NUMBER default null
      ,users_nk1_in  in  VARCHAR2 default null
      ,name_in  in  VARCHAR2 default null
      );
   -- This function traps and returns any error message from the del procedure
   function del
      (id_in  in  NUMBER default null
      ,user_id_in  in  NUMBER default null
      ,users_nk1_in  in  VARCHAR2 default null
      ,name_in  in  VARCHAR2 default null
      ) return varchar2;
   -- Application Delete procedure with updated parameters
   procedure del2
      (id_io  in out nocopy  NUMBER
      ,user_id_in  in NUMBER default null
      ,users_nk1_in  in VARCHAR2 default null
      ,name_in  in VARCHAR2 default null
      );
   -- This function traps and returns any error message from the del2 procedure
   function del2
      (id_io  in out nocopy  NUMBER
      ,user_id_in  in NUMBER default null
      ,users_nk1_in  in VARCHAR2 default null
      ,name_in  in VARCHAR2 default null
      ) return varchar2;

   -- Special Data Warehouse Dimension Function
   --   Attempts to find matching record based on natural keys
   --   If found, performs updates on non-NK columns that changed
   --   If not found, inserts new record
   --   Returns ID of record
   procedure load_dim
      (dim_tab  in out nocopy  games%ROWTYPE
      );
   -- This function traps and returns any error message from the load_dim procedure
   function load_dim
      (dim_tab  in out nocopy  games%ROWTYPE
      ) return varchar2;

end games_dml;
/
select 'GAMES_DML' as "Package:"
 from  user_errors
 where name  = 'GAMES_DML'
  and  type  = 'PACKAGE'
  and  rownum = 1
/
select '('||line||'/'||position||') '||text as error
 from  user_errors
 where name = 'GAMES_DML'
  and  type = 'PACKAGE'
 order by sequence
/

create package body games_dml
is

 -- Package Body Games_Dml
 -- (Data Manipulation Language, Foreign Key and Path Lookup)

   -- Application: Clue Notes For Oracle
   -- Generated by DTGen (http://dmstex.com/services/dtgen)
   -- December  16, 2013  11:32:31 AM

   --
   --
   -- © Duane.Dieterich@DMSTEX.com 2013
   --
   -- All Rights Reserved
   --
   -- No part of this software may be reproduced, copied, modified or adapted,
   -- without the prior written consent of the author, unless otherwise
   -- indicated for stand-alone materials.
   --
   -- You may quote extracts from this software with attribution to
   -- Duane.Dieterich@DMSTEX.com
   --
   -- For any other mode of sharing, please contact Duane.Dieterich@DMSTEX.com.
   --
   -- Commercial use and distribution of this software is not allowed without
   -- express and prior written consent of the author.
   --
   -- THE SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
   -- INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY
   -- AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL
   -- THE COPYRIGHT HOLDER OR DMSTEX BUSINESS SOLUTIONS LLC, ITS MEMBERS,
   -- MANAGERS, OR EMPLOYEES BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
   -- SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
   -- TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
   -- PROFITS; CORRUPTION OF DATA, OR BUSINESS INTERRUPTION) HOWEVER CAUSED
   -- AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
   -- OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF
   -- THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH
   -- DAMAGE.
   --
   --


----------------------------------------
function get_next_id
      return NUMBER
is
   retid  NUMBER;
begin
   select games_seq.nextval
    into  retid from dual;
   return retid;
end get_next_id;
----------------------------------------
function get_curr_id
      return NUMBER
is
   retid  NUMBER;
begin
   select games_seq.currval
    into  retid from dual;
   return retid;
end get_curr_id;
----------------------------------------
function get_id
      (users_nk1  in  VARCHAR2
      ,name  in  VARCHAR2
      ) return number
   -- For all the Natural Key Columns, Return an ID
is
begin
   return games_tab.get_id
      (users_nk1
      ,name
      );
end get_id;
----------------------------------------
-- For all the Natural Key Column IDs, Return an ID
function get_id2
      (user_id_in  in  NUMBER
      ,name_in  in  VARCHAR2
      ) return NUMBER
is
   retid  NUMBER(38);
begin
   select id
    into  retid
    from  games  GAM
    where user_id_in = GAM.user_id
     and  name_in = GAM.name
    ;
   return retid;
exception when no_data_found then return null;
end get_id2;
----------------------------------------
function get_nk
      (id_in  in  NUMBER)
   return VARCHAR2
   -- For an ID, return a delimited list of Natural Key Values
is
begin
   return games_tab.get_nk(id_in);
end get_nk;
----------------------------------------
procedure clear
      (n_rec  in out nocopy  games_act%ROWTYPE
      )
is
begin
   n_rec.id := null;
   n_rec.user_id := null;
   n_rec.users_nk1 := null;
   n_rec.name := null;
   n_rec.last_act_num := null;
   n_rec.completed := null;
   n_rec.hide_undo := null;
   n_rec.hide_accuse := null;
   n_rec.hide_missing := null;
   n_rec.hide_my_sugg := null;
   n_rec.hide_pcards := null;
   n_rec.hide_sugg_hist := null;
end clear;
----------
function clear
      (n_rec  in out nocopy  games_act%ROWTYPE
      ) return varchar2
is
begin
   clear(n_rec);
   return '';
exception when others then return sqlerrm;
end clear;
----------------------------------------
procedure clear
      (n_tab  in out nocopy  games%ROWTYPE
      )
is
begin
   n_tab.id := null;
   n_tab.user_id := null;
   n_tab.name := null;
   n_tab.last_act_num := null;
   n_tab.completed := null;
   n_tab.hide_undo := null;
   n_tab.hide_accuse := null;
   n_tab.hide_missing := null;
   n_tab.hide_my_sugg := null;
   n_tab.hide_pcards := null;
   n_tab.hide_sugg_hist := null;
end clear;
----------
function clear
      (n_tab  in out nocopy  games%ROWTYPE
      ) return varchar2
is
begin
   clear(n_tab);
   return '';
exception when others then return sqlerrm;
end clear;
----------------------------------------
procedure get_rec_by_id
      (n_rec  in out nocopy  games_act%ROWTYPE
      )
is
   start_tstamp  timestamp := systimestamp;
begin
   if n_rec.id is null then
      clear(n_rec);
   else
      select * into n_rec from games_act
       where id = n_rec.id;
   end if;
   return;
   util.trc_time_interval('games_dml.get_rec_by_id(act rec) ID:' || n_rec.id, start_tstamp);
end get_rec_by_id;
----------
function get_rec_by_id
      (n_rec  in out nocopy  games_act%ROWTYPE
      ) return varchar2
is
begin
   get_rec_by_id(n_rec);
   return '';
exception when others then return sqlerrm;
end get_rec_by_id;
----------------------------------------
procedure get_rec_by_id
      (n_tab  in out nocopy  games%ROWTYPE
      )
is
   start_tstamp  timestamp := systimestamp;
begin
   if n_tab.id is null then
      clear(n_tab);
   else
      select * into n_tab from games
       where id = n_tab.id;
   end if;
   return;
   util.trc_time_interval('games_dml.get_rec_by_id(tab rec) ID:' || n_tab.id, start_tstamp);
end get_rec_by_id;
----------
function get_rec_by_id
      (n_tab  in out nocopy  games%ROWTYPE
      ) return varchar2
is
begin
   get_rec_by_id(n_tab);
   return '';
exception when others then return sqlerrm;
end get_rec_by_id;
----------------------------------------
-- Insert a games ACTIVE View Record
procedure ins
      (new_rec  in out nocopy  games_act%ROWTYPE
      ,upd_vals_in  in  boolean default TRUE
      )
is
   new_tab  games%ROWTYPE;
   start_tstamp  timestamp := systimestamp;
begin
   -- Set new_rec.user_id, if needed
   if new_rec.user_id is null then
      if    new_rec.users_nk1 is not null
      then
         new_rec.user_id := users_tab.get_id
            (new_rec.users_nk1
            );
         if new_rec.user_id is null then
            raise_application_error(-20020, 'Null ID was returned from users_tab.get_id');
         end if;
      end if;
   end if;
   new_tab.id := new_rec.id;
   new_tab.user_id := new_rec.user_id;
   new_tab.name := new_rec.name;
   new_tab.last_act_num := new_rec.last_act_num;
   new_tab.completed := new_rec.completed;
   new_tab.hide_undo := new_rec.hide_undo;
   new_tab.hide_accuse := new_rec.hide_accuse;
   new_tab.hide_missing := new_rec.hide_missing;
   new_tab.hide_my_sugg := new_rec.hide_my_sugg;
   new_tab.hide_pcards := new_rec.hide_pcards;
   new_tab.hide_sugg_hist := new_rec.hide_sugg_hist;
   games_tab.ins(new_tab);
   if upd_vals_in then
      -- games_tab.ins returns a new ID, if needed
      select * into new_rec from games_act
       where id = new_tab.id;
   end if;
   return;
   util.trc_time_interval('games_dml.ins(act rec) ID:' || new_rec.id, start_tstamp);
end ins;
----------
function ins
      (new_rec  in out nocopy  games_act%ROWTYPE
      ,upd_vals_in  in  boolean default TRUE
      ) return varchar2
is
begin
   ins(new_rec, upd_vals_in);
   return '';
exception when others then return sqlerrm;
end ins;
----------------------------------------
-- Insert a games Table Record
procedure ins
      (new_tab   in out nocopy  games%ROWTYPE
      )
is
   start_tstamp  timestamp := systimestamp;
begin
   games_tab.ins(new_tab);
   return;
   util.trc_time_interval('games_dml.ins(tab rec) ID:' || new_tab.id, start_tstamp);
end ins;
----------
function ins
      (new_tab   in out nocopy  games%ROWTYPE
      ) return varchar2
is
begin
   ins(new_tab);
   return '';
exception when others then return sqlerrm;
end ins;
----------------------------------------
-- Insert columns for games ACTIVE View
--   without returning updated data in each column
procedure ins
      (id_in  in  NUMBER default null
      ,user_id_in  in  NUMBER default null
      ,users_nk1_in  in  VARCHAR2 default null
      ,name_in  in  VARCHAR2 default null
      ,last_act_num_in  in  NUMBER default null
      ,completed_in  in  VARCHAR2 default null
      ,hide_undo_in  in  VARCHAR2 default null
      ,hide_accuse_in  in  VARCHAR2 default null
      ,hide_missing_in  in  VARCHAR2 default null
      ,hide_my_sugg_in  in  VARCHAR2 default null
      ,hide_pcards_in  in  VARCHAR2 default null
      ,hide_sugg_hist_in  in  VARCHAR2 default null
      )
is
   new_rec  games_act%ROWTYPE;
   start_tstamp  timestamp := systimestamp;
begin
   new_rec.id := id_in;
   new_rec.user_id := user_id_in;
   new_rec.users_nk1 := users_nk1_in;
   new_rec.name := name_in;
   new_rec.last_act_num := last_act_num_in;
   new_rec.completed := completed_in;
   new_rec.hide_undo := hide_undo_in;
   new_rec.hide_accuse := hide_accuse_in;
   new_rec.hide_missing := hide_missing_in;
   new_rec.hide_my_sugg := hide_my_sugg_in;
   new_rec.hide_pcards := hide_pcards_in;
   new_rec.hide_sugg_hist := hide_sugg_hist_in;
   ins(new_rec, FALSE);
   return;
   util.trc_time_interval('games_dml.ins(tab col) ID:' || id_in, start_tstamp);
end ins;
----------
function ins
      (id_in  in  NUMBER default null
      ,user_id_in  in  NUMBER default null
      ,users_nk1_in  in  VARCHAR2 default null
      ,name_in  in  VARCHAR2 default null
      ,last_act_num_in  in  NUMBER default null
      ,completed_in  in  VARCHAR2 default null
      ,hide_undo_in  in  VARCHAR2 default null
      ,hide_accuse_in  in  VARCHAR2 default null
      ,hide_missing_in  in  VARCHAR2 default null
      ,hide_my_sugg_in  in  VARCHAR2 default null
      ,hide_pcards_in  in  VARCHAR2 default null
      ,hide_sugg_hist_in  in  VARCHAR2 default null
      ) return varchar2
is
begin
   ins
      (id_in
      ,user_id_in
      ,users_nk1_in
      ,name_in
      ,last_act_num_in
      ,completed_in
      ,hide_undo_in
      ,hide_accuse_in
      ,hide_missing_in
      ,hide_my_sugg_in
      ,hide_pcards_in
      ,hide_sugg_hist_in
      );
   return '';
exception when others then return sqlerrm;
end ins;
----------------------------------------
-- Insert columns for games ACTIVE View
--   with updated data returned in each column
procedure ins2
      (id_io  in out nocopy  NUMBER
      ,user_id_io  in out nocopy  NUMBER
      ,users_nk1_io  in out nocopy  VARCHAR2
      ,name_io  in out nocopy  VARCHAR2
      ,last_act_num_io  in out nocopy  NUMBER
      ,completed_io  in out nocopy  VARCHAR2
      ,hide_undo_io  in out nocopy  VARCHAR2
      ,hide_accuse_io  in out nocopy  VARCHAR2
      ,hide_missing_io  in out nocopy  VARCHAR2
      ,hide_my_sugg_io  in out nocopy  VARCHAR2
      ,hide_pcards_io  in out nocopy  VARCHAR2
      ,hide_sugg_hist_io  in out nocopy  VARCHAR2
      )
is
   new_rec  games_act%ROWTYPE;
   start_tstamp  timestamp := systimestamp;
begin
   new_rec.id := id_io;
   new_rec.user_id := user_id_io;
   new_rec.users_nk1 := users_nk1_io;
   new_rec.name := name_io;
   new_rec.last_act_num := last_act_num_io;
   new_rec.completed := completed_io;
   new_rec.hide_undo := hide_undo_io;
   new_rec.hide_accuse := hide_accuse_io;
   new_rec.hide_missing := hide_missing_io;
   new_rec.hide_my_sugg := hide_my_sugg_io;
   new_rec.hide_pcards := hide_pcards_io;
   new_rec.hide_sugg_hist := hide_sugg_hist_io;
   --
   ins(new_rec);
   --
   id_io := new_rec.id;
   user_id_io := new_rec.user_id;
   users_nk1_io := new_rec.users_nk1;
   name_io := new_rec.name;
   last_act_num_io := new_rec.last_act_num;
   completed_io := new_rec.completed;
   hide_undo_io := new_rec.hide_undo;
   hide_accuse_io := new_rec.hide_accuse;
   hide_missing_io := new_rec.hide_missing;
   hide_my_sugg_io := new_rec.hide_my_sugg;
   hide_pcards_io := new_rec.hide_pcards;
   hide_sugg_hist_io := new_rec.hide_sugg_hist;
   return;
   util.trc_time_interval('games_dml.ins2(tab col) ID:' || id_io, start_tstamp);
end ins2;
----------
function ins2
      (id_io  in out nocopy  NUMBER
      ,user_id_io  in out nocopy  NUMBER
      ,users_nk1_io  in out nocopy  VARCHAR2
      ,name_io  in out nocopy  VARCHAR2
      ,last_act_num_io  in out nocopy  NUMBER
      ,completed_io  in out nocopy  VARCHAR2
      ,hide_undo_io  in out nocopy  VARCHAR2
      ,hide_accuse_io  in out nocopy  VARCHAR2
      ,hide_missing_io  in out nocopy  VARCHAR2
      ,hide_my_sugg_io  in out nocopy  VARCHAR2
      ,hide_pcards_io  in out nocopy  VARCHAR2
      ,hide_sugg_hist_io  in out nocopy  VARCHAR2
      ) return varchar2
is
begin
   ins2
      (id_io
      ,user_id_io
      ,users_nk1_io
      ,name_io
      ,last_act_num_io
      ,completed_io
      ,hide_undo_io
      ,hide_accuse_io
      ,hide_missing_io
      ,hide_my_sugg_io
      ,hide_pcards_io
      ,hide_sugg_hist_io
      );
   return '';
exception when others then return sqlerrm;
end ins2;
----------------------------------------
-- Insert columns for games Table
--   with updated data returned in each column
procedure ins2
      (id_io  in out nocopy  NUMBER
      ,user_id_io  in out nocopy  NUMBER
      ,name_io  in out nocopy  VARCHAR2
      ,last_act_num_io  in out nocopy  NUMBER
      ,completed_io  in out nocopy  VARCHAR2
      ,hide_undo_io  in out nocopy  VARCHAR2
      ,hide_accuse_io  in out nocopy  VARCHAR2
      ,hide_missing_io  in out nocopy  VARCHAR2
      ,hide_my_sugg_io  in out nocopy  VARCHAR2
      ,hide_pcards_io  in out nocopy  VARCHAR2
      ,hide_sugg_hist_io  in out nocopy  VARCHAR2
      )
is
   new_rec  games%ROWTYPE;
   start_tstamp  timestamp := systimestamp;
begin
   new_rec.id := id_io;
   new_rec.user_id := user_id_io;
   new_rec.name := name_io;
   new_rec.last_act_num := last_act_num_io;
   new_rec.completed := completed_io;
   new_rec.hide_undo := hide_undo_io;
   new_rec.hide_accuse := hide_accuse_io;
   new_rec.hide_missing := hide_missing_io;
   new_rec.hide_my_sugg := hide_my_sugg_io;
   new_rec.hide_pcards := hide_pcards_io;
   new_rec.hide_sugg_hist := hide_sugg_hist_io;
   --
   games_tab.ins(new_rec);
   --
   id_io := new_rec.id;
   user_id_io := new_rec.user_id;
   name_io := new_rec.name;
   last_act_num_io := new_rec.last_act_num;
   completed_io := new_rec.completed;
   hide_undo_io := new_rec.hide_undo;
   hide_accuse_io := new_rec.hide_accuse;
   hide_missing_io := new_rec.hide_missing;
   hide_my_sugg_io := new_rec.hide_my_sugg;
   hide_pcards_io := new_rec.hide_pcards;
   hide_sugg_hist_io := new_rec.hide_sugg_hist;
   return;
   util.trc_time_interval('games_dml.ins2(tab col) ID:' || id_io, start_tstamp);
end ins2;
----------
function ins2
      (id_io  in out nocopy  NUMBER
      ,user_id_io  in out nocopy  NUMBER
      ,name_io  in out nocopy  VARCHAR2
      ,last_act_num_io  in out nocopy  NUMBER
      ,completed_io  in out nocopy  VARCHAR2
      ,hide_undo_io  in out nocopy  VARCHAR2
      ,hide_accuse_io  in out nocopy  VARCHAR2
      ,hide_missing_io  in out nocopy  VARCHAR2
      ,hide_my_sugg_io  in out nocopy  VARCHAR2
      ,hide_pcards_io  in out nocopy  VARCHAR2
      ,hide_sugg_hist_io  in out nocopy  VARCHAR2
      ) return varchar2
is
begin
   ins2
      (id_io
      ,user_id_io
      ,name_io
      ,last_act_num_io
      ,completed_io
      ,hide_undo_io
      ,hide_accuse_io
      ,hide_missing_io
      ,hide_my_sugg_io
      ,hide_pcards_io
      ,hide_sugg_hist_io
      );
   return '';
exception when others then return sqlerrm;
end ins2;
----------------------------------------
-- Special Use Update for Specific Column Updates.
--   Only differences between old and new data will be updated.
--   Set upd_val_in TRUE to get updated data in new_rec
procedure upd
      (old_rec  in  games_act%ROWTYPE
      ,new_rec  in out nocopy  games_act%ROWTYPE
      ,upd_vals_in  in  boolean default FALSE
      )
is
   old_tab  games%ROWTYPE;
   new_tab  games%ROWTYPE;
   start_tstamp  timestamp := systimestamp;
begin
   if old_rec.id is null then
      raise_application_error (-20023, 'ID is null');
   end if;
   -- Set new_rec.user_id, if needed
   if new_rec.user_id is null then
      if    new_rec.users_nk1 is not null
      then
         new_rec.user_id := users_tab.get_id
            (new_rec.users_nk1
            );
         if new_rec.user_id is null then
            raise_application_error(-20020, 'Null ID was returned from users_tab.get_id');
         end if;
      end if;
   end if;
   -- Set new_rec.user_id, if needed
   if new_rec.user_id = old_rec.user_id then
      if    not (new_rec.users_nk1 = old_rec.users_nk1)
      then
         new_rec.user_id := users_tab.get_id
            (new_rec.users_nk1
            );
         if new_rec.user_id is null then
            raise_application_error(-20020, 'Null ID was returned from users_tab.get_id');
         end if;
      end if;
   end if;
   -- Load the Table Record from the View Record
   old_tab.id := old_rec.id;
   new_tab.id := new_rec.id;
   old_tab.user_id := old_rec.user_id;
   new_tab.user_id := new_rec.user_id;
   old_tab.name := old_rec.name;
   new_tab.name := new_rec.name;
   old_tab.last_act_num := old_rec.last_act_num;
   new_tab.last_act_num := new_rec.last_act_num;
   old_tab.completed := old_rec.completed;
   new_tab.completed := new_rec.completed;
   old_tab.hide_undo := old_rec.hide_undo;
   new_tab.hide_undo := new_rec.hide_undo;
   old_tab.hide_accuse := old_rec.hide_accuse;
   new_tab.hide_accuse := new_rec.hide_accuse;
   old_tab.hide_missing := old_rec.hide_missing;
   new_tab.hide_missing := new_rec.hide_missing;
   old_tab.hide_my_sugg := old_rec.hide_my_sugg;
   new_tab.hide_my_sugg := new_rec.hide_my_sugg;
   old_tab.hide_pcards := old_rec.hide_pcards;
   new_tab.hide_pcards := new_rec.hide_pcards;
   old_tab.hide_sugg_hist := old_rec.hide_sugg_hist;
   new_tab.hide_sugg_hist := new_rec.hide_sugg_hist;
   -- Run the update
   games_tab.upd(old_tab, new_tab);
   if upd_vals_in then
      -- Load the View Record from the Returned (new) Table Record
      -- games_tab.upd should have set new ID = old ID
      select * into new_rec from games_act
       where id = old_tab.id;
   end if;
   return;
   util.trc_time_interval('games_dml.upd(trigger) ID:' || old_tab.id, start_tstamp);
end upd;
----------
function upd
      (old_rec  in  games_act%ROWTYPE
      ,new_rec  in out nocopy  games_act%ROWTYPE
      ,upd_vals_in  in  boolean default FALSE
      ) return varchar2
is
begin
   upd(old_rec, new_rec, upd_vals_in);
   return '';
exception when others then return sqlerrm;
end upd;
----------------------------------------
-- Special Use Update for Specific Column Updates.
--   Only differences between old and new data will be updated.
--   Set upd_val_in TRUE to get updated data in new_rec
procedure upd
      (old_tab  in  games%ROWTYPE
      ,new_tab  in out nocopy  games%ROWTYPE
      )
is
   start_tstamp  timestamp := systimestamp;
begin
   if old_tab.id is null then
      raise_application_error (-20023, 'ID is null');
   end if;
   -- Run the update
   games_tab.upd(old_tab, new_tab);
   return;
   util.trc_time_interval('games_dml.upd(trigger) ID:' || old_tab.id, start_tstamp);
end upd;
----------
function upd
      (old_tab  in  games%ROWTYPE
      ,new_tab  in out nocopy  games%ROWTYPE
      ) return varchar2
is
begin
   upd(old_tab, new_tab);
   return '';
exception when others then return sqlerrm;
end upd;
----------------------------------------
-- Update a games ACTIVE View Record
procedure upd
      (new_rec  in out nocopy  games_act%ROWTYPE
      ,upd_vals_in  in  boolean default TRUE
      )
is
   old_rec  games_act%ROWTYPE;
   start_tstamp  timestamp := systimestamp;
begin
   if new_rec.id is null then
      if    new_rec.users_nk1 is not null
        and new_rec.name is not null
      then
         new_rec.id := games_tab.get_id
            (new_rec.users_nk1
            ,new_rec.name
            );
      end if;
   end if;
   if new_rec.id is null then
      if    new_rec.user_id is not null
        and new_rec.name is not null
      then
         begin
            select id into new_rec.id from games
             where user_id = new_rec.user_id
              and  name = new_rec.name
               ;
         exception when NO_DATA_FOUND then new_rec.id := null;
         end;
      end if;
   end if;
   if new_rec.id is null then
      raise_application_error (-20023, 'ID is null and could not be found from Natural Keys');
   end if;
   select * into old_rec from games_act
    where id = new_rec.id;
   upd(old_rec, new_rec, upd_vals_in);
   return;
   util.trc_time_interval('games_dml.upd(act rec) ID:' || new_rec.id, start_tstamp);
end upd;
----------
function upd
      (new_rec  in out nocopy  games_act%ROWTYPE
      ,upd_vals_in  in  boolean default TRUE
      ) return varchar2
is
begin
   upd(new_rec, upd_vals_in);
   return '';
exception when others then return sqlerrm;
end upd;
----------------------------------------
-- Update a games Table Record
procedure upd
      (new_tab   in out nocopy  games%ROWTYPE
      )
is
   start_tstamp  timestamp := systimestamp;
begin
   if new_tab.id is null then
      if    new_tab.user_id is not null
        and new_tab.name is not null
      then
         begin
            select id into new_tab.id from games
             where user_id = new_tab.user_id
              and  name = new_tab.name
               ;
         exception when NO_DATA_FOUND then new_tab.id := null;
         end;
      end if;
   end if;
   if new_tab.id is null then
      raise_application_error (-20023, 'ID is null and could not be found from Natural Keys');
   end if;
   games_tab.upd(new_tab);
   return;
   util.trc_time_interval('games_dml.upd(tab rec) ID:' || new_tab.id, start_tstamp);
end upd;
----------
function upd
      (new_tab   in out nocopy  games%ROWTYPE
      ) return varchar2
is
begin
   upd(new_tab);
   return '';
exception when others then return sqlerrm;
end upd;
----------------------------------------
-- Update columns for games ACTIVE View
--   without returning updated data in each column
procedure upd
      (id_in  in  NUMBER default null
      ,user_id_in  in  NUMBER default null
      ,users_nk1_in  in  VARCHAR2 default null
      ,name_in  in  VARCHAR2 default null
      ,last_act_num_in  in  NUMBER default null
      ,completed_in  in  VARCHAR2 default null
      ,hide_undo_in  in  VARCHAR2 default null
      ,hide_accuse_in  in  VARCHAR2 default null
      ,hide_missing_in  in  VARCHAR2 default null
      ,hide_my_sugg_in  in  VARCHAR2 default null
      ,hide_pcards_in  in  VARCHAR2 default null
      ,hide_sugg_hist_in  in  VARCHAR2 default null
      )
is
   new_rec  games_act%ROWTYPE;
   start_tstamp  timestamp := systimestamp;
begin
   new_rec.id := id_in;
   new_rec.user_id := user_id_in;
   new_rec.users_nk1 := users_nk1_in;
   new_rec.name := name_in;
   new_rec.last_act_num := last_act_num_in;
   new_rec.completed := completed_in;
   new_rec.hide_undo := hide_undo_in;
   new_rec.hide_accuse := hide_accuse_in;
   new_rec.hide_missing := hide_missing_in;
   new_rec.hide_my_sugg := hide_my_sugg_in;
   new_rec.hide_pcards := hide_pcards_in;
   new_rec.hide_sugg_hist := hide_sugg_hist_in;
   -- Make corrections when ID is supplied, but NK is missing
   if    new_rec.ID is not null
     and new_rec.users_nk1 is null
     and new_rec.name is null
   then
      select GAM.users_nk1
            ,GAM.name
       into  new_rec.users_nk1
            ,new_rec.name
       from  games_act  GAM
       where GAM.id = new_rec.ID;
   end if;
   -- Make corrections when user_id is supplied, but the Natural Key is missing
   if    new_rec.user_id is not null
     and new_rec.users_nk1 is null
   then
      select USR.name
       into  new_rec.users_nk1
       from  users_act  USR
       where USR.id = new_rec.user_id;
   end if;
   upd(new_rec, FALSE);
   return;
   util.trc_time_interval('games_dml.upd(act col) ID:' || id_in, start_tstamp);
end upd;
----------
function upd
      (id_in  in  NUMBER default null
      ,user_id_in  in  NUMBER default null
      ,users_nk1_in  in  VARCHAR2 default null
      ,name_in  in  VARCHAR2 default null
      ,last_act_num_in  in  NUMBER default null
      ,completed_in  in  VARCHAR2 default null
      ,hide_undo_in  in  VARCHAR2 default null
      ,hide_accuse_in  in  VARCHAR2 default null
      ,hide_missing_in  in  VARCHAR2 default null
      ,hide_my_sugg_in  in  VARCHAR2 default null
      ,hide_pcards_in  in  VARCHAR2 default null
      ,hide_sugg_hist_in  in  VARCHAR2 default null
      ) return varchar2
is
begin
   upd
      (id_in
      ,user_id_in
      ,users_nk1_in
      ,name_in
      ,last_act_num_in
      ,completed_in
      ,hide_undo_in
      ,hide_accuse_in
      ,hide_missing_in
      ,hide_my_sugg_in
      ,hide_pcards_in
      ,hide_sugg_hist_in
      );
   return '';
exception when others then return sqlerrm;
end upd;
----------------------------------------
-- Update columns for games ACTIVE View
--   with updated data returned in each column
procedure upd2
      (id_io  in out nocopy  NUMBER
      ,user_id_io  in out nocopy  NUMBER
      ,users_nk1_io  in out nocopy  VARCHAR2
      ,name_io  in out nocopy  VARCHAR2
      ,last_act_num_io  in out nocopy  NUMBER
      ,completed_io  in out nocopy  VARCHAR2
      ,hide_undo_io  in out nocopy  VARCHAR2
      ,hide_accuse_io  in out nocopy  VARCHAR2
      ,hide_missing_io  in out nocopy  VARCHAR2
      ,hide_my_sugg_io  in out nocopy  VARCHAR2
      ,hide_pcards_io  in out nocopy  VARCHAR2
      ,hide_sugg_hist_io  in out nocopy  VARCHAR2
      )
is
   new_rec  games_act%ROWTYPE;
   start_tstamp  timestamp := systimestamp;
begin
   new_rec.id := id_io;
   new_rec.user_id := user_id_io;
   new_rec.users_nk1 := users_nk1_io;
   new_rec.name := name_io;
   new_rec.last_act_num := last_act_num_io;
   new_rec.completed := completed_io;
   new_rec.hide_undo := hide_undo_io;
   new_rec.hide_accuse := hide_accuse_io;
   new_rec.hide_missing := hide_missing_io;
   new_rec.hide_my_sugg := hide_my_sugg_io;
   new_rec.hide_pcards := hide_pcards_io;
   new_rec.hide_sugg_hist := hide_sugg_hist_io;
   --
   --  upd(new_rec) will set new_rec.id as needed
   upd(new_rec);
   --
   id_io := new_rec.id;
   user_id_io := new_rec.user_id;
   users_nk1_io := new_rec.users_nk1;
   name_io := new_rec.name;
   last_act_num_io := new_rec.last_act_num;
   completed_io := new_rec.completed;
   hide_undo_io := new_rec.hide_undo;
   hide_accuse_io := new_rec.hide_accuse;
   hide_missing_io := new_rec.hide_missing;
   hide_my_sugg_io := new_rec.hide_my_sugg;
   hide_pcards_io := new_rec.hide_pcards;
   hide_sugg_hist_io := new_rec.hide_sugg_hist;
   return;
   util.trc_time_interval('games_dml.upd2(act col) ID:' || id_io, start_tstamp);
end upd2;
----------
function upd2
      (id_io  in out nocopy  NUMBER
      ,user_id_io  in out nocopy  NUMBER
      ,users_nk1_io  in out nocopy  VARCHAR2
      ,name_io  in out nocopy  VARCHAR2
      ,last_act_num_io  in out nocopy  NUMBER
      ,completed_io  in out nocopy  VARCHAR2
      ,hide_undo_io  in out nocopy  VARCHAR2
      ,hide_accuse_io  in out nocopy  VARCHAR2
      ,hide_missing_io  in out nocopy  VARCHAR2
      ,hide_my_sugg_io  in out nocopy  VARCHAR2
      ,hide_pcards_io  in out nocopy  VARCHAR2
      ,hide_sugg_hist_io  in out nocopy  VARCHAR2
      ) return varchar2
is
begin
   upd2
      (id_io
      ,user_id_io
      ,users_nk1_io
      ,name_io
      ,last_act_num_io
      ,completed_io
      ,hide_undo_io
      ,hide_accuse_io
      ,hide_missing_io
      ,hide_my_sugg_io
      ,hide_pcards_io
      ,hide_sugg_hist_io
      );
   return '';
exception when others then return sqlerrm;
end upd2;
----------------------------------------
-- Update columns for games Table
--   with updated data returned in each column
procedure upd2
      (id_io  in out nocopy  NUMBER
      ,user_id_io  in out nocopy  NUMBER
      ,name_io  in out nocopy  VARCHAR2
      ,last_act_num_io  in out nocopy  NUMBER
      ,completed_io  in out nocopy  VARCHAR2
      ,hide_undo_io  in out nocopy  VARCHAR2
      ,hide_accuse_io  in out nocopy  VARCHAR2
      ,hide_missing_io  in out nocopy  VARCHAR2
      ,hide_my_sugg_io  in out nocopy  VARCHAR2
      ,hide_pcards_io  in out nocopy  VARCHAR2
      ,hide_sugg_hist_io  in out nocopy  VARCHAR2
      )
is
   new_rec  games%ROWTYPE;
   start_tstamp  timestamp := systimestamp;
begin
   if id_io is null then
      if    user_id_io is not null
        and name_io is not null
      then
         begin
            select id into id_io from games
             where user_id = user_id_io
              and  name = name_io
               ;
         exception when NO_DATA_FOUND then id_io := null;
         end;
      end if;
   end if;
   if id_io is null then
      raise_application_error (-20023, 'ID is null and could not be found from Natural Keys');
   end if;
   new_rec.id := id_io;
   new_rec.user_id := user_id_io;
   new_rec.name := name_io;
   new_rec.last_act_num := last_act_num_io;
   new_rec.completed := completed_io;
   new_rec.hide_undo := hide_undo_io;
   new_rec.hide_accuse := hide_accuse_io;
   new_rec.hide_missing := hide_missing_io;
   new_rec.hide_my_sugg := hide_my_sugg_io;
   new_rec.hide_pcards := hide_pcards_io;
   new_rec.hide_sugg_hist := hide_sugg_hist_io;
   --
   games_tab.upd(new_rec);
   --
   id_io := new_rec.id;
   user_id_io := new_rec.user_id;
   name_io := new_rec.name;
   last_act_num_io := new_rec.last_act_num;
   completed_io := new_rec.completed;
   hide_undo_io := new_rec.hide_undo;
   hide_accuse_io := new_rec.hide_accuse;
   hide_missing_io := new_rec.hide_missing;
   hide_my_sugg_io := new_rec.hide_my_sugg;
   hide_pcards_io := new_rec.hide_pcards;
   hide_sugg_hist_io := new_rec.hide_sugg_hist;
   return;
   util.trc_time_interval('games_dml.upd2(tab col) ID:' || id_io, start_tstamp);
end upd2;
----------
function upd2
      (id_io  in out nocopy  NUMBER
      ,user_id_io  in out nocopy  NUMBER
      ,name_io  in out nocopy  VARCHAR2
      ,last_act_num_io  in out nocopy  NUMBER
      ,completed_io  in out nocopy  VARCHAR2
      ,hide_undo_io  in out nocopy  VARCHAR2
      ,hide_accuse_io  in out nocopy  VARCHAR2
      ,hide_missing_io  in out nocopy  VARCHAR2
      ,hide_my_sugg_io  in out nocopy  VARCHAR2
      ,hide_pcards_io  in out nocopy  VARCHAR2
      ,hide_sugg_hist_io  in out nocopy  VARCHAR2
      ) return varchar2
is
begin
    upd2
      (id_io
      ,user_id_io
      ,name_io
      ,last_act_num_io
      ,completed_io
      ,hide_undo_io
      ,hide_accuse_io
      ,hide_missing_io
      ,hide_my_sugg_io
      ,hide_pcards_io
      ,hide_sugg_hist_io
      );
   return '';
exception when others then return sqlerrm;
end upd2;

----------------------------------------
-- Application Delete procedure without updated parameters
procedure del
      (id_in  in  NUMBER default null
      ,user_id_in  in  NUMBER default null
      ,users_nk1_in  in  VARCHAR2 default null
      ,name_in  in  VARCHAR2 default null
      )
is
   start_tstamp  timestamp := systimestamp;
   tmp_id  NUMBER;
begin
   tmp_id := id_in;
   if tmp_id is null then
      if    users_nk1_in is not null
        and name_in is not null
      then
         tmp_id := games_tab.get_id
            (users_nk1_in
            ,name_in
            );
      end if;
   end if;
   if tmp_id is null then
      if    user_id_in is not null
        and name_in is not null
      then
         begin
            select id into tmp_id from games
             where user_id = user_id_in
              and  name = name_in
               ;
         exception when NO_DATA_FOUND then tmp_id := null;
         end;
      end if;
   end if;
   if tmp_id is null then
      raise_application_error (-20023, 'ID is null and could not be found from Natural Keys');
   end if;
   games_tab.del(tmp_id);
   return;
   util.trc_time_interval('games_dml.del ID:' || id_in, start_tstamp);
end del;
----------
function del
      (id_in  in  NUMBER default null
      ,user_id_in  in  NUMBER default null
      ,users_nk1_in  in  VARCHAR2 default null
      ,name_in  in  VARCHAR2 default null
      ) return varchar2
is
begin
   del
      (id_in
      ,user_id_in
      ,users_nk1_in
      ,name_in
      );
   return '';
exception when others then return sqlerrm;
end del;
----------------------------------------
-- Application Delete procedure with updated parameters
procedure del2
      (id_io  in out nocopy  NUMBER
      ,user_id_in  in  NUMBER default null
      ,users_nk1_in  in  VARCHAR2 default null
      ,name_in  in  VARCHAR2 default null
      )
is
   start_tstamp  timestamp := systimestamp;
begin
   if id_io is null then
      if    users_nk1_in is not null
        and name_in is not null
      then
         id_io := games_tab.get_id
            (users_nk1_in
            ,name_in
            );
      end if;
   end if;
   if id_io is null then
      if    user_id_in is not null
        and name_in is not null
      then
         begin
            select id into id_io from games
             where user_id = user_id_in
              and  name = name_in
               ;
         exception when NO_DATA_FOUND then id_io := null;
         end;
      end if;
   end if;
   if id_io is null then
      raise_application_error (-20023, 'ID is null and could not be found from Natural Keys');
   end if;
   games_tab.del(id_io);
   return;
   util.trc_time_interval('games_dml.del2 ID:' || id_io, start_tstamp);
end del2;
----------
function del2
      (id_io  in out nocopy  NUMBER
      ,user_id_in  in  NUMBER default null
      ,users_nk1_in  in  VARCHAR2 default null
      ,name_in  in  VARCHAR2 default null
      ) return varchar2
is
begin
   del2
      (id_io
      ,user_id_in
      ,users_nk1_in
      ,name_in
      );
   return '';
exception when others then return sqlerrm;
end del2;
----------------------------------------
procedure load_dim
      (dim_tab  in out nocopy  games%ROWTYPE
      )
is
   -- Special Data Warehouse Dimension Function
   start_tstamp  timestamp := systimestamp;
   procedure private_upd is
      saved_inc  boolean := util.get_ignore_no_change;
   begin
      util.set_ignore_no_change(TRUE);
      upd (dim_tab);
      util.set_ignore_no_change(saved_inc);
   exception
      when others then
         util.set_ignore_no_change(saved_inc);
         raise;
   end private_upd;
begin
   -- Attempt to find matching record based on natural keys
   if dim_tab.id is null then
      begin
         select id
          into  dim_tab.id
          from  games
          where user_id = dim_tab.user_id
           and  user_id = dim_tab.user_id
           and  name = dim_tab.name
         ;
      exception
         when NO_DATA_FOUND then dim_tab.id := null;
      end;
   end if;
   if dim_tab.id is not null then
      -- If found, perform update on non-NK columns that changed
      private_upd;
      return;
      util.trc_time_interval('games_dml.load_dimE ID:' || dim_tab.id, start_tstamp);
   end if;
   -- If not found, insert new record
   begin
      ins(dim_tab);
   exception
      when DUP_VAL_ON_INDEX then
         -- Since this can run multi-threaded, another thread
         --   may have already populated this value.
         private_upd;
   end;
   return;
   util.trc_time_interval('games_dml.load_dim ID:' || dim_tab.id, start_tstamp);
end load_dim;
----------
function load_dim
      (dim_tab  in out nocopy  games%ROWTYPE
      ) return varchar2
is
begin
   load_dim(dim_tab);
   return '';
exception when others then return sqlerrm;
end load_dim;
----------------------------------------
end games_dml;
/
select 'GAMES_DML' as "Package Body:"
 from  user_errors
 where name  = 'GAMES_DML'
  and  type  = 'PACKAGE BODY'
  and  rownum = 1
/
select '('||line||'/'||position||') '||text as error
 from  user_errors
 where name = 'GAMES_DML'
  and  type = 'PACKAGE BODY'
 order by sequence
/

create TRIGGER games_act_ioi
   instead of insert on games_act
   for each row
declare

   -- Trigger Games_Act_Ioi

   -- Application: Clue Notes For Oracle
   -- Generated by DTGen (http://dmstex.com/services/dtgen)
   -- December  16, 2013  11:32:31 AM

   --
   --
   -- © Duane.Dieterich@DMSTEX.com 2013
   --
   -- All Rights Reserved
   --
   -- No part of this software may be reproduced, copied, modified or adapted,
   -- without the prior written consent of the author, unless otherwise
   -- indicated for stand-alone materials.
   --
   -- You may quote extracts from this software with attribution to
   -- Duane.Dieterich@DMSTEX.com
   --
   -- For any other mode of sharing, please contact Duane.Dieterich@DMSTEX.com.
   --
   -- Commercial use and distribution of this software is not allowed without
   -- express and prior written consent of the author.
   --
   -- THE SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
   -- INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY
   -- AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL
   -- THE COPYRIGHT HOLDER OR DMSTEX BUSINESS SOLUTIONS LLC, ITS MEMBERS,
   -- MANAGERS, OR EMPLOYEES BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
   -- SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
   -- TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
   -- PROFITS; CORRUPTION OF DATA, OR BUSINESS INTERRUPTION) HOWEVER CAUSED
   -- AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
   -- OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF
   -- THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH
   -- DAMAGE.
   --
   --


   new_rec  games_act%ROWTYPE;
   start_tstamp  timestamp := systimestamp;
begin
   new_rec.id := :new.id;
   new_rec.user_id := :new.user_id;
   new_rec.users_nk1 := :new.users_nk1;
   new_rec.name := :new.name;
   new_rec.last_act_num := :new.last_act_num;
   new_rec.completed := :new.completed;
   new_rec.hide_undo := :new.hide_undo;
   new_rec.hide_accuse := :new.hide_accuse;
   new_rec.hide_missing := :new.hide_missing;
   new_rec.hide_my_sugg := :new.hide_my_sugg;
   new_rec.hide_pcards := :new.hide_pcards;
   new_rec.hide_sugg_hist := :new.hide_sugg_hist;
   games_dml.ins(new_rec, FALSE);
   util.trc_time_interval('games_act_ioi trigger ID:' || :new.id, start_tstamp);
end games_act_ioi;
/
select 'GAMES_ACT_IOI' as "Trigger:"
 from  user_errors
 where name  = 'GAMES_ACT_IOI'
  and  type  = 'TRIGGER'
  and  rownum = 1
/
select '('||line||'/'||position||') '||text as error
 from  user_errors
 where name = 'GAMES_ACT_IOI'
  and  type = 'TRIGGER'
 order by sequence
/

create TRIGGER games_act_iou
   instead of update on games_act
   for each row
declare

   -- Trigger Games_Act_Iou

   -- Application: Clue Notes For Oracle
   -- Generated by DTGen (http://dmstex.com/services/dtgen)
   -- December  16, 2013  11:32:31 AM

   --
   --
   -- © Duane.Dieterich@DMSTEX.com 2013
   --
   -- All Rights Reserved
   --
   -- No part of this software may be reproduced, copied, modified or adapted,
   -- without the prior written consent of the author, unless otherwise
   -- indicated for stand-alone materials.
   --
   -- You may quote extracts from this software with attribution to
   -- Duane.Dieterich@DMSTEX.com
   --
   -- For any other mode of sharing, please contact Duane.Dieterich@DMSTEX.com.
   --
   -- Commercial use and distribution of this software is not allowed without
   -- express and prior written consent of the author.
   --
   -- THE SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
   -- INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY
   -- AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL
   -- THE COPYRIGHT HOLDER OR DMSTEX BUSINESS SOLUTIONS LLC, ITS MEMBERS,
   -- MANAGERS, OR EMPLOYEES BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
   -- SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
   -- TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
   -- PROFITS; CORRUPTION OF DATA, OR BUSINESS INTERRUPTION) HOWEVER CAUSED
   -- AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
   -- OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF
   -- THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH
   -- DAMAGE.
   --
   --


   old_rec  games_act%ROWTYPE;
   new_rec  games_act%ROWTYPE;
   start_tstamp  timestamp := systimestamp;
begin
   -- NOTE: Column Specified Update DML works without this lock
   --select btab.id into new_rec.id from games btab
   -- where btab.id = :old.id for update;
   old_rec.id := :old.id;
   new_rec.id := :new.id;
   old_rec.user_id := :old.user_id;
   new_rec.user_id := :new.user_id;
   old_rec.users_nk1 := :old.users_nk1;
   new_rec.users_nk1 := :new.users_nk1;
   old_rec.name := :old.name;
   new_rec.name := :new.name;
   old_rec.last_act_num := :old.last_act_num;
   new_rec.last_act_num := :new.last_act_num;
   old_rec.completed := :old.completed;
   new_rec.completed := :new.completed;
   old_rec.hide_undo := :old.hide_undo;
   new_rec.hide_undo := :new.hide_undo;
   old_rec.hide_accuse := :old.hide_accuse;
   new_rec.hide_accuse := :new.hide_accuse;
   old_rec.hide_missing := :old.hide_missing;
   new_rec.hide_missing := :new.hide_missing;
   old_rec.hide_my_sugg := :old.hide_my_sugg;
   new_rec.hide_my_sugg := :new.hide_my_sugg;
   old_rec.hide_pcards := :old.hide_pcards;
   new_rec.hide_pcards := :new.hide_pcards;
   old_rec.hide_sugg_hist := :old.hide_sugg_hist;
   new_rec.hide_sugg_hist := :new.hide_sugg_hist;
   games_dml.upd(old_rec, new_rec);
   util.trc_time_interval('games_act_iou trigger ID:' || :old.id, start_tstamp);
end games_act_iou;
/
select 'GAMES_ACT_IOU' as "Trigger:"
 from  user_errors
 where name  = 'GAMES_ACT_IOU'
  and  type  = 'TRIGGER'
  and  rownum = 1
/
select '('||line||'/'||position||') '||text as error
 from  user_errors
 where name = 'GAMES_ACT_IOU'
  and  type = 'TRIGGER'
 order by sequence
/

create TRIGGER games_act_iod
   instead of delete on games_act
   for each row
declare

   -- Trigger Games_Act_Iod

   -- Application: Clue Notes For Oracle
   -- Generated by DTGen (http://dmstex.com/services/dtgen)
   -- December  16, 2013  11:32:31 AM

   --
   --
   -- © Duane.Dieterich@DMSTEX.com 2013
   --
   -- All Rights Reserved
   --
   -- No part of this software may be reproduced, copied, modified or adapted,
   -- without the prior written consent of the author, unless otherwise
   -- indicated for stand-alone materials.
   --
   -- You may quote extracts from this software with attribution to
   -- Duane.Dieterich@DMSTEX.com
   --
   -- For any other mode of sharing, please contact Duane.Dieterich@DMSTEX.com.
   --
   -- Commercial use and distribution of this software is not allowed without
   -- express and prior written consent of the author.
   --
   -- THE SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
   -- INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY
   -- AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL
   -- THE COPYRIGHT HOLDER OR DMSTEX BUSINESS SOLUTIONS LLC, ITS MEMBERS,
   -- MANAGERS, OR EMPLOYEES BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
   -- SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
   -- TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
   -- PROFITS; CORRUPTION OF DATA, OR BUSINESS INTERRUPTION) HOWEVER CAUSED
   -- AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
   -- OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF
   -- THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH
   -- DAMAGE.
   --
   --


   start_tstamp  timestamp := systimestamp;
begin
   games_tab.del(:old.id);
   util.trc_time_interval('games_act_iod trigger ID:' || :old.id, start_tstamp);
end games_act_iod;
/
select 'GAMES_ACT_IOD' as "Trigger:"
 from  user_errors
 where name  = 'GAMES_ACT_IOD'
  and  type  = 'TRIGGER'
  and  rownum = 1
/
select '('||line||'/'||position||') '||text as error
 from  user_errors
 where name = 'GAMES_ACT_IOD'
  and  type = 'TRIGGER'
 order by sequence
/


create view players_act
      (id
      ,game_id
      ,games_nk1
      ,games_nk2
      ,name
      ,seq
      ,total_cards
      )
   as select
       PLY.id
      ,PLY.game_id
      ,GAM.users_nk1
      ,GAM.name
      ,PLY.name
      ,PLY.seq
      ,PLY.total_cards
 from             players PLY
       inner join games_act GAM on GAM.id = PLY.game_id
/
select 'PLAYERS_ACT' as "View:"
 from  user_errors
 where name  = 'PLAYERS_ACT'
  and  type  = 'VIEW'
  and  rownum = 1
/
select '('||line||'/'||position||') '||text as error
 from  user_errors
 where name = 'PLAYERS_ACT'
  and  type = 'VIEW'
 order by sequence
/

comment on table players_act is 'Players for each User''s Game'
/

comment on column players_act.id is 'Surrogate Primary Key for these players'
/
comment on column players_act.game_id is 'User''s Game for this Player'
/
comment on column players_act.games_nk1 is 'GAMES Natural Key 1: USERS NK1: Clue Notes User Name'
/
comment on column players_act.games_nk2 is 'GAMES Natural Key 2: User''s Game Name'
/
comment on column players_act.name is 'Player''s Name'
/
comment on column players_act.seq is 'Player''s Sequence from User in Game'
/
comment on column players_act.total_cards is 'Total Cards Held by Player'
/

alter view players_act add constraint players_act_pk
   primary key (id) disable
/

alter view players_act add constraint players_act_fk1
   foreign key (game_id) references games_act (id) disable
/

CREATE type players_vobj
is
   -- Players Active View (Virtual) Record Type
object
   (id  NUMBER(38)
   ,game_id  NUMBER(38)
   ,games_nk1  VARCHAR2(320)
   ,games_nk2  VARCHAR2(320)
   ,name  VARCHAR2(15)
   ,seq  NUMBER(2)
   ,total_cards  NUMBER(2)
   )
/
select 'PLAYERS_VOBJ' as "Type:"
 from  user_errors
 where name  = 'PLAYERS_VOBJ'
  and  type  = 'TYPE'
  and  rownum = 1
/
select '('||line||'/'||position||') '||text as error
 from  user_errors
 where name = 'PLAYERS_VOBJ'
  and  type = 'TYPE'
 order by sequence
/

CREATE type players_vtab
is
   -- Players Active View (Virtual) Table Type
table of players_vobj
/
select 'PLAYERS_VTAB' as "Type:"
 from  user_errors
 where name  = 'PLAYERS_VTAB'
  and  type  = 'TYPE'
  and  rownum = 1
/
select '('||line||'/'||position||') '||text as error
 from  user_errors
 where name = 'PLAYERS_VTAB'
  and  type = 'TYPE'
 order by sequence
/

create package players_dml
is

   -- Package Players_Dml
   -- (Data Manipulation Language, Foreign Key and Path Lookup)

   -- Application: Clue Notes For Oracle
   -- Generated by DTGen (http://dmstex.com/services/dtgen)
   -- December  16, 2013  11:32:31 AM

   --
   --
   -- © Duane.Dieterich@DMSTEX.com 2013
   --
   -- All Rights Reserved
   --
   -- No part of this software may be reproduced, copied, modified or adapted,
   -- without the prior written consent of the author, unless otherwise
   -- indicated for stand-alone materials.
   --
   -- You may quote extracts from this software with attribution to
   -- Duane.Dieterich@DMSTEX.com
   --
   -- For any other mode of sharing, please contact Duane.Dieterich@DMSTEX.com.
   --
   -- Commercial use and distribution of this software is not allowed without
   -- express and prior written consent of the author.
   --
   -- THE SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
   -- INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY
   -- AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL
   -- THE COPYRIGHT HOLDER OR DMSTEX BUSINESS SOLUTIONS LLC, ITS MEMBERS,
   -- MANAGERS, OR EMPLOYEES BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
   -- SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
   -- TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
   -- PROFITS; CORRUPTION OF DATA, OR BUSINESS INTERRUPTION) HOWEVER CAUSED
   -- AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
   -- OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF
   -- THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH
   -- DAMAGE.
   --
   --


   -- Return the next Surrogate Key ID for players
   function get_next_id
      return NUMBER;
   -- Return the current Surrogate Key ID for players
   --   NOTE: This will return an ERROR if get_next_id has not been called
   function get_curr_id
      return NUMBER;

   -- Return the next Surrogate Key ID for the Natural Keys of players
   --   NOTE: The fields used in this function are the Natural Keys for players
   --         Alternatively, the Natural Key IDs for players are:
   --            -) game_id
   --            -) name
   function get_id
      (games_nk1  in  VARCHAR2
      ,games_nk2  in  VARCHAR2
      ,name  in  VARCHAR2
      ) return NUMBER;
   -- For all the Natural Key Column IDs, Return an ID
   function get_id2
      (game_id_in  in  NUMBER
      ,name_in  in  VARCHAR2
      ) return NUMBER;
   -- Return a concatenated string of Natural Keys for a players id
   function get_nk
      (id_in  in  NUMBER
      ) return VARCHAR2;

   -- Set a "view" record to null
   procedure clear
      (n_rec  in out nocopy  players_ACT%ROWTYPE
      );
   -- This function traps and returns any error message from the clear procedure
   function clear
      (n_rec  in out nocopy  players_ACT%ROWTYPE
      ) return varchar2;
   -- Set a "table" record to null
   procedure clear
      (n_tab  in out nocopy  players%ROWTYPE
      );
   -- This function traps and returns any error message from the clear procedure
   function clear
      (n_tab  in out nocopy  players%ROWTYPE
      ) return varchar2;

   -- Set a "view" record from a players ID
   procedure get_rec_by_id
      (n_rec  in out nocopy  players_ACT%ROWTYPE
      );
   -- This function traps and returns any error message from the get_rec_by_id procedure
   function get_rec_by_id
      (n_rec  in out nocopy  players_ACT%ROWTYPE
      ) return varchar2;
   -- Set a "table" record from a players ID
   procedure get_rec_by_id
      (n_tab  in out nocopy  players%ROWTYPE
      );
   -- This function traps and returns any error message from the get_rec_by_id procedure
   function get_rec_by_id
      (n_tab  in out nocopy  players%ROWTYPE
      ) return varchar2;

   -- NOTE: All INS procedures will run faster with a null ID
   --       because it avoids a history search for duplicate IDs
   --
   -- Insert a players ACTIVE View Record
   -- NOTE: If UPD_VALS_IN is set to FALSE, the function will run faster,
   --       but the returned record may contain invalid data
   procedure ins
      (new_rec  in out nocopy  players_act%ROWTYPE
      ,upd_vals_in  in  boolean default TRUE
      );
   -- This function traps and returns any error message from the ins procedure
   function ins
      (new_rec  in out nocopy  players_act%ROWTYPE
      ,upd_vals_in  in  boolean default TRUE
      ) return varchar2;
   -- Insert a players Table Record
   --  (Fastest insert procedure and returned data is always valid)
   procedure ins
      (new_tab  in out nocopy  players%ROWTYPE
      );
   -- This function traps and returns any error message from the ins procedure
   function ins
      (new_tab  in out nocopy  players%ROWTYPE
      ) return varchar2;
   -- Insert columns for players ACTIVE View
   --   without returning updated data in each column
   procedure ins
      (id_in  in  NUMBER default null
      ,game_id_in  in  NUMBER default null
      ,games_nk1_in  in  VARCHAR2 default null
      ,games_nk2_in  in  VARCHAR2 default null
      ,name_in  in  VARCHAR2 default null
      ,seq_in  in  NUMBER
      ,total_cards_in  in  NUMBER default null
      );
   -- This function traps and returns any error message from the ins procedure
   function ins
      (id_in  in  NUMBER default null
      ,game_id_in  in  NUMBER default null
      ,games_nk1_in  in  VARCHAR2 default null
      ,games_nk2_in  in  VARCHAR2 default null
      ,name_in  in  VARCHAR2 default null
      ,seq_in  in  NUMBER
      ,total_cards_in  in  NUMBER default null
      ) return varchar2;
   -- Insert columns for players ACTIVE View
   --   with updated data returned in each column
   procedure ins2
      (id_io  in out nocopy  NUMBER
      ,game_id_io  in out nocopy  NUMBER
      ,games_nk1_io  in out nocopy  VARCHAR2
      ,games_nk2_io  in out nocopy  VARCHAR2
      ,name_io  in out nocopy  VARCHAR2
      ,seq_io  in out nocopy  NUMBER
      ,total_cards_io  in out nocopy  NUMBER
      );
   -- This function traps and returns any error message from the ins2 procedure
   function ins2
      (id_io  in out nocopy  NUMBER
      ,game_id_io  in out nocopy  NUMBER
      ,games_nk1_io  in out nocopy  VARCHAR2
      ,games_nk2_io  in out nocopy  VARCHAR2
      ,name_io  in out nocopy  VARCHAR2
      ,seq_io  in out nocopy  NUMBER
      ,total_cards_io  in out nocopy  NUMBER
      ) return varchar2;
   -- Insert columns for players Table
   --   with updated data returned in each column
   procedure ins2
      (id_io  in out nocopy  NUMBER
      ,game_id_io  in out nocopy  NUMBER
      ,name_io  in out nocopy  VARCHAR2
      ,seq_io  in out nocopy  NUMBER
      ,total_cards_io  in out nocopy  NUMBER
      );
   -- This function traps and returns any error message from the ins2 procedure
   function ins2
      (id_io  in out nocopy  NUMBER
      ,game_id_io  in out nocopy  NUMBER
      ,name_io  in out nocopy  VARCHAR2
      ,seq_io  in out nocopy  NUMBER
      ,total_cards_io  in out nocopy  NUMBER
      ) return varchar2;

   -- Special Use Update for Specific Column Updates.
   --   Only differences between old and new data will be updated.
   --   Set upd_val_in TRUE to get updated data in new_rec
   procedure upd
      (old_rec  in  players_act%ROWTYPE
      ,new_rec  in out nocopy  players_act%ROWTYPE
      ,upd_vals_in  in  boolean default FALSE
      );
   -- This function traps and returns any error message from the upd procedure
   function upd
      (old_rec  in  players_act%ROWTYPE
      ,new_rec  in out nocopy  players_act%ROWTYPE
      ,upd_vals_in  in  boolean default FALSE
      ) return varchar2;
   -- Special Use Update for Specific Column Updates.
   --   Only differences between old and new data will be updated.
   --   Set upd_val_in TRUE to get updated data in new_rec
   procedure upd
      (old_tab  in  players%ROWTYPE
      ,new_tab  in out nocopy  players%ROWTYPE
      );
   -- This function traps and returns any error message from the upd procedure
   function upd
      (old_tab  in  players%ROWTYPE
      ,new_tab  in out nocopy  players%ROWTYPE
      ) return varchar2;
   -- Update a players ACTIVE View Record
   -- NOTE: If UPD_VALS_IN is set to FALSE, the returned record
   --       may contain invalid data
   -- NOTE: Only FK NKs that are part of this NK will be used to find
   --       this ID from its NKs (FK IDs will be ignored)
   procedure upd
      (new_rec  in out nocopy  players_act%ROWTYPE
      ,upd_vals_in  in  boolean default TRUE
      );
   -- This function traps and returns any error message from the upd procedure
   function upd
      (new_rec  in out nocopy  players_act%ROWTYPE
      ,upd_vals_in  in  boolean default TRUE
      ) return varchar2;
   -- Update a players Table Record
   --  (Fastest update procedure and returned data is always valid)
   -- NOTE: playersID must be supplied (NK lookup will not be performed)
   procedure upd
      (new_tab  in out nocopy  players%ROWTYPE
      );
   -- This function traps and returns any error message from the upd procedure
   function upd
      (new_tab  in out nocopy  players%ROWTYPE
      ) return varchar2;
   -- Update columns for players ACTIVE View
   --   without returning updated data in each column
   procedure upd
      (id_in  in  NUMBER default null
      ,game_id_in  in  NUMBER default null
      ,games_nk1_in  in  VARCHAR2 default null
      ,games_nk2_in  in  VARCHAR2 default null
      ,name_in  in  VARCHAR2 default null
      ,seq_in  in  NUMBER
      ,total_cards_in  in  NUMBER default null
      );
   -- This function traps and returns any error message from the upd procedure
   function upd
      (id_in  in  NUMBER default null
      ,game_id_in  in  NUMBER default null
      ,games_nk1_in  in  VARCHAR2 default null
      ,games_nk2_in  in  VARCHAR2 default null
      ,name_in  in  VARCHAR2 default null
      ,seq_in  in  NUMBER
      ,total_cards_in  in  NUMBER default null
      ) return varchar2;
   -- Update columns for players ACTIVE View
   --   with updated data returned in each column
   procedure upd2
      (id_io  in out nocopy  NUMBER
      ,game_id_io  in out nocopy  NUMBER
      ,games_nk1_io  in out nocopy  VARCHAR2
      ,games_nk2_io  in out nocopy  VARCHAR2
      ,name_io  in out nocopy  VARCHAR2
      ,seq_io  in out nocopy  NUMBER
      ,total_cards_io  in out nocopy  NUMBER
      );
   -- This function traps and returns any error message from the upd2 procedure
   function upd2
      (id_io  in out nocopy  NUMBER
      ,game_id_io  in out nocopy  NUMBER
      ,games_nk1_io  in out nocopy  VARCHAR2
      ,games_nk2_io  in out nocopy  VARCHAR2
      ,name_io  in out nocopy  VARCHAR2
      ,seq_io  in out nocopy  NUMBER
      ,total_cards_io  in out nocopy  NUMBER
      ) return varchar2;
   -- Update columns for players Table
   --   with updated data returned in each column
   procedure upd2
      (id_io  in out nocopy  NUMBER
      ,game_id_io  in out nocopy  NUMBER
      ,name_io  in out nocopy  VARCHAR2
      ,seq_io  in out nocopy  NUMBER
      ,total_cards_io  in out nocopy  NUMBER
      );
   -- This function traps and returns any error message from the upd2 procedure
   function upd2
      (id_io  in out nocopy  NUMBER
      ,game_id_io  in out nocopy  NUMBER
      ,name_io  in out nocopy  VARCHAR2
      ,seq_io  in out nocopy  NUMBER
      ,total_cards_io  in out nocopy  NUMBER
      ) return varchar2;

   -- Application Delete procedure without updated parameters
   procedure del
      (id_in  in  NUMBER default null
      ,game_id_in  in  NUMBER default null
      ,games_nk1_in  in  VARCHAR2 default null
      ,games_nk2_in  in  VARCHAR2 default null
      ,name_in  in  VARCHAR2 default null
      );
   -- This function traps and returns any error message from the del procedure
   function del
      (id_in  in  NUMBER default null
      ,game_id_in  in  NUMBER default null
      ,games_nk1_in  in  VARCHAR2 default null
      ,games_nk2_in  in  VARCHAR2 default null
      ,name_in  in  VARCHAR2 default null
      ) return varchar2;
   -- Application Delete procedure with updated parameters
   procedure del2
      (id_io  in out nocopy  NUMBER
      ,game_id_in  in NUMBER default null
      ,games_nk1_in  in VARCHAR2 default null
      ,games_nk2_in  in VARCHAR2 default null
      ,name_in  in VARCHAR2 default null
      );
   -- This function traps and returns any error message from the del2 procedure
   function del2
      (id_io  in out nocopy  NUMBER
      ,game_id_in  in NUMBER default null
      ,games_nk1_in  in VARCHAR2 default null
      ,games_nk2_in  in VARCHAR2 default null
      ,name_in  in VARCHAR2 default null
      ) return varchar2;

   -- Special Data Warehouse Dimension Function
   --   Attempts to find matching record based on natural keys
   --   If found, performs updates on non-NK columns that changed
   --   If not found, inserts new record
   --   Returns ID of record
   procedure load_dim
      (dim_tab  in out nocopy  players%ROWTYPE
      );
   -- This function traps and returns any error message from the load_dim procedure
   function load_dim
      (dim_tab  in out nocopy  players%ROWTYPE
      ) return varchar2;

end players_dml;
/
select 'PLAYERS_DML' as "Package:"
 from  user_errors
 where name  = 'PLAYERS_DML'
  and  type  = 'PACKAGE'
  and  rownum = 1
/
select '('||line||'/'||position||') '||text as error
 from  user_errors
 where name = 'PLAYERS_DML'
  and  type = 'PACKAGE'
 order by sequence
/

create package body players_dml
is

 -- Package Body Players_Dml
 -- (Data Manipulation Language, Foreign Key and Path Lookup)

   -- Application: Clue Notes For Oracle
   -- Generated by DTGen (http://dmstex.com/services/dtgen)
   -- December  16, 2013  11:32:31 AM

   --
   --
   -- © Duane.Dieterich@DMSTEX.com 2013
   --
   -- All Rights Reserved
   --
   -- No part of this software may be reproduced, copied, modified or adapted,
   -- without the prior written consent of the author, unless otherwise
   -- indicated for stand-alone materials.
   --
   -- You may quote extracts from this software with attribution to
   -- Duane.Dieterich@DMSTEX.com
   --
   -- For any other mode of sharing, please contact Duane.Dieterich@DMSTEX.com.
   --
   -- Commercial use and distribution of this software is not allowed without
   -- express and prior written consent of the author.
   --
   -- THE SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
   -- INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY
   -- AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL
   -- THE COPYRIGHT HOLDER OR DMSTEX BUSINESS SOLUTIONS LLC, ITS MEMBERS,
   -- MANAGERS, OR EMPLOYEES BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
   -- SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
   -- TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
   -- PROFITS; CORRUPTION OF DATA, OR BUSINESS INTERRUPTION) HOWEVER CAUSED
   -- AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
   -- OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF
   -- THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH
   -- DAMAGE.
   --
   --


----------------------------------------
function get_next_id
      return NUMBER
is
   retid  NUMBER;
begin
   select players_seq.nextval
    into  retid from dual;
   return retid;
end get_next_id;
----------------------------------------
function get_curr_id
      return NUMBER
is
   retid  NUMBER;
begin
   select players_seq.currval
    into  retid from dual;
   return retid;
end get_curr_id;
----------------------------------------
function get_id
      (games_nk1  in  VARCHAR2
      ,games_nk2  in  VARCHAR2
      ,name  in  VARCHAR2
      ) return number
   -- For all the Natural Key Columns, Return an ID
is
begin
   return players_tab.get_id
      (games_nk1
      ,games_nk2
      ,name
      );
end get_id;
----------------------------------------
-- For all the Natural Key Column IDs, Return an ID
function get_id2
      (game_id_in  in  NUMBER
      ,name_in  in  VARCHAR2
      ) return NUMBER
is
   retid  NUMBER(38);
begin
   select id
    into  retid
    from  players  PLY
    where game_id_in = PLY.game_id
     and  name_in = PLY.name
    ;
   return retid;
exception when no_data_found then return null;
end get_id2;
----------------------------------------
function get_nk
      (id_in  in  NUMBER)
   return VARCHAR2
   -- For an ID, return a delimited list of Natural Key Values
is
begin
   return players_tab.get_nk(id_in);
end get_nk;
----------------------------------------
procedure clear
      (n_rec  in out nocopy  players_act%ROWTYPE
      )
is
begin
   n_rec.id := null;
   n_rec.game_id := null;
   n_rec.games_nk1 := null;
   n_rec.games_nk2 := null;
   n_rec.name := null;
   n_rec.seq := null;
   n_rec.total_cards := null;
end clear;
----------
function clear
      (n_rec  in out nocopy  players_act%ROWTYPE
      ) return varchar2
is
begin
   clear(n_rec);
   return '';
exception when others then return sqlerrm;
end clear;
----------------------------------------
procedure clear
      (n_tab  in out nocopy  players%ROWTYPE
      )
is
begin
   n_tab.id := null;
   n_tab.game_id := null;
   n_tab.name := null;
   n_tab.seq := null;
   n_tab.total_cards := null;
end clear;
----------
function clear
      (n_tab  in out nocopy  players%ROWTYPE
      ) return varchar2
is
begin
   clear(n_tab);
   return '';
exception when others then return sqlerrm;
end clear;
----------------------------------------
procedure get_rec_by_id
      (n_rec  in out nocopy  players_act%ROWTYPE
      )
is
   start_tstamp  timestamp := systimestamp;
begin
   if n_rec.id is null then
      clear(n_rec);
   else
      select * into n_rec from players_act
       where id = n_rec.id;
   end if;
   return;
   util.trc_time_interval('players_dml.get_rec_by_id(act rec) ID:' || n_rec.id, start_tstamp);
end get_rec_by_id;
----------
function get_rec_by_id
      (n_rec  in out nocopy  players_act%ROWTYPE
      ) return varchar2
is
begin
   get_rec_by_id(n_rec);
   return '';
exception when others then return sqlerrm;
end get_rec_by_id;
----------------------------------------
procedure get_rec_by_id
      (n_tab  in out nocopy  players%ROWTYPE
      )
is
   start_tstamp  timestamp := systimestamp;
begin
   if n_tab.id is null then
      clear(n_tab);
   else
      select * into n_tab from players
       where id = n_tab.id;
   end if;
   return;
   util.trc_time_interval('players_dml.get_rec_by_id(tab rec) ID:' || n_tab.id, start_tstamp);
end get_rec_by_id;
----------
function get_rec_by_id
      (n_tab  in out nocopy  players%ROWTYPE
      ) return varchar2
is
begin
   get_rec_by_id(n_tab);
   return '';
exception when others then return sqlerrm;
end get_rec_by_id;
----------------------------------------
-- Insert a players ACTIVE View Record
procedure ins
      (new_rec  in out nocopy  players_act%ROWTYPE
      ,upd_vals_in  in  boolean default TRUE
      )
is
   new_tab  players%ROWTYPE;
   start_tstamp  timestamp := systimestamp;
begin
   -- Set new_rec.game_id, if needed
   if new_rec.game_id is null then
      if    new_rec.games_nk1 is not null
        and new_rec.games_nk2 is not null
      then
         new_rec.game_id := games_tab.get_id
            (new_rec.games_nk1
            ,new_rec.games_nk2
            );
         if new_rec.game_id is null then
            raise_application_error(-20020, 'Null ID was returned from games_tab.get_id');
         end if;
      end if;
   end if;
   new_tab.id := new_rec.id;
   new_tab.game_id := new_rec.game_id;
   new_tab.name := new_rec.name;
   new_tab.seq := new_rec.seq;
   new_tab.total_cards := new_rec.total_cards;
   players_tab.ins(new_tab);
   if upd_vals_in then
      -- players_tab.ins returns a new ID, if needed
      select * into new_rec from players_act
       where id = new_tab.id;
   end if;
   return;
   util.trc_time_interval('players_dml.ins(act rec) ID:' || new_rec.id, start_tstamp);
end ins;
----------
function ins
      (new_rec  in out nocopy  players_act%ROWTYPE
      ,upd_vals_in  in  boolean default TRUE
      ) return varchar2
is
begin
   ins(new_rec, upd_vals_in);
   return '';
exception when others then return sqlerrm;
end ins;
----------------------------------------
-- Insert a players Table Record
procedure ins
      (new_tab   in out nocopy  players%ROWTYPE
      )
is
   start_tstamp  timestamp := systimestamp;
begin
   players_tab.ins(new_tab);
   return;
   util.trc_time_interval('players_dml.ins(tab rec) ID:' || new_tab.id, start_tstamp);
end ins;
----------
function ins
      (new_tab   in out nocopy  players%ROWTYPE
      ) return varchar2
is
begin
   ins(new_tab);
   return '';
exception when others then return sqlerrm;
end ins;
----------------------------------------
-- Insert columns for players ACTIVE View
--   without returning updated data in each column
procedure ins
      (id_in  in  NUMBER default null
      ,game_id_in  in  NUMBER default null
      ,games_nk1_in  in  VARCHAR2 default null
      ,games_nk2_in  in  VARCHAR2 default null
      ,name_in  in  VARCHAR2 default null
      ,seq_in  in  NUMBER
      ,total_cards_in  in  NUMBER default null
      )
is
   new_rec  players_act%ROWTYPE;
   start_tstamp  timestamp := systimestamp;
begin
   new_rec.id := id_in;
   new_rec.game_id := game_id_in;
   new_rec.games_nk1 := games_nk1_in;
   new_rec.games_nk2 := games_nk2_in;
   new_rec.name := name_in;
   new_rec.seq := seq_in;
   new_rec.total_cards := total_cards_in;
   ins(new_rec, FALSE);
   return;
   util.trc_time_interval('players_dml.ins(tab col) ID:' || id_in, start_tstamp);
end ins;
----------
function ins
      (id_in  in  NUMBER default null
      ,game_id_in  in  NUMBER default null
      ,games_nk1_in  in  VARCHAR2 default null
      ,games_nk2_in  in  VARCHAR2 default null
      ,name_in  in  VARCHAR2 default null
      ,seq_in  in  NUMBER
      ,total_cards_in  in  NUMBER default null
      ) return varchar2
is
begin
   ins
      (id_in
      ,game_id_in
      ,games_nk1_in
      ,games_nk2_in
      ,name_in
      ,seq_in
      ,total_cards_in
      );
   return '';
exception when others then return sqlerrm;
end ins;
----------------------------------------
-- Insert columns for players ACTIVE View
--   with updated data returned in each column
procedure ins2
      (id_io  in out nocopy  NUMBER
      ,game_id_io  in out nocopy  NUMBER
      ,games_nk1_io  in out nocopy  VARCHAR2
      ,games_nk2_io  in out nocopy  VARCHAR2
      ,name_io  in out nocopy  VARCHAR2
      ,seq_io  in out nocopy  NUMBER
      ,total_cards_io  in out nocopy  NUMBER
      )
is
   new_rec  players_act%ROWTYPE;
   start_tstamp  timestamp := systimestamp;
begin
   new_rec.id := id_io;
   new_rec.game_id := game_id_io;
   new_rec.games_nk1 := games_nk1_io;
   new_rec.games_nk2 := games_nk2_io;
   new_rec.name := name_io;
   new_rec.seq := seq_io;
   new_rec.total_cards := total_cards_io;
   --
   ins(new_rec);
   --
   id_io := new_rec.id;
   game_id_io := new_rec.game_id;
   games_nk1_io := new_rec.games_nk1;
   games_nk2_io := new_rec.games_nk2;
   name_io := new_rec.name;
   seq_io := new_rec.seq;
   total_cards_io := new_rec.total_cards;
   return;
   util.trc_time_interval('players_dml.ins2(tab col) ID:' || id_io, start_tstamp);
end ins2;
----------
function ins2
      (id_io  in out nocopy  NUMBER
      ,game_id_io  in out nocopy  NUMBER
      ,games_nk1_io  in out nocopy  VARCHAR2
      ,games_nk2_io  in out nocopy  VARCHAR2
      ,name_io  in out nocopy  VARCHAR2
      ,seq_io  in out nocopy  NUMBER
      ,total_cards_io  in out nocopy  NUMBER
      ) return varchar2
is
begin
   ins2
      (id_io
      ,game_id_io
      ,games_nk1_io
      ,games_nk2_io
      ,name_io
      ,seq_io
      ,total_cards_io
      );
   return '';
exception when others then return sqlerrm;
end ins2;
----------------------------------------
-- Insert columns for players Table
--   with updated data returned in each column
procedure ins2
      (id_io  in out nocopy  NUMBER
      ,game_id_io  in out nocopy  NUMBER
      ,name_io  in out nocopy  VARCHAR2
      ,seq_io  in out nocopy  NUMBER
      ,total_cards_io  in out nocopy  NUMBER
      )
is
   new_rec  players%ROWTYPE;
   start_tstamp  timestamp := systimestamp;
begin
   new_rec.id := id_io;
   new_rec.game_id := game_id_io;
   new_rec.name := name_io;
   new_rec.seq := seq_io;
   new_rec.total_cards := total_cards_io;
   --
   players_tab.ins(new_rec);
   --
   id_io := new_rec.id;
   game_id_io := new_rec.game_id;
   name_io := new_rec.name;
   seq_io := new_rec.seq;
   total_cards_io := new_rec.total_cards;
   return;
   util.trc_time_interval('players_dml.ins2(tab col) ID:' || id_io, start_tstamp);
end ins2;
----------
function ins2
      (id_io  in out nocopy  NUMBER
      ,game_id_io  in out nocopy  NUMBER
      ,name_io  in out nocopy  VARCHAR2
      ,seq_io  in out nocopy  NUMBER
      ,total_cards_io  in out nocopy  NUMBER
      ) return varchar2
is
begin
   ins2
      (id_io
      ,game_id_io
      ,name_io
      ,seq_io
      ,total_cards_io
      );
   return '';
exception when others then return sqlerrm;
end ins2;
----------------------------------------
-- Special Use Update for Specific Column Updates.
--   Only differences between old and new data will be updated.
--   Set upd_val_in TRUE to get updated data in new_rec
procedure upd
      (old_rec  in  players_act%ROWTYPE
      ,new_rec  in out nocopy  players_act%ROWTYPE
      ,upd_vals_in  in  boolean default FALSE
      )
is
   old_tab  players%ROWTYPE;
   new_tab  players%ROWTYPE;
   start_tstamp  timestamp := systimestamp;
begin
   if old_rec.id is null then
      raise_application_error (-20023, 'ID is null');
   end if;
   -- Set new_rec.game_id, if needed
   if new_rec.game_id is null then
      if    new_rec.games_nk1 is not null
        and new_rec.games_nk2 is not null
      then
         new_rec.game_id := games_tab.get_id
            (new_rec.games_nk1
            ,new_rec.games_nk2
            );
         if new_rec.game_id is null then
            raise_application_error(-20020, 'Null ID was returned from games_tab.get_id');
         end if;
      end if;
   end if;
   -- Set new_rec.game_id, if needed
   if new_rec.game_id = old_rec.game_id then
      if    not (new_rec.games_nk1 = old_rec.games_nk1)
        or  not (new_rec.games_nk2 = old_rec.games_nk2)
      then
         new_rec.game_id := games_tab.get_id
            (new_rec.games_nk1
            ,new_rec.games_nk2
            );
         if new_rec.game_id is null then
            raise_application_error(-20020, 'Null ID was returned from games_tab.get_id');
         end if;
      end if;
   end if;
   -- Load the Table Record from the View Record
   old_tab.id := old_rec.id;
   new_tab.id := new_rec.id;
   old_tab.game_id := old_rec.game_id;
   new_tab.game_id := new_rec.game_id;
   old_tab.name := old_rec.name;
   new_tab.name := new_rec.name;
   old_tab.seq := old_rec.seq;
   new_tab.seq := new_rec.seq;
   old_tab.total_cards := old_rec.total_cards;
   new_tab.total_cards := new_rec.total_cards;
   -- Run the update
   players_tab.upd(old_tab, new_tab);
   if upd_vals_in then
      -- Load the View Record from the Returned (new) Table Record
      -- players_tab.upd should have set new ID = old ID
      select * into new_rec from players_act
       where id = old_tab.id;
   end if;
   return;
   util.trc_time_interval('players_dml.upd(trigger) ID:' || old_tab.id, start_tstamp);
end upd;
----------
function upd
      (old_rec  in  players_act%ROWTYPE
      ,new_rec  in out nocopy  players_act%ROWTYPE
      ,upd_vals_in  in  boolean default FALSE
      ) return varchar2
is
begin
   upd(old_rec, new_rec, upd_vals_in);
   return '';
exception when others then return sqlerrm;
end upd;
----------------------------------------
-- Special Use Update for Specific Column Updates.
--   Only differences between old and new data will be updated.
--   Set upd_val_in TRUE to get updated data in new_rec
procedure upd
      (old_tab  in  players%ROWTYPE
      ,new_tab  in out nocopy  players%ROWTYPE
      )
is
   start_tstamp  timestamp := systimestamp;
begin
   if old_tab.id is null then
      raise_application_error (-20023, 'ID is null');
   end if;
   -- Run the update
   players_tab.upd(old_tab, new_tab);
   return;
   util.trc_time_interval('players_dml.upd(trigger) ID:' || old_tab.id, start_tstamp);
end upd;
----------
function upd
      (old_tab  in  players%ROWTYPE
      ,new_tab  in out nocopy  players%ROWTYPE
      ) return varchar2
is
begin
   upd(old_tab, new_tab);
   return '';
exception when others then return sqlerrm;
end upd;
----------------------------------------
-- Update a players ACTIVE View Record
procedure upd
      (new_rec  in out nocopy  players_act%ROWTYPE
      ,upd_vals_in  in  boolean default TRUE
      )
is
   old_rec  players_act%ROWTYPE;
   start_tstamp  timestamp := systimestamp;
begin
   if new_rec.id is null then
      if    new_rec.games_nk1 is not null
        and new_rec.games_nk2 is not null
        and new_rec.name is not null
      then
         new_rec.id := players_tab.get_id
            (new_rec.games_nk1
            ,new_rec.games_nk2
            ,new_rec.name
            );
      end if;
   end if;
   if new_rec.id is null then
      if    new_rec.game_id is not null
        and new_rec.name is not null
      then
         begin
            select id into new_rec.id from players
             where game_id = new_rec.game_id
              and  name = new_rec.name
               ;
         exception when NO_DATA_FOUND then new_rec.id := null;
         end;
      end if;
   end if;
   if new_rec.id is null then
      raise_application_error (-20023, 'ID is null and could not be found from Natural Keys');
   end if;
   select * into old_rec from players_act
    where id = new_rec.id;
   upd(old_rec, new_rec, upd_vals_in);
   return;
   util.trc_time_interval('players_dml.upd(act rec) ID:' || new_rec.id, start_tstamp);
end upd;
----------
function upd
      (new_rec  in out nocopy  players_act%ROWTYPE
      ,upd_vals_in  in  boolean default TRUE
      ) return varchar2
is
begin
   upd(new_rec, upd_vals_in);
   return '';
exception when others then return sqlerrm;
end upd;
----------------------------------------
-- Update a players Table Record
procedure upd
      (new_tab   in out nocopy  players%ROWTYPE
      )
is
   start_tstamp  timestamp := systimestamp;
begin
   if new_tab.id is null then
      if    new_tab.game_id is not null
        and new_tab.name is not null
      then
         begin
            select id into new_tab.id from players
             where game_id = new_tab.game_id
              and  name = new_tab.name
               ;
         exception when NO_DATA_FOUND then new_tab.id := null;
         end;
      end if;
   end if;
   if new_tab.id is null then
      raise_application_error (-20023, 'ID is null and could not be found from Natural Keys');
   end if;
   players_tab.upd(new_tab);
   return;
   util.trc_time_interval('players_dml.upd(tab rec) ID:' || new_tab.id, start_tstamp);
end upd;
----------
function upd
      (new_tab   in out nocopy  players%ROWTYPE
      ) return varchar2
is
begin
   upd(new_tab);
   return '';
exception when others then return sqlerrm;
end upd;
----------------------------------------
-- Update columns for players ACTIVE View
--   without returning updated data in each column
procedure upd
      (id_in  in  NUMBER default null
      ,game_id_in  in  NUMBER default null
      ,games_nk1_in  in  VARCHAR2 default null
      ,games_nk2_in  in  VARCHAR2 default null
      ,name_in  in  VARCHAR2 default null
      ,seq_in  in  NUMBER
      ,total_cards_in  in  NUMBER default null
      )
is
   new_rec  players_act%ROWTYPE;
   start_tstamp  timestamp := systimestamp;
begin
   new_rec.id := id_in;
   new_rec.game_id := game_id_in;
   new_rec.games_nk1 := games_nk1_in;
   new_rec.games_nk2 := games_nk2_in;
   new_rec.name := name_in;
   new_rec.seq := seq_in;
   new_rec.total_cards := total_cards_in;
   -- Make corrections when ID is supplied, but NK is missing
   if    new_rec.ID is not null
     and new_rec.games_nk1 is null
     and new_rec.games_nk2 is null
     and new_rec.name is null
   then
      select PLY.games_nk1
            ,PLY.games_nk2
            ,PLY.name
       into  new_rec.games_nk1
            ,new_rec.games_nk2
            ,new_rec.name
       from  players_act  PLY
       where PLY.id = new_rec.ID;
   end if;
   -- Make corrections when game_id is supplied, but the Natural Key is missing
   if    new_rec.game_id is not null
     and new_rec.games_nk1 is null
     and new_rec.games_nk2 is null
   then
      select GAM.users_nk1
            ,GAM.name
       into  new_rec.games_nk1
            ,new_rec.games_nk2
       from  games_act  GAM
       where GAM.id = new_rec.game_id;
   end if;
   upd(new_rec, FALSE);
   return;
   util.trc_time_interval('players_dml.upd(act col) ID:' || id_in, start_tstamp);
end upd;
----------
function upd
      (id_in  in  NUMBER default null
      ,game_id_in  in  NUMBER default null
      ,games_nk1_in  in  VARCHAR2 default null
      ,games_nk2_in  in  VARCHAR2 default null
      ,name_in  in  VARCHAR2 default null
      ,seq_in  in  NUMBER
      ,total_cards_in  in  NUMBER default null
      ) return varchar2
is
begin
   upd
      (id_in
      ,game_id_in
      ,games_nk1_in
      ,games_nk2_in
      ,name_in
      ,seq_in
      ,total_cards_in
      );
   return '';
exception when others then return sqlerrm;
end upd;
----------------------------------------
-- Update columns for players ACTIVE View
--   with updated data returned in each column
procedure upd2
      (id_io  in out nocopy  NUMBER
      ,game_id_io  in out nocopy  NUMBER
      ,games_nk1_io  in out nocopy  VARCHAR2
      ,games_nk2_io  in out nocopy  VARCHAR2
      ,name_io  in out nocopy  VARCHAR2
      ,seq_io  in out nocopy  NUMBER
      ,total_cards_io  in out nocopy  NUMBER
      )
is
   new_rec  players_act%ROWTYPE;
   start_tstamp  timestamp := systimestamp;
begin
   new_rec.id := id_io;
   new_rec.game_id := game_id_io;
   new_rec.games_nk1 := games_nk1_io;
   new_rec.games_nk2 := games_nk2_io;
   new_rec.name := name_io;
   new_rec.seq := seq_io;
   new_rec.total_cards := total_cards_io;
   --
   --  upd(new_rec) will set new_rec.id as needed
   upd(new_rec);
   --
   id_io := new_rec.id;
   game_id_io := new_rec.game_id;
   games_nk1_io := new_rec.games_nk1;
   games_nk2_io := new_rec.games_nk2;
   name_io := new_rec.name;
   seq_io := new_rec.seq;
   total_cards_io := new_rec.total_cards;
   return;
   util.trc_time_interval('players_dml.upd2(act col) ID:' || id_io, start_tstamp);
end upd2;
----------
function upd2
      (id_io  in out nocopy  NUMBER
      ,game_id_io  in out nocopy  NUMBER
      ,games_nk1_io  in out nocopy  VARCHAR2
      ,games_nk2_io  in out nocopy  VARCHAR2
      ,name_io  in out nocopy  VARCHAR2
      ,seq_io  in out nocopy  NUMBER
      ,total_cards_io  in out nocopy  NUMBER
      ) return varchar2
is
begin
   upd2
      (id_io
      ,game_id_io
      ,games_nk1_io
      ,games_nk2_io
      ,name_io
      ,seq_io
      ,total_cards_io
      );
   return '';
exception when others then return sqlerrm;
end upd2;
----------------------------------------
-- Update columns for players Table
--   with updated data returned in each column
procedure upd2
      (id_io  in out nocopy  NUMBER
      ,game_id_io  in out nocopy  NUMBER
      ,name_io  in out nocopy  VARCHAR2
      ,seq_io  in out nocopy  NUMBER
      ,total_cards_io  in out nocopy  NUMBER
      )
is
   new_rec  players%ROWTYPE;
   start_tstamp  timestamp := systimestamp;
begin
   if id_io is null then
      if    game_id_io is not null
        and name_io is not null
      then
         begin
            select id into id_io from players
             where game_id = game_id_io
              and  name = name_io
               ;
         exception when NO_DATA_FOUND then id_io := null;
         end;
      end if;
   end if;
   if id_io is null then
      raise_application_error (-20023, 'ID is null and could not be found from Natural Keys');
   end if;
   new_rec.id := id_io;
   new_rec.game_id := game_id_io;
   new_rec.name := name_io;
   new_rec.seq := seq_io;
   new_rec.total_cards := total_cards_io;
   --
   players_tab.upd(new_rec);
   --
   id_io := new_rec.id;
   game_id_io := new_rec.game_id;
   name_io := new_rec.name;
   seq_io := new_rec.seq;
   total_cards_io := new_rec.total_cards;
   return;
   util.trc_time_interval('players_dml.upd2(tab col) ID:' || id_io, start_tstamp);
end upd2;
----------
function upd2
      (id_io  in out nocopy  NUMBER
      ,game_id_io  in out nocopy  NUMBER
      ,name_io  in out nocopy  VARCHAR2
      ,seq_io  in out nocopy  NUMBER
      ,total_cards_io  in out nocopy  NUMBER
      ) return varchar2
is
begin
    upd2
      (id_io
      ,game_id_io
      ,name_io
      ,seq_io
      ,total_cards_io
      );
   return '';
exception when others then return sqlerrm;
end upd2;

----------------------------------------
-- Application Delete procedure without updated parameters
procedure del
      (id_in  in  NUMBER default null
      ,game_id_in  in  NUMBER default null
      ,games_nk1_in  in  VARCHAR2 default null
      ,games_nk2_in  in  VARCHAR2 default null
      ,name_in  in  VARCHAR2 default null
      )
is
   start_tstamp  timestamp := systimestamp;
   tmp_id  NUMBER;
begin
   tmp_id := id_in;
   if tmp_id is null then
      if    games_nk1_in is not null
        and games_nk2_in is not null
        and name_in is not null
      then
         tmp_id := players_tab.get_id
            (games_nk1_in
            ,games_nk2_in
            ,name_in
            );
      end if;
   end if;
   if tmp_id is null then
      if    game_id_in is not null
        and name_in is not null
      then
         begin
            select id into tmp_id from players
             where game_id = game_id_in
              and  name = name_in
               ;
         exception when NO_DATA_FOUND then tmp_id := null;
         end;
      end if;
   end if;
   if tmp_id is null then
      raise_application_error (-20023, 'ID is null and could not be found from Natural Keys');
   end if;
   players_tab.del(tmp_id);
   return;
   util.trc_time_interval('players_dml.del ID:' || id_in, start_tstamp);
end del;
----------
function del
      (id_in  in  NUMBER default null
      ,game_id_in  in  NUMBER default null
      ,games_nk1_in  in  VARCHAR2 default null
      ,games_nk2_in  in  VARCHAR2 default null
      ,name_in  in  VARCHAR2 default null
      ) return varchar2
is
begin
   del
      (id_in
      ,game_id_in
      ,games_nk1_in
      ,games_nk2_in
      ,name_in
      );
   return '';
exception when others then return sqlerrm;
end del;
----------------------------------------
-- Application Delete procedure with updated parameters
procedure del2
      (id_io  in out nocopy  NUMBER
      ,game_id_in  in  NUMBER default null
      ,games_nk1_in  in  VARCHAR2 default null
      ,games_nk2_in  in  VARCHAR2 default null
      ,name_in  in  VARCHAR2 default null
      )
is
   start_tstamp  timestamp := systimestamp;
begin
   if id_io is null then
      if    games_nk1_in is not null
        and games_nk2_in is not null
        and name_in is not null
      then
         id_io := players_tab.get_id
            (games_nk1_in
            ,games_nk2_in
            ,name_in
            );
      end if;
   end if;
   if id_io is null then
      if    game_id_in is not null
        and name_in is not null
      then
         begin
            select id into id_io from players
             where game_id = game_id_in
              and  name = name_in
               ;
         exception when NO_DATA_FOUND then id_io := null;
         end;
      end if;
   end if;
   if id_io is null then
      raise_application_error (-20023, 'ID is null and could not be found from Natural Keys');
   end if;
   players_tab.del(id_io);
   return;
   util.trc_time_interval('players_dml.del2 ID:' || id_io, start_tstamp);
end del2;
----------
function del2
      (id_io  in out nocopy  NUMBER
      ,game_id_in  in  NUMBER default null
      ,games_nk1_in  in  VARCHAR2 default null
      ,games_nk2_in  in  VARCHAR2 default null
      ,name_in  in  VARCHAR2 default null
      ) return varchar2
is
begin
   del2
      (id_io
      ,game_id_in
      ,games_nk1_in
      ,games_nk2_in
      ,name_in
      );
   return '';
exception when others then return sqlerrm;
end del2;
----------------------------------------
procedure load_dim
      (dim_tab  in out nocopy  players%ROWTYPE
      )
is
   -- Special Data Warehouse Dimension Function
   start_tstamp  timestamp := systimestamp;
   procedure private_upd is
      saved_inc  boolean := util.get_ignore_no_change;
   begin
      util.set_ignore_no_change(TRUE);
      upd (dim_tab);
      util.set_ignore_no_change(saved_inc);
   exception
      when others then
         util.set_ignore_no_change(saved_inc);
         raise;
   end private_upd;
begin
   -- Attempt to find matching record based on natural keys
   if dim_tab.id is null then
      begin
         select id
          into  dim_tab.id
          from  players
          where game_id = dim_tab.game_id
           and  game_id = dim_tab.game_id
           and  name = dim_tab.name
         ;
      exception
         when NO_DATA_FOUND then dim_tab.id := null;
      end;
   end if;
   if dim_tab.id is not null then
      -- If found, perform update on non-NK columns that changed
      private_upd;
      return;
      util.trc_time_interval('players_dml.load_dimE ID:' || dim_tab.id, start_tstamp);
   end if;
   -- If not found, insert new record
   begin
      ins(dim_tab);
   exception
      when DUP_VAL_ON_INDEX then
         -- Since this can run multi-threaded, another thread
         --   may have already populated this value.
         private_upd;
   end;
   return;
   util.trc_time_interval('players_dml.load_dim ID:' || dim_tab.id, start_tstamp);
end load_dim;
----------
function load_dim
      (dim_tab  in out nocopy  players%ROWTYPE
      ) return varchar2
is
begin
   load_dim(dim_tab);
   return '';
exception when others then return sqlerrm;
end load_dim;
----------------------------------------
end players_dml;
/
select 'PLAYERS_DML' as "Package Body:"
 from  user_errors
 where name  = 'PLAYERS_DML'
  and  type  = 'PACKAGE BODY'
  and  rownum = 1
/
select '('||line||'/'||position||') '||text as error
 from  user_errors
 where name = 'PLAYERS_DML'
  and  type = 'PACKAGE BODY'
 order by sequence
/

create TRIGGER players_act_ioi
   instead of insert on players_act
   for each row
declare

   -- Trigger Players_Act_Ioi

   -- Application: Clue Notes For Oracle
   -- Generated by DTGen (http://dmstex.com/services/dtgen)
   -- December  16, 2013  11:32:31 AM

   --
   --
   -- © Duane.Dieterich@DMSTEX.com 2013
   --
   -- All Rights Reserved
   --
   -- No part of this software may be reproduced, copied, modified or adapted,
   -- without the prior written consent of the author, unless otherwise
   -- indicated for stand-alone materials.
   --
   -- You may quote extracts from this software with attribution to
   -- Duane.Dieterich@DMSTEX.com
   --
   -- For any other mode of sharing, please contact Duane.Dieterich@DMSTEX.com.
   --
   -- Commercial use and distribution of this software is not allowed without
   -- express and prior written consent of the author.
   --
   -- THE SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
   -- INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY
   -- AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL
   -- THE COPYRIGHT HOLDER OR DMSTEX BUSINESS SOLUTIONS LLC, ITS MEMBERS,
   -- MANAGERS, OR EMPLOYEES BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
   -- SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
   -- TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
   -- PROFITS; CORRUPTION OF DATA, OR BUSINESS INTERRUPTION) HOWEVER CAUSED
   -- AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
   -- OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF
   -- THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH
   -- DAMAGE.
   --
   --


   new_rec  players_act%ROWTYPE;
   start_tstamp  timestamp := systimestamp;
begin
   new_rec.id := :new.id;
   new_rec.game_id := :new.game_id;
   new_rec.games_nk1 := :new.games_nk1;
   new_rec.games_nk2 := :new.games_nk2;
   new_rec.name := :new.name;
   new_rec.seq := :new.seq;
   new_rec.total_cards := :new.total_cards;
   players_dml.ins(new_rec, FALSE);
   util.trc_time_interval('players_act_ioi trigger ID:' || :new.id, start_tstamp);
end players_act_ioi;
/
select 'PLAYERS_ACT_IOI' as "Trigger:"
 from  user_errors
 where name  = 'PLAYERS_ACT_IOI'
  and  type  = 'TRIGGER'
  and  rownum = 1
/
select '('||line||'/'||position||') '||text as error
 from  user_errors
 where name = 'PLAYERS_ACT_IOI'
  and  type = 'TRIGGER'
 order by sequence
/

create TRIGGER players_act_iou
   instead of update on players_act
   for each row
declare

   -- Trigger Players_Act_Iou

   -- Application: Clue Notes For Oracle
   -- Generated by DTGen (http://dmstex.com/services/dtgen)
   -- December  16, 2013  11:32:31 AM

   --
   --
   -- © Duane.Dieterich@DMSTEX.com 2013
   --
   -- All Rights Reserved
   --
   -- No part of this software may be reproduced, copied, modified or adapted,
   -- without the prior written consent of the author, unless otherwise
   -- indicated for stand-alone materials.
   --
   -- You may quote extracts from this software with attribution to
   -- Duane.Dieterich@DMSTEX.com
   --
   -- For any other mode of sharing, please contact Duane.Dieterich@DMSTEX.com.
   --
   -- Commercial use and distribution of this software is not allowed without
   -- express and prior written consent of the author.
   --
   -- THE SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
   -- INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY
   -- AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL
   -- THE COPYRIGHT HOLDER OR DMSTEX BUSINESS SOLUTIONS LLC, ITS MEMBERS,
   -- MANAGERS, OR EMPLOYEES BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
   -- SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
   -- TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
   -- PROFITS; CORRUPTION OF DATA, OR BUSINESS INTERRUPTION) HOWEVER CAUSED
   -- AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
   -- OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF
   -- THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH
   -- DAMAGE.
   --
   --


   old_rec  players_act%ROWTYPE;
   new_rec  players_act%ROWTYPE;
   start_tstamp  timestamp := systimestamp;
begin
   -- NOTE: Column Specified Update DML works without this lock
   --select btab.id into new_rec.id from players btab
   -- where btab.id = :old.id for update;
   old_rec.id := :old.id;
   new_rec.id := :new.id;
   old_rec.game_id := :old.game_id;
   new_rec.game_id := :new.game_id;
   old_rec.games_nk1 := :old.games_nk1;
   new_rec.games_nk1 := :new.games_nk1;
   old_rec.games_nk2 := :old.games_nk2;
   new_rec.games_nk2 := :new.games_nk2;
   old_rec.name := :old.name;
   new_rec.name := :new.name;
   old_rec.seq := :old.seq;
   new_rec.seq := :new.seq;
   old_rec.total_cards := :old.total_cards;
   new_rec.total_cards := :new.total_cards;
   players_dml.upd(old_rec, new_rec);
   util.trc_time_interval('players_act_iou trigger ID:' || :old.id, start_tstamp);
end players_act_iou;
/
select 'PLAYERS_ACT_IOU' as "Trigger:"
 from  user_errors
 where name  = 'PLAYERS_ACT_IOU'
  and  type  = 'TRIGGER'
  and  rownum = 1
/
select '('||line||'/'||position||') '||text as error
 from  user_errors
 where name = 'PLAYERS_ACT_IOU'
  and  type = 'TRIGGER'
 order by sequence
/

create TRIGGER players_act_iod
   instead of delete on players_act
   for each row
declare

   -- Trigger Players_Act_Iod

   -- Application: Clue Notes For Oracle
   -- Generated by DTGen (http://dmstex.com/services/dtgen)
   -- December  16, 2013  11:32:31 AM

   --
   --
   -- © Duane.Dieterich@DMSTEX.com 2013
   --
   -- All Rights Reserved
   --
   -- No part of this software may be reproduced, copied, modified or adapted,
   -- without the prior written consent of the author, unless otherwise
   -- indicated for stand-alone materials.
   --
   -- You may quote extracts from this software with attribution to
   -- Duane.Dieterich@DMSTEX.com
   --
   -- For any other mode of sharing, please contact Duane.Dieterich@DMSTEX.com.
   --
   -- Commercial use and distribution of this software is not allowed without
   -- express and prior written consent of the author.
   --
   -- THE SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
   -- INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY
   -- AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL
   -- THE COPYRIGHT HOLDER OR DMSTEX BUSINESS SOLUTIONS LLC, ITS MEMBERS,
   -- MANAGERS, OR EMPLOYEES BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
   -- SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
   -- TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
   -- PROFITS; CORRUPTION OF DATA, OR BUSINESS INTERRUPTION) HOWEVER CAUSED
   -- AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
   -- OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF
   -- THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH
   -- DAMAGE.
   --
   --


   start_tstamp  timestamp := systimestamp;
begin
   players_tab.del(:old.id);
   util.trc_time_interval('players_act_iod trigger ID:' || :old.id, start_tstamp);
end players_act_iod;
/
select 'PLAYERS_ACT_IOD' as "Trigger:"
 from  user_errors
 where name  = 'PLAYERS_ACT_IOD'
  and  type  = 'TRIGGER'
  and  rownum = 1
/
select '('||line||'/'||position||') '||text as error
 from  user_errors
 where name = 'PLAYERS_ACT_IOD'
  and  type = 'TRIGGER'
 order by sequence
/


create view cards_act
      (id
      ,game_id
      ,games_nk1
      ,games_nk2
      ,name
      ,ctype_id
      ,card_types_nk1
      ,card_types_nk2
      )
   as select
       CRD.id
      ,CRD.game_id
      ,GAM.users_nk1
      ,GAM.name
      ,CRD.name
      ,CRD.ctype_id
      ,CTYPE.users_nk1
      ,CTYPE.name
 from             cards CRD
       inner join games_act GAM on GAM.id = CRD.game_id
       inner join card_types_act CTYPE on CTYPE.id = CRD.ctype_id
/
select 'CARDS_ACT' as "View:"
 from  user_errors
 where name  = 'CARDS_ACT'
  and  type  = 'VIEW'
  and  rownum = 1
/
select '('||line||'/'||position||') '||text as error
 from  user_errors
 where name = 'CARDS_ACT'
  and  type = 'VIEW'
 order by sequence
/

comment on table cards_act is 'Cards for each User''s Game'
/

comment on column cards_act.id is 'Surrogate Primary Key for these cards'
/
comment on column cards_act.game_id is 'User''s Game for this Card'
/
comment on column cards_act.games_nk1 is 'GAMES Natural Key 1: USERS NK1: Clue Notes User Name'
/
comment on column cards_act.games_nk2 is 'GAMES Natural Key 2: User''s Game Name'
/
comment on column cards_act.name is 'Card Name'
/
comment on column cards_act.ctype_id is 'Card Type'
/
comment on column cards_act.card_types_nk1 is 'CARD_TYPES Natural Key 1: USERS NK1: Clue Notes User Name'
/
comment on column cards_act.card_types_nk2 is 'CARD_TYPES Natural Key 2: Card Type Name'
/

alter view cards_act add constraint cards_act_pk
   primary key (id) disable
/

alter view cards_act add constraint cards_act_fk1
   foreign key (game_id) references games_act (id) disable
/
alter view cards_act add constraint cards_act_fk3
   foreign key (ctype_id) references card_types_act (id) disable
/

CREATE type cards_vobj
is
   -- Cards Active View (Virtual) Record Type
object
   (id  NUMBER(38)
   ,game_id  NUMBER(38)
   ,games_nk1  VARCHAR2(320)
   ,games_nk2  VARCHAR2(320)
   ,name  VARCHAR2(15)
   ,ctype_id  NUMBER(38)
   ,card_types_nk1  VARCHAR2(320)
   ,card_types_nk2  VARCHAR2(15)
   )
/
select 'CARDS_VOBJ' as "Type:"
 from  user_errors
 where name  = 'CARDS_VOBJ'
  and  type  = 'TYPE'
  and  rownum = 1
/
select '('||line||'/'||position||') '||text as error
 from  user_errors
 where name = 'CARDS_VOBJ'
  and  type = 'TYPE'
 order by sequence
/

CREATE type cards_vtab
is
   -- Cards Active View (Virtual) Table Type
table of cards_vobj
/
select 'CARDS_VTAB' as "Type:"
 from  user_errors
 where name  = 'CARDS_VTAB'
  and  type  = 'TYPE'
  and  rownum = 1
/
select '('||line||'/'||position||') '||text as error
 from  user_errors
 where name = 'CARDS_VTAB'
  and  type = 'TYPE'
 order by sequence
/

create package cards_dml
is

   -- Package Cards_Dml
   -- (Data Manipulation Language, Foreign Key and Path Lookup)

   -- Application: Clue Notes For Oracle
   -- Generated by DTGen (http://dmstex.com/services/dtgen)
   -- December  16, 2013  11:32:31 AM

   --
   --
   -- © Duane.Dieterich@DMSTEX.com 2013
   --
   -- All Rights Reserved
   --
   -- No part of this software may be reproduced, copied, modified or adapted,
   -- without the prior written consent of the author, unless otherwise
   -- indicated for stand-alone materials.
   --
   -- You may quote extracts from this software with attribution to
   -- Duane.Dieterich@DMSTEX.com
   --
   -- For any other mode of sharing, please contact Duane.Dieterich@DMSTEX.com.
   --
   -- Commercial use and distribution of this software is not allowed without
   -- express and prior written consent of the author.
   --
   -- THE SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
   -- INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY
   -- AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL
   -- THE COPYRIGHT HOLDER OR DMSTEX BUSINESS SOLUTIONS LLC, ITS MEMBERS,
   -- MANAGERS, OR EMPLOYEES BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
   -- SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
   -- TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
   -- PROFITS; CORRUPTION OF DATA, OR BUSINESS INTERRUPTION) HOWEVER CAUSED
   -- AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
   -- OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF
   -- THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH
   -- DAMAGE.
   --
   --


   -- Return the next Surrogate Key ID for cards
   function get_next_id
      return NUMBER;
   -- Return the current Surrogate Key ID for cards
   --   NOTE: This will return an ERROR if get_next_id has not been called
   function get_curr_id
      return NUMBER;

   -- Return the next Surrogate Key ID for the Natural Keys of cards
   --   NOTE: The fields used in this function are the Natural Keys for cards
   --         Alternatively, the Natural Key IDs for cards are:
   --            -) game_id
   --            -) name
   function get_id
      (games_nk1  in  VARCHAR2
      ,games_nk2  in  VARCHAR2
      ,name  in  VARCHAR2
      ) return NUMBER;
   -- For all the Natural Key Column IDs, Return an ID
   function get_id2
      (game_id_in  in  NUMBER
      ,name_in  in  VARCHAR2
      ) return NUMBER;
   -- Return a concatenated string of Natural Keys for a cards id
   function get_nk
      (id_in  in  NUMBER
      ) return VARCHAR2;

   -- Set a "view" record to null
   procedure clear
      (n_rec  in out nocopy  cards_ACT%ROWTYPE
      );
   -- This function traps and returns any error message from the clear procedure
   function clear
      (n_rec  in out nocopy  cards_ACT%ROWTYPE
      ) return varchar2;
   -- Set a "table" record to null
   procedure clear
      (n_tab  in out nocopy  cards%ROWTYPE
      );
   -- This function traps and returns any error message from the clear procedure
   function clear
      (n_tab  in out nocopy  cards%ROWTYPE
      ) return varchar2;

   -- Set a "view" record from a cards ID
   procedure get_rec_by_id
      (n_rec  in out nocopy  cards_ACT%ROWTYPE
      );
   -- This function traps and returns any error message from the get_rec_by_id procedure
   function get_rec_by_id
      (n_rec  in out nocopy  cards_ACT%ROWTYPE
      ) return varchar2;
   -- Set a "table" record from a cards ID
   procedure get_rec_by_id
      (n_tab  in out nocopy  cards%ROWTYPE
      );
   -- This function traps and returns any error message from the get_rec_by_id procedure
   function get_rec_by_id
      (n_tab  in out nocopy  cards%ROWTYPE
      ) return varchar2;

   -- NOTE: All INS procedures will run faster with a null ID
   --       because it avoids a history search for duplicate IDs
   --
   -- Insert a cards ACTIVE View Record
   -- NOTE: If UPD_VALS_IN is set to FALSE, the function will run faster,
   --       but the returned record may contain invalid data
   procedure ins
      (new_rec  in out nocopy  cards_act%ROWTYPE
      ,upd_vals_in  in  boolean default TRUE
      );
   -- This function traps and returns any error message from the ins procedure
   function ins
      (new_rec  in out nocopy  cards_act%ROWTYPE
      ,upd_vals_in  in  boolean default TRUE
      ) return varchar2;
   -- Insert a cards Table Record
   --  (Fastest insert procedure and returned data is always valid)
   procedure ins
      (new_tab  in out nocopy  cards%ROWTYPE
      );
   -- This function traps and returns any error message from the ins procedure
   function ins
      (new_tab  in out nocopy  cards%ROWTYPE
      ) return varchar2;
   -- Insert columns for cards ACTIVE View
   --   without returning updated data in each column
   procedure ins
      (id_in  in  NUMBER default null
      ,game_id_in  in  NUMBER default null
      ,games_nk1_in  in  VARCHAR2 default null
      ,games_nk2_in  in  VARCHAR2 default null
      ,name_in  in  VARCHAR2 default null
      ,ctype_id_in  in  NUMBER default null
      ,card_types_nk1_in  in  VARCHAR2 default null
      ,card_types_nk2_in  in  VARCHAR2 default null
      );
   -- This function traps and returns any error message from the ins procedure
   function ins
      (id_in  in  NUMBER default null
      ,game_id_in  in  NUMBER default null
      ,games_nk1_in  in  VARCHAR2 default null
      ,games_nk2_in  in  VARCHAR2 default null
      ,name_in  in  VARCHAR2 default null
      ,ctype_id_in  in  NUMBER default null
      ,card_types_nk1_in  in  VARCHAR2 default null
      ,card_types_nk2_in  in  VARCHAR2 default null
      ) return varchar2;
   -- Insert columns for cards ACTIVE View
   --   with updated data returned in each column
   procedure ins2
      (id_io  in out nocopy  NUMBER
      ,game_id_io  in out nocopy  NUMBER
      ,games_nk1_io  in out nocopy  VARCHAR2
      ,games_nk2_io  in out nocopy  VARCHAR2
      ,name_io  in out nocopy  VARCHAR2
      ,ctype_id_io  in out nocopy  NUMBER
      ,card_types_nk1_io  in out nocopy  VARCHAR2
      ,card_types_nk2_io  in out nocopy  VARCHAR2
      );
   -- This function traps and returns any error message from the ins2 procedure
   function ins2
      (id_io  in out nocopy  NUMBER
      ,game_id_io  in out nocopy  NUMBER
      ,games_nk1_io  in out nocopy  VARCHAR2
      ,games_nk2_io  in out nocopy  VARCHAR2
      ,name_io  in out nocopy  VARCHAR2
      ,ctype_id_io  in out nocopy  NUMBER
      ,card_types_nk1_io  in out nocopy  VARCHAR2
      ,card_types_nk2_io  in out nocopy  VARCHAR2
      ) return varchar2;
   -- Insert columns for cards Table
   --   with updated data returned in each column
   procedure ins2
      (id_io  in out nocopy  NUMBER
      ,game_id_io  in out nocopy  NUMBER
      ,name_io  in out nocopy  VARCHAR2
      ,ctype_id_io  in out nocopy  NUMBER
      );
   -- This function traps and returns any error message from the ins2 procedure
   function ins2
      (id_io  in out nocopy  NUMBER
      ,game_id_io  in out nocopy  NUMBER
      ,name_io  in out nocopy  VARCHAR2
      ,ctype_id_io  in out nocopy  NUMBER
      ) return varchar2;

   -- Special Use Update for Specific Column Updates.
   --   Only differences between old and new data will be updated.
   --   Set upd_val_in TRUE to get updated data in new_rec
   procedure upd
      (old_rec  in  cards_act%ROWTYPE
      ,new_rec  in out nocopy  cards_act%ROWTYPE
      ,upd_vals_in  in  boolean default FALSE
      );
   -- This function traps and returns any error message from the upd procedure
   function upd
      (old_rec  in  cards_act%ROWTYPE
      ,new_rec  in out nocopy  cards_act%ROWTYPE
      ,upd_vals_in  in  boolean default FALSE
      ) return varchar2;
   -- Special Use Update for Specific Column Updates.
   --   Only differences between old and new data will be updated.
   --   Set upd_val_in TRUE to get updated data in new_rec
   procedure upd
      (old_tab  in  cards%ROWTYPE
      ,new_tab  in out nocopy  cards%ROWTYPE
      );
   -- This function traps and returns any error message from the upd procedure
   function upd
      (old_tab  in  cards%ROWTYPE
      ,new_tab  in out nocopy  cards%ROWTYPE
      ) return varchar2;
   -- Update a cards ACTIVE View Record
   -- NOTE: If UPD_VALS_IN is set to FALSE, the returned record
   --       may contain invalid data
   -- NOTE: Only FK NKs that are part of this NK will be used to find
   --       this ID from its NKs (FK IDs will be ignored)
   procedure upd
      (new_rec  in out nocopy  cards_act%ROWTYPE
      ,upd_vals_in  in  boolean default TRUE
      );
   -- This function traps and returns any error message from the upd procedure
   function upd
      (new_rec  in out nocopy  cards_act%ROWTYPE
      ,upd_vals_in  in  boolean default TRUE
      ) return varchar2;
   -- Update a cards Table Record
   --  (Fastest update procedure and returned data is always valid)
   -- NOTE: cardsID must be supplied (NK lookup will not be performed)
   procedure upd
      (new_tab  in out nocopy  cards%ROWTYPE
      );
   -- This function traps and returns any error message from the upd procedure
   function upd
      (new_tab  in out nocopy  cards%ROWTYPE
      ) return varchar2;
   -- Update columns for cards ACTIVE View
   --   without returning updated data in each column
   procedure upd
      (id_in  in  NUMBER default null
      ,game_id_in  in  NUMBER default null
      ,games_nk1_in  in  VARCHAR2 default null
      ,games_nk2_in  in  VARCHAR2 default null
      ,name_in  in  VARCHAR2 default null
      ,ctype_id_in  in  NUMBER default null
      ,card_types_nk1_in  in  VARCHAR2 default null
      ,card_types_nk2_in  in  VARCHAR2 default null
      );
   -- This function traps and returns any error message from the upd procedure
   function upd
      (id_in  in  NUMBER default null
      ,game_id_in  in  NUMBER default null
      ,games_nk1_in  in  VARCHAR2 default null
      ,games_nk2_in  in  VARCHAR2 default null
      ,name_in  in  VARCHAR2 default null
      ,ctype_id_in  in  NUMBER default null
      ,card_types_nk1_in  in  VARCHAR2 default null
      ,card_types_nk2_in  in  VARCHAR2 default null
      ) return varchar2;
   -- Update columns for cards ACTIVE View
   --   with updated data returned in each column
   procedure upd2
      (id_io  in out nocopy  NUMBER
      ,game_id_io  in out nocopy  NUMBER
      ,games_nk1_io  in out nocopy  VARCHAR2
      ,games_nk2_io  in out nocopy  VARCHAR2
      ,name_io  in out nocopy  VARCHAR2
      ,ctype_id_io  in out nocopy  NUMBER
      ,card_types_nk1_io  in out nocopy  VARCHAR2
      ,card_types_nk2_io  in out nocopy  VARCHAR2
      );
   -- This function traps and returns any error message from the upd2 procedure
   function upd2
      (id_io  in out nocopy  NUMBER
      ,game_id_io  in out nocopy  NUMBER
      ,games_nk1_io  in out nocopy  VARCHAR2
      ,games_nk2_io  in out nocopy  VARCHAR2
      ,name_io  in out nocopy  VARCHAR2
      ,ctype_id_io  in out nocopy  NUMBER
      ,card_types_nk1_io  in out nocopy  VARCHAR2
      ,card_types_nk2_io  in out nocopy  VARCHAR2
      ) return varchar2;
   -- Update columns for cards Table
   --   with updated data returned in each column
   procedure upd2
      (id_io  in out nocopy  NUMBER
      ,game_id_io  in out nocopy  NUMBER
      ,name_io  in out nocopy  VARCHAR2
      ,ctype_id_io  in out nocopy  NUMBER
      );
   -- This function traps and returns any error message from the upd2 procedure
   function upd2
      (id_io  in out nocopy  NUMBER
      ,game_id_io  in out nocopy  NUMBER
      ,name_io  in out nocopy  VARCHAR2
      ,ctype_id_io  in out nocopy  NUMBER
      ) return varchar2;

   -- Application Delete procedure without updated parameters
   procedure del
      (id_in  in  NUMBER default null
      ,game_id_in  in  NUMBER default null
      ,games_nk1_in  in  VARCHAR2 default null
      ,games_nk2_in  in  VARCHAR2 default null
      ,name_in  in  VARCHAR2 default null
      );
   -- This function traps and returns any error message from the del procedure
   function del
      (id_in  in  NUMBER default null
      ,game_id_in  in  NUMBER default null
      ,games_nk1_in  in  VARCHAR2 default null
      ,games_nk2_in  in  VARCHAR2 default null
      ,name_in  in  VARCHAR2 default null
      ) return varchar2;
   -- Application Delete procedure with updated parameters
   procedure del2
      (id_io  in out nocopy  NUMBER
      ,game_id_in  in NUMBER default null
      ,games_nk1_in  in VARCHAR2 default null
      ,games_nk2_in  in VARCHAR2 default null
      ,name_in  in VARCHAR2 default null
      );
   -- This function traps and returns any error message from the del2 procedure
   function del2
      (id_io  in out nocopy  NUMBER
      ,game_id_in  in NUMBER default null
      ,games_nk1_in  in VARCHAR2 default null
      ,games_nk2_in  in VARCHAR2 default null
      ,name_in  in VARCHAR2 default null
      ) return varchar2;

   -- Special Data Warehouse Dimension Function
   --   Attempts to find matching record based on natural keys
   --   If found, performs updates on non-NK columns that changed
   --   If not found, inserts new record
   --   Returns ID of record
   procedure load_dim
      (dim_tab  in out nocopy  cards%ROWTYPE
      );
   -- This function traps and returns any error message from the load_dim procedure
   function load_dim
      (dim_tab  in out nocopy  cards%ROWTYPE
      ) return varchar2;

end cards_dml;
/
select 'CARDS_DML' as "Package:"
 from  user_errors
 where name  = 'CARDS_DML'
  and  type  = 'PACKAGE'
  and  rownum = 1
/
select '('||line||'/'||position||') '||text as error
 from  user_errors
 where name = 'CARDS_DML'
  and  type = 'PACKAGE'
 order by sequence
/

create package body cards_dml
is

 -- Package Body Cards_Dml
 -- (Data Manipulation Language, Foreign Key and Path Lookup)

   -- Application: Clue Notes For Oracle
   -- Generated by DTGen (http://dmstex.com/services/dtgen)
   -- December  16, 2013  11:32:31 AM

   --
   --
   -- © Duane.Dieterich@DMSTEX.com 2013
   --
   -- All Rights Reserved
   --
   -- No part of this software may be reproduced, copied, modified or adapted,
   -- without the prior written consent of the author, unless otherwise
   -- indicated for stand-alone materials.
   --
   -- You may quote extracts from this software with attribution to
   -- Duane.Dieterich@DMSTEX.com
   --
   -- For any other mode of sharing, please contact Duane.Dieterich@DMSTEX.com.
   --
   -- Commercial use and distribution of this software is not allowed without
   -- express and prior written consent of the author.
   --
   -- THE SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
   -- INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY
   -- AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL
   -- THE COPYRIGHT HOLDER OR DMSTEX BUSINESS SOLUTIONS LLC, ITS MEMBERS,
   -- MANAGERS, OR EMPLOYEES BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
   -- SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
   -- TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
   -- PROFITS; CORRUPTION OF DATA, OR BUSINESS INTERRUPTION) HOWEVER CAUSED
   -- AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
   -- OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF
   -- THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH
   -- DAMAGE.
   --
   --


----------------------------------------
function get_next_id
      return NUMBER
is
   retid  NUMBER;
begin
   select cards_seq.nextval
    into  retid from dual;
   return retid;
end get_next_id;
----------------------------------------
function get_curr_id
      return NUMBER
is
   retid  NUMBER;
begin
   select cards_seq.currval
    into  retid from dual;
   return retid;
end get_curr_id;
----------------------------------------
function get_id
      (games_nk1  in  VARCHAR2
      ,games_nk2  in  VARCHAR2
      ,name  in  VARCHAR2
      ) return number
   -- For all the Natural Key Columns, Return an ID
is
begin
   return cards_tab.get_id
      (games_nk1
      ,games_nk2
      ,name
      );
end get_id;
----------------------------------------
-- For all the Natural Key Column IDs, Return an ID
function get_id2
      (game_id_in  in  NUMBER
      ,name_in  in  VARCHAR2
      ) return NUMBER
is
   retid  NUMBER(38);
begin
   select id
    into  retid
    from  cards  CRD
    where game_id_in = CRD.game_id
     and  name_in = CRD.name
    ;
   return retid;
exception when no_data_found then return null;
end get_id2;
----------------------------------------
function get_nk
      (id_in  in  NUMBER)
   return VARCHAR2
   -- For an ID, return a delimited list of Natural Key Values
is
begin
   return cards_tab.get_nk(id_in);
end get_nk;
----------------------------------------
procedure clear
      (n_rec  in out nocopy  cards_act%ROWTYPE
      )
is
begin
   n_rec.id := null;
   n_rec.game_id := null;
   n_rec.games_nk1 := null;
   n_rec.games_nk2 := null;
   n_rec.name := null;
   n_rec.ctype_id := null;
   n_rec.card_types_nk1 := null;
   n_rec.card_types_nk2 := null;
end clear;
----------
function clear
      (n_rec  in out nocopy  cards_act%ROWTYPE
      ) return varchar2
is
begin
   clear(n_rec);
   return '';
exception when others then return sqlerrm;
end clear;
----------------------------------------
procedure clear
      (n_tab  in out nocopy  cards%ROWTYPE
      )
is
begin
   n_tab.id := null;
   n_tab.game_id := null;
   n_tab.name := null;
   n_tab.ctype_id := null;
end clear;
----------
function clear
      (n_tab  in out nocopy  cards%ROWTYPE
      ) return varchar2
is
begin
   clear(n_tab);
   return '';
exception when others then return sqlerrm;
end clear;
----------------------------------------
procedure get_rec_by_id
      (n_rec  in out nocopy  cards_act%ROWTYPE
      )
is
   start_tstamp  timestamp := systimestamp;
begin
   if n_rec.id is null then
      clear(n_rec);
   else
      select * into n_rec from cards_act
       where id = n_rec.id;
   end if;
   return;
   util.trc_time_interval('cards_dml.get_rec_by_id(act rec) ID:' || n_rec.id, start_tstamp);
end get_rec_by_id;
----------
function get_rec_by_id
      (n_rec  in out nocopy  cards_act%ROWTYPE
      ) return varchar2
is
begin
   get_rec_by_id(n_rec);
   return '';
exception when others then return sqlerrm;
end get_rec_by_id;
----------------------------------------
procedure get_rec_by_id
      (n_tab  in out nocopy  cards%ROWTYPE
      )
is
   start_tstamp  timestamp := systimestamp;
begin
   if n_tab.id is null then
      clear(n_tab);
   else
      select * into n_tab from cards
       where id = n_tab.id;
   end if;
   return;
   util.trc_time_interval('cards_dml.get_rec_by_id(tab rec) ID:' || n_tab.id, start_tstamp);
end get_rec_by_id;
----------
function get_rec_by_id
      (n_tab  in out nocopy  cards%ROWTYPE
      ) return varchar2
is
begin
   get_rec_by_id(n_tab);
   return '';
exception when others then return sqlerrm;
end get_rec_by_id;
----------------------------------------
-- Insert a cards ACTIVE View Record
procedure ins
      (new_rec  in out nocopy  cards_act%ROWTYPE
      ,upd_vals_in  in  boolean default TRUE
      )
is
   new_tab  cards%ROWTYPE;
   start_tstamp  timestamp := systimestamp;
begin
   -- Set new_rec.game_id, if needed
   if new_rec.game_id is null then
      if    new_rec.games_nk1 is not null
        and new_rec.games_nk2 is not null
      then
         new_rec.game_id := games_tab.get_id
            (new_rec.games_nk1
            ,new_rec.games_nk2
            );
         if new_rec.game_id is null then
            raise_application_error(-20020, 'Null ID was returned from games_tab.get_id');
         end if;
      end if;
   end if;
   -- Set new_rec.ctype_id, if needed
   if new_rec.ctype_id is null then
      if    new_rec.card_types_nk1 is not null
        and new_rec.card_types_nk2 is not null
      then
         new_rec.ctype_id := card_types_tab.get_id
            (new_rec.card_types_nk1
            ,new_rec.card_types_nk2
            );
         if new_rec.ctype_id is null then
            raise_application_error(-20020, 'Null ID was returned from card_types_tab.get_id');
         end if;
      end if;
   end if;
   new_tab.id := new_rec.id;
   new_tab.game_id := new_rec.game_id;
   new_tab.name := new_rec.name;
   new_tab.ctype_id := new_rec.ctype_id;
   cards_tab.ins(new_tab);
   if upd_vals_in then
      -- cards_tab.ins returns a new ID, if needed
      select * into new_rec from cards_act
       where id = new_tab.id;
   end if;
   return;
   util.trc_time_interval('cards_dml.ins(act rec) ID:' || new_rec.id, start_tstamp);
end ins;
----------
function ins
      (new_rec  in out nocopy  cards_act%ROWTYPE
      ,upd_vals_in  in  boolean default TRUE
      ) return varchar2
is
begin
   ins(new_rec, upd_vals_in);
   return '';
exception when others then return sqlerrm;
end ins;
----------------------------------------
-- Insert a cards Table Record
procedure ins
      (new_tab   in out nocopy  cards%ROWTYPE
      )
is
   start_tstamp  timestamp := systimestamp;
begin
   cards_tab.ins(new_tab);
   return;
   util.trc_time_interval('cards_dml.ins(tab rec) ID:' || new_tab.id, start_tstamp);
end ins;
----------
function ins
      (new_tab   in out nocopy  cards%ROWTYPE
      ) return varchar2
is
begin
   ins(new_tab);
   return '';
exception when others then return sqlerrm;
end ins;
----------------------------------------
-- Insert columns for cards ACTIVE View
--   without returning updated data in each column
procedure ins
      (id_in  in  NUMBER default null
      ,game_id_in  in  NUMBER default null
      ,games_nk1_in  in  VARCHAR2 default null
      ,games_nk2_in  in  VARCHAR2 default null
      ,name_in  in  VARCHAR2 default null
      ,ctype_id_in  in  NUMBER default null
      ,card_types_nk1_in  in  VARCHAR2 default null
      ,card_types_nk2_in  in  VARCHAR2 default null
      )
is
   new_rec  cards_act%ROWTYPE;
   start_tstamp  timestamp := systimestamp;
begin
   new_rec.id := id_in;
   new_rec.game_id := game_id_in;
   new_rec.games_nk1 := games_nk1_in;
   new_rec.games_nk2 := games_nk2_in;
   new_rec.name := name_in;
   new_rec.ctype_id := ctype_id_in;
   new_rec.card_types_nk1 := card_types_nk1_in;
   new_rec.card_types_nk2 := card_types_nk2_in;
   ins(new_rec, FALSE);
   return;
   util.trc_time_interval('cards_dml.ins(tab col) ID:' || id_in, start_tstamp);
end ins;
----------
function ins
      (id_in  in  NUMBER default null
      ,game_id_in  in  NUMBER default null
      ,games_nk1_in  in  VARCHAR2 default null
      ,games_nk2_in  in  VARCHAR2 default null
      ,name_in  in  VARCHAR2 default null
      ,ctype_id_in  in  NUMBER default null
      ,card_types_nk1_in  in  VARCHAR2 default null
      ,card_types_nk2_in  in  VARCHAR2 default null
      ) return varchar2
is
begin
   ins
      (id_in
      ,game_id_in
      ,games_nk1_in
      ,games_nk2_in
      ,name_in
      ,ctype_id_in
      ,card_types_nk1_in
      ,card_types_nk2_in
      );
   return '';
exception when others then return sqlerrm;
end ins;
----------------------------------------
-- Insert columns for cards ACTIVE View
--   with updated data returned in each column
procedure ins2
      (id_io  in out nocopy  NUMBER
      ,game_id_io  in out nocopy  NUMBER
      ,games_nk1_io  in out nocopy  VARCHAR2
      ,games_nk2_io  in out nocopy  VARCHAR2
      ,name_io  in out nocopy  VARCHAR2
      ,ctype_id_io  in out nocopy  NUMBER
      ,card_types_nk1_io  in out nocopy  VARCHAR2
      ,card_types_nk2_io  in out nocopy  VARCHAR2
      )
is
   new_rec  cards_act%ROWTYPE;
   start_tstamp  timestamp := systimestamp;
begin
   new_rec.id := id_io;
   new_rec.game_id := game_id_io;
   new_rec.games_nk1 := games_nk1_io;
   new_rec.games_nk2 := games_nk2_io;
   new_rec.name := name_io;
   new_rec.ctype_id := ctype_id_io;
   new_rec.card_types_nk1 := card_types_nk1_io;
   new_rec.card_types_nk2 := card_types_nk2_io;
   --
   ins(new_rec);
   --
   id_io := new_rec.id;
   game_id_io := new_rec.game_id;
   games_nk1_io := new_rec.games_nk1;
   games_nk2_io := new_rec.games_nk2;
   name_io := new_rec.name;
   ctype_id_io := new_rec.ctype_id;
   card_types_nk1_io := new_rec.card_types_nk1;
   card_types_nk2_io := new_rec.card_types_nk2;
   return;
   util.trc_time_interval('cards_dml.ins2(tab col) ID:' || id_io, start_tstamp);
end ins2;
----------
function ins2
      (id_io  in out nocopy  NUMBER
      ,game_id_io  in out nocopy  NUMBER
      ,games_nk1_io  in out nocopy  VARCHAR2
      ,games_nk2_io  in out nocopy  VARCHAR2
      ,name_io  in out nocopy  VARCHAR2
      ,ctype_id_io  in out nocopy  NUMBER
      ,card_types_nk1_io  in out nocopy  VARCHAR2
      ,card_types_nk2_io  in out nocopy  VARCHAR2
      ) return varchar2
is
begin
   ins2
      (id_io
      ,game_id_io
      ,games_nk1_io
      ,games_nk2_io
      ,name_io
      ,ctype_id_io
      ,card_types_nk1_io
      ,card_types_nk2_io
      );
   return '';
exception when others then return sqlerrm;
end ins2;
----------------------------------------
-- Insert columns for cards Table
--   with updated data returned in each column
procedure ins2
      (id_io  in out nocopy  NUMBER
      ,game_id_io  in out nocopy  NUMBER
      ,name_io  in out nocopy  VARCHAR2
      ,ctype_id_io  in out nocopy  NUMBER
      )
is
   new_rec  cards%ROWTYPE;
   start_tstamp  timestamp := systimestamp;
begin
   new_rec.id := id_io;
   new_rec.game_id := game_id_io;
   new_rec.name := name_io;
   new_rec.ctype_id := ctype_id_io;
   --
   cards_tab.ins(new_rec);
   --
   id_io := new_rec.id;
   game_id_io := new_rec.game_id;
   name_io := new_rec.name;
   ctype_id_io := new_rec.ctype_id;
   return;
   util.trc_time_interval('cards_dml.ins2(tab col) ID:' || id_io, start_tstamp);
end ins2;
----------
function ins2
      (id_io  in out nocopy  NUMBER
      ,game_id_io  in out nocopy  NUMBER
      ,name_io  in out nocopy  VARCHAR2
      ,ctype_id_io  in out nocopy  NUMBER
      ) return varchar2
is
begin
   ins2
      (id_io
      ,game_id_io
      ,name_io
      ,ctype_id_io
      );
   return '';
exception when others then return sqlerrm;
end ins2;
----------------------------------------
-- Special Use Update for Specific Column Updates.
--   Only differences between old and new data will be updated.
--   Set upd_val_in TRUE to get updated data in new_rec
procedure upd
      (old_rec  in  cards_act%ROWTYPE
      ,new_rec  in out nocopy  cards_act%ROWTYPE
      ,upd_vals_in  in  boolean default FALSE
      )
is
   old_tab  cards%ROWTYPE;
   new_tab  cards%ROWTYPE;
   start_tstamp  timestamp := systimestamp;
begin
   if old_rec.id is null then
      raise_application_error (-20023, 'ID is null');
   end if;
   -- Set new_rec.game_id, if needed
   if new_rec.game_id is null then
      if    new_rec.games_nk1 is not null
        and new_rec.games_nk2 is not null
      then
         new_rec.game_id := games_tab.get_id
            (new_rec.games_nk1
            ,new_rec.games_nk2
            );
         if new_rec.game_id is null then
            raise_application_error(-20020, 'Null ID was returned from games_tab.get_id');
         end if;
      end if;
   end if;
   -- Set new_rec.ctype_id, if needed
   if new_rec.ctype_id is null then
      if    new_rec.card_types_nk1 is not null
        and new_rec.card_types_nk2 is not null
      then
         new_rec.ctype_id := card_types_tab.get_id
            (new_rec.card_types_nk1
            ,new_rec.card_types_nk2
            );
         if new_rec.ctype_id is null then
            raise_application_error(-20020, 'Null ID was returned from card_types_tab.get_id');
         end if;
      end if;
   end if;
   -- Set new_rec.game_id, if needed
   if new_rec.game_id = old_rec.game_id then
      if    not (new_rec.games_nk1 = old_rec.games_nk1)
        or  not (new_rec.games_nk2 = old_rec.games_nk2)
      then
         new_rec.game_id := games_tab.get_id
            (new_rec.games_nk1
            ,new_rec.games_nk2
            );
         if new_rec.game_id is null then
            raise_application_error(-20020, 'Null ID was returned from games_tab.get_id');
         end if;
      end if;
   end if;
   -- Set new_rec.ctype_id, if needed
   if new_rec.ctype_id = old_rec.ctype_id then
      if    not (new_rec.card_types_nk1 = old_rec.card_types_nk1)
        or  not (new_rec.card_types_nk2 = old_rec.card_types_nk2)
      then
         new_rec.ctype_id := card_types_tab.get_id
            (new_rec.card_types_nk1
            ,new_rec.card_types_nk2
            );
         if new_rec.ctype_id is null then
            raise_application_error(-20020, 'Null ID was returned from card_types_tab.get_id');
         end if;
      end if;
   end if;
   -- Load the Table Record from the View Record
   old_tab.id := old_rec.id;
   new_tab.id := new_rec.id;
   old_tab.game_id := old_rec.game_id;
   new_tab.game_id := new_rec.game_id;
   old_tab.name := old_rec.name;
   new_tab.name := new_rec.name;
   old_tab.ctype_id := old_rec.ctype_id;
   new_tab.ctype_id := new_rec.ctype_id;
   -- Run the update
   cards_tab.upd(old_tab, new_tab);
   if upd_vals_in then
      -- Load the View Record from the Returned (new) Table Record
      -- cards_tab.upd should have set new ID = old ID
      select * into new_rec from cards_act
       where id = old_tab.id;
   end if;
   return;
   util.trc_time_interval('cards_dml.upd(trigger) ID:' || old_tab.id, start_tstamp);
end upd;
----------
function upd
      (old_rec  in  cards_act%ROWTYPE
      ,new_rec  in out nocopy  cards_act%ROWTYPE
      ,upd_vals_in  in  boolean default FALSE
      ) return varchar2
is
begin
   upd(old_rec, new_rec, upd_vals_in);
   return '';
exception when others then return sqlerrm;
end upd;
----------------------------------------
-- Special Use Update for Specific Column Updates.
--   Only differences between old and new data will be updated.
--   Set upd_val_in TRUE to get updated data in new_rec
procedure upd
      (old_tab  in  cards%ROWTYPE
      ,new_tab  in out nocopy  cards%ROWTYPE
      )
is
   start_tstamp  timestamp := systimestamp;
begin
   if old_tab.id is null then
      raise_application_error (-20023, 'ID is null');
   end if;
   -- Run the update
   cards_tab.upd(old_tab, new_tab);
   return;
   util.trc_time_interval('cards_dml.upd(trigger) ID:' || old_tab.id, start_tstamp);
end upd;
----------
function upd
      (old_tab  in  cards%ROWTYPE
      ,new_tab  in out nocopy  cards%ROWTYPE
      ) return varchar2
is
begin
   upd(old_tab, new_tab);
   return '';
exception when others then return sqlerrm;
end upd;
----------------------------------------
-- Update a cards ACTIVE View Record
procedure upd
      (new_rec  in out nocopy  cards_act%ROWTYPE
      ,upd_vals_in  in  boolean default TRUE
      )
is
   old_rec  cards_act%ROWTYPE;
   start_tstamp  timestamp := systimestamp;
begin
   if new_rec.id is null then
      if    new_rec.games_nk1 is not null
        and new_rec.games_nk2 is not null
        and new_rec.name is not null
      then
         new_rec.id := cards_tab.get_id
            (new_rec.games_nk1
            ,new_rec.games_nk2
            ,new_rec.name
            );
      end if;
   end if;
   if new_rec.id is null then
      if    new_rec.game_id is not null
        and new_rec.name is not null
      then
         begin
            select id into new_rec.id from cards
             where game_id = new_rec.game_id
              and  name = new_rec.name
               ;
         exception when NO_DATA_FOUND then new_rec.id := null;
         end;
      end if;
   end if;
   if new_rec.id is null then
      raise_application_error (-20023, 'ID is null and could not be found from Natural Keys');
   end if;
   select * into old_rec from cards_act
    where id = new_rec.id;
   upd(old_rec, new_rec, upd_vals_in);
   return;
   util.trc_time_interval('cards_dml.upd(act rec) ID:' || new_rec.id, start_tstamp);
end upd;
----------
function upd
      (new_rec  in out nocopy  cards_act%ROWTYPE
      ,upd_vals_in  in  boolean default TRUE
      ) return varchar2
is
begin
   upd(new_rec, upd_vals_in);
   return '';
exception when others then return sqlerrm;
end upd;
----------------------------------------
-- Update a cards Table Record
procedure upd
      (new_tab   in out nocopy  cards%ROWTYPE
      )
is
   start_tstamp  timestamp := systimestamp;
begin
   if new_tab.id is null then
      if    new_tab.game_id is not null
        and new_tab.name is not null
      then
         begin
            select id into new_tab.id from cards
             where game_id = new_tab.game_id
              and  name = new_tab.name
               ;
         exception when NO_DATA_FOUND then new_tab.id := null;
         end;
      end if;
   end if;
   if new_tab.id is null then
      raise_application_error (-20023, 'ID is null and could not be found from Natural Keys');
   end if;
   cards_tab.upd(new_tab);
   return;
   util.trc_time_interval('cards_dml.upd(tab rec) ID:' || new_tab.id, start_tstamp);
end upd;
----------
function upd
      (new_tab   in out nocopy  cards%ROWTYPE
      ) return varchar2
is
begin
   upd(new_tab);
   return '';
exception when others then return sqlerrm;
end upd;
----------------------------------------
-- Update columns for cards ACTIVE View
--   without returning updated data in each column
procedure upd
      (id_in  in  NUMBER default null
      ,game_id_in  in  NUMBER default null
      ,games_nk1_in  in  VARCHAR2 default null
      ,games_nk2_in  in  VARCHAR2 default null
      ,name_in  in  VARCHAR2 default null
      ,ctype_id_in  in  NUMBER default null
      ,card_types_nk1_in  in  VARCHAR2 default null
      ,card_types_nk2_in  in  VARCHAR2 default null
      )
is
   new_rec  cards_act%ROWTYPE;
   start_tstamp  timestamp := systimestamp;
begin
   new_rec.id := id_in;
   new_rec.game_id := game_id_in;
   new_rec.games_nk1 := games_nk1_in;
   new_rec.games_nk2 := games_nk2_in;
   new_rec.name := name_in;
   new_rec.ctype_id := ctype_id_in;
   new_rec.card_types_nk1 := card_types_nk1_in;
   new_rec.card_types_nk2 := card_types_nk2_in;
   -- Make corrections when ID is supplied, but NK is missing
   if    new_rec.ID is not null
     and new_rec.games_nk1 is null
     and new_rec.games_nk2 is null
     and new_rec.name is null
   then
      select CRD.games_nk1
            ,CRD.games_nk2
            ,CRD.name
       into  new_rec.games_nk1
            ,new_rec.games_nk2
            ,new_rec.name
       from  cards_act  CRD
       where CRD.id = new_rec.ID;
   end if;
   -- Make corrections when game_id is supplied, but the Natural Key is missing
   if    new_rec.game_id is not null
     and new_rec.games_nk1 is null
     and new_rec.games_nk2 is null
   then
      select GAM.users_nk1
            ,GAM.name
       into  new_rec.games_nk1
            ,new_rec.games_nk2
       from  games_act  GAM
       where GAM.id = new_rec.game_id;
   end if;
   -- Make corrections when ctype_id is supplied, but the Natural Key is missing
   if    new_rec.ctype_id is not null
     and new_rec.card_types_nk1 is null
     and new_rec.card_types_nk2 is null
   then
      select CTYPE.users_nk1
            ,CTYPE.name
       into  new_rec.card_types_nk1
            ,new_rec.card_types_nk2
       from  card_types_act  CTYPE
       where CTYPE.id = new_rec.ctype_id;
   end if;
   upd(new_rec, FALSE);
   return;
   util.trc_time_interval('cards_dml.upd(act col) ID:' || id_in, start_tstamp);
end upd;
----------
function upd
      (id_in  in  NUMBER default null
      ,game_id_in  in  NUMBER default null
      ,games_nk1_in  in  VARCHAR2 default null
      ,games_nk2_in  in  VARCHAR2 default null
      ,name_in  in  VARCHAR2 default null
      ,ctype_id_in  in  NUMBER default null
      ,card_types_nk1_in  in  VARCHAR2 default null
      ,card_types_nk2_in  in  VARCHAR2 default null
      ) return varchar2
is
begin
   upd
      (id_in
      ,game_id_in
      ,games_nk1_in
      ,games_nk2_in
      ,name_in
      ,ctype_id_in
      ,card_types_nk1_in
      ,card_types_nk2_in
      );
   return '';
exception when others then return sqlerrm;
end upd;
----------------------------------------
-- Update columns for cards ACTIVE View
--   with updated data returned in each column
procedure upd2
      (id_io  in out nocopy  NUMBER
      ,game_id_io  in out nocopy  NUMBER
      ,games_nk1_io  in out nocopy  VARCHAR2
      ,games_nk2_io  in out nocopy  VARCHAR2
      ,name_io  in out nocopy  VARCHAR2
      ,ctype_id_io  in out nocopy  NUMBER
      ,card_types_nk1_io  in out nocopy  VARCHAR2
      ,card_types_nk2_io  in out nocopy  VARCHAR2
      )
is
   new_rec  cards_act%ROWTYPE;
   start_tstamp  timestamp := systimestamp;
begin
   new_rec.id := id_io;
   new_rec.game_id := game_id_io;
   new_rec.games_nk1 := games_nk1_io;
   new_rec.games_nk2 := games_nk2_io;
   new_rec.name := name_io;
   new_rec.ctype_id := ctype_id_io;
   new_rec.card_types_nk1 := card_types_nk1_io;
   new_rec.card_types_nk2 := card_types_nk2_io;
   --
   --  upd(new_rec) will set new_rec.id as needed
   upd(new_rec);
   --
   id_io := new_rec.id;
   game_id_io := new_rec.game_id;
   games_nk1_io := new_rec.games_nk1;
   games_nk2_io := new_rec.games_nk2;
   name_io := new_rec.name;
   ctype_id_io := new_rec.ctype_id;
   card_types_nk1_io := new_rec.card_types_nk1;
   card_types_nk2_io := new_rec.card_types_nk2;
   return;
   util.trc_time_interval('cards_dml.upd2(act col) ID:' || id_io, start_tstamp);
end upd2;
----------
function upd2
      (id_io  in out nocopy  NUMBER
      ,game_id_io  in out nocopy  NUMBER
      ,games_nk1_io  in out nocopy  VARCHAR2
      ,games_nk2_io  in out nocopy  VARCHAR2
      ,name_io  in out nocopy  VARCHAR2
      ,ctype_id_io  in out nocopy  NUMBER
      ,card_types_nk1_io  in out nocopy  VARCHAR2
      ,card_types_nk2_io  in out nocopy  VARCHAR2
      ) return varchar2
is
begin
   upd2
      (id_io
      ,game_id_io
      ,games_nk1_io
      ,games_nk2_io
      ,name_io
      ,ctype_id_io
      ,card_types_nk1_io
      ,card_types_nk2_io
      );
   return '';
exception when others then return sqlerrm;
end upd2;
----------------------------------------
-- Update columns for cards Table
--   with updated data returned in each column
procedure upd2
      (id_io  in out nocopy  NUMBER
      ,game_id_io  in out nocopy  NUMBER
      ,name_io  in out nocopy  VARCHAR2
      ,ctype_id_io  in out nocopy  NUMBER
      )
is
   new_rec  cards%ROWTYPE;
   start_tstamp  timestamp := systimestamp;
begin
   if id_io is null then
      if    game_id_io is not null
        and name_io is not null
      then
         begin
            select id into id_io from cards
             where game_id = game_id_io
              and  name = name_io
               ;
         exception when NO_DATA_FOUND then id_io := null;
         end;
      end if;
   end if;
   if id_io is null then
      raise_application_error (-20023, 'ID is null and could not be found from Natural Keys');
   end if;
   new_rec.id := id_io;
   new_rec.game_id := game_id_io;
   new_rec.name := name_io;
   new_rec.ctype_id := ctype_id_io;
   --
   cards_tab.upd(new_rec);
   --
   id_io := new_rec.id;
   game_id_io := new_rec.game_id;
   name_io := new_rec.name;
   ctype_id_io := new_rec.ctype_id;
   return;
   util.trc_time_interval('cards_dml.upd2(tab col) ID:' || id_io, start_tstamp);
end upd2;
----------
function upd2
      (id_io  in out nocopy  NUMBER
      ,game_id_io  in out nocopy  NUMBER
      ,name_io  in out nocopy  VARCHAR2
      ,ctype_id_io  in out nocopy  NUMBER
      ) return varchar2
is
begin
    upd2
      (id_io
      ,game_id_io
      ,name_io
      ,ctype_id_io
      );
   return '';
exception when others then return sqlerrm;
end upd2;

----------------------------------------
-- Application Delete procedure without updated parameters
procedure del
      (id_in  in  NUMBER default null
      ,game_id_in  in  NUMBER default null
      ,games_nk1_in  in  VARCHAR2 default null
      ,games_nk2_in  in  VARCHAR2 default null
      ,name_in  in  VARCHAR2 default null
      )
is
   start_tstamp  timestamp := systimestamp;
   tmp_id  NUMBER;
begin
   tmp_id := id_in;
   if tmp_id is null then
      if    games_nk1_in is not null
        and games_nk2_in is not null
        and name_in is not null
      then
         tmp_id := cards_tab.get_id
            (games_nk1_in
            ,games_nk2_in
            ,name_in
            );
      end if;
   end if;
   if tmp_id is null then
      if    game_id_in is not null
        and name_in is not null
      then
         begin
            select id into tmp_id from cards
             where game_id = game_id_in
              and  name = name_in
               ;
         exception when NO_DATA_FOUND then tmp_id := null;
         end;
      end if;
   end if;
   if tmp_id is null then
      raise_application_error (-20023, 'ID is null and could not be found from Natural Keys');
   end if;
   cards_tab.del(tmp_id);
   return;
   util.trc_time_interval('cards_dml.del ID:' || id_in, start_tstamp);
end del;
----------
function del
      (id_in  in  NUMBER default null
      ,game_id_in  in  NUMBER default null
      ,games_nk1_in  in  VARCHAR2 default null
      ,games_nk2_in  in  VARCHAR2 default null
      ,name_in  in  VARCHAR2 default null
      ) return varchar2
is
begin
   del
      (id_in
      ,game_id_in
      ,games_nk1_in
      ,games_nk2_in
      ,name_in
      );
   return '';
exception when others then return sqlerrm;
end del;
----------------------------------------
-- Application Delete procedure with updated parameters
procedure del2
      (id_io  in out nocopy  NUMBER
      ,game_id_in  in  NUMBER default null
      ,games_nk1_in  in  VARCHAR2 default null
      ,games_nk2_in  in  VARCHAR2 default null
      ,name_in  in  VARCHAR2 default null
      )
is
   start_tstamp  timestamp := systimestamp;
begin
   if id_io is null then
      if    games_nk1_in is not null
        and games_nk2_in is not null
        and name_in is not null
      then
         id_io := cards_tab.get_id
            (games_nk1_in
            ,games_nk2_in
            ,name_in
            );
      end if;
   end if;
   if id_io is null then
      if    game_id_in is not null
        and name_in is not null
      then
         begin
            select id into id_io from cards
             where game_id = game_id_in
              and  name = name_in
               ;
         exception when NO_DATA_FOUND then id_io := null;
         end;
      end if;
   end if;
   if id_io is null then
      raise_application_error (-20023, 'ID is null and could not be found from Natural Keys');
   end if;
   cards_tab.del(id_io);
   return;
   util.trc_time_interval('cards_dml.del2 ID:' || id_io, start_tstamp);
end del2;
----------
function del2
      (id_io  in out nocopy  NUMBER
      ,game_id_in  in  NUMBER default null
      ,games_nk1_in  in  VARCHAR2 default null
      ,games_nk2_in  in  VARCHAR2 default null
      ,name_in  in  VARCHAR2 default null
      ) return varchar2
is
begin
   del2
      (id_io
      ,game_id_in
      ,games_nk1_in
      ,games_nk2_in
      ,name_in
      );
   return '';
exception when others then return sqlerrm;
end del2;
----------------------------------------
procedure load_dim
      (dim_tab  in out nocopy  cards%ROWTYPE
      )
is
   -- Special Data Warehouse Dimension Function
   start_tstamp  timestamp := systimestamp;
   procedure private_upd is
      saved_inc  boolean := util.get_ignore_no_change;
   begin
      util.set_ignore_no_change(TRUE);
      upd (dim_tab);
      util.set_ignore_no_change(saved_inc);
   exception
      when others then
         util.set_ignore_no_change(saved_inc);
         raise;
   end private_upd;
begin
   -- Attempt to find matching record based on natural keys
   if dim_tab.id is null then
      begin
         select id
          into  dim_tab.id
          from  cards
          where game_id = dim_tab.game_id
           and  game_id = dim_tab.game_id
           and  name = dim_tab.name
         ;
      exception
         when NO_DATA_FOUND then dim_tab.id := null;
      end;
   end if;
   if dim_tab.id is not null then
      -- If found, perform update on non-NK columns that changed
      private_upd;
      return;
      util.trc_time_interval('cards_dml.load_dimE ID:' || dim_tab.id, start_tstamp);
   end if;
   -- If not found, insert new record
   begin
      ins(dim_tab);
   exception
      when DUP_VAL_ON_INDEX then
         -- Since this can run multi-threaded, another thread
         --   may have already populated this value.
         private_upd;
   end;
   return;
   util.trc_time_interval('cards_dml.load_dim ID:' || dim_tab.id, start_tstamp);
end load_dim;
----------
function load_dim
      (dim_tab  in out nocopy  cards%ROWTYPE
      ) return varchar2
is
begin
   load_dim(dim_tab);
   return '';
exception when others then return sqlerrm;
end load_dim;
----------------------------------------
end cards_dml;
/
select 'CARDS_DML' as "Package Body:"
 from  user_errors
 where name  = 'CARDS_DML'
  and  type  = 'PACKAGE BODY'
  and  rownum = 1
/
select '('||line||'/'||position||') '||text as error
 from  user_errors
 where name = 'CARDS_DML'
  and  type = 'PACKAGE BODY'
 order by sequence
/

create TRIGGER cards_act_ioi
   instead of insert on cards_act
   for each row
declare

   -- Trigger Cards_Act_Ioi

   -- Application: Clue Notes For Oracle
   -- Generated by DTGen (http://dmstex.com/services/dtgen)
   -- December  16, 2013  11:32:31 AM

   --
   --
   -- © Duane.Dieterich@DMSTEX.com 2013
   --
   -- All Rights Reserved
   --
   -- No part of this software may be reproduced, copied, modified or adapted,
   -- without the prior written consent of the author, unless otherwise
   -- indicated for stand-alone materials.
   --
   -- You may quote extracts from this software with attribution to
   -- Duane.Dieterich@DMSTEX.com
   --
   -- For any other mode of sharing, please contact Duane.Dieterich@DMSTEX.com.
   --
   -- Commercial use and distribution of this software is not allowed without
   -- express and prior written consent of the author.
   --
   -- THE SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
   -- INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY
   -- AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL
   -- THE COPYRIGHT HOLDER OR DMSTEX BUSINESS SOLUTIONS LLC, ITS MEMBERS,
   -- MANAGERS, OR EMPLOYEES BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
   -- SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
   -- TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
   -- PROFITS; CORRUPTION OF DATA, OR BUSINESS INTERRUPTION) HOWEVER CAUSED
   -- AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
   -- OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF
   -- THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH
   -- DAMAGE.
   --
   --


   new_rec  cards_act%ROWTYPE;
   start_tstamp  timestamp := systimestamp;
begin
   new_rec.id := :new.id;
   new_rec.game_id := :new.game_id;
   new_rec.games_nk1 := :new.games_nk1;
   new_rec.games_nk2 := :new.games_nk2;
   new_rec.name := :new.name;
   new_rec.ctype_id := :new.ctype_id;
   new_rec.card_types_nk1 := :new.card_types_nk1;
   new_rec.card_types_nk2 := :new.card_types_nk2;
   cards_dml.ins(new_rec, FALSE);
   util.trc_time_interval('cards_act_ioi trigger ID:' || :new.id, start_tstamp);
end cards_act_ioi;
/
select 'CARDS_ACT_IOI' as "Trigger:"
 from  user_errors
 where name  = 'CARDS_ACT_IOI'
  and  type  = 'TRIGGER'
  and  rownum = 1
/
select '('||line||'/'||position||') '||text as error
 from  user_errors
 where name = 'CARDS_ACT_IOI'
  and  type = 'TRIGGER'
 order by sequence
/

create TRIGGER cards_act_iou
   instead of update on cards_act
   for each row
declare

   -- Trigger Cards_Act_Iou

   -- Application: Clue Notes For Oracle
   -- Generated by DTGen (http://dmstex.com/services/dtgen)
   -- December  16, 2013  11:32:31 AM

   --
   --
   -- © Duane.Dieterich@DMSTEX.com 2013
   --
   -- All Rights Reserved
   --
   -- No part of this software may be reproduced, copied, modified or adapted,
   -- without the prior written consent of the author, unless otherwise
   -- indicated for stand-alone materials.
   --
   -- You may quote extracts from this software with attribution to
   -- Duane.Dieterich@DMSTEX.com
   --
   -- For any other mode of sharing, please contact Duane.Dieterich@DMSTEX.com.
   --
   -- Commercial use and distribution of this software is not allowed without
   -- express and prior written consent of the author.
   --
   -- THE SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
   -- INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY
   -- AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL
   -- THE COPYRIGHT HOLDER OR DMSTEX BUSINESS SOLUTIONS LLC, ITS MEMBERS,
   -- MANAGERS, OR EMPLOYEES BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
   -- SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
   -- TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
   -- PROFITS; CORRUPTION OF DATA, OR BUSINESS INTERRUPTION) HOWEVER CAUSED
   -- AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
   -- OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF
   -- THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH
   -- DAMAGE.
   --
   --


   old_rec  cards_act%ROWTYPE;
   new_rec  cards_act%ROWTYPE;
   start_tstamp  timestamp := systimestamp;
begin
   -- NOTE: Column Specified Update DML works without this lock
   --select btab.id into new_rec.id from cards btab
   -- where btab.id = :old.id for update;
   old_rec.id := :old.id;
   new_rec.id := :new.id;
   old_rec.game_id := :old.game_id;
   new_rec.game_id := :new.game_id;
   old_rec.games_nk1 := :old.games_nk1;
   new_rec.games_nk1 := :new.games_nk1;
   old_rec.games_nk2 := :old.games_nk2;
   new_rec.games_nk2 := :new.games_nk2;
   old_rec.name := :old.name;
   new_rec.name := :new.name;
   old_rec.ctype_id := :old.ctype_id;
   new_rec.ctype_id := :new.ctype_id;
   old_rec.card_types_nk1 := :old.card_types_nk1;
   new_rec.card_types_nk1 := :new.card_types_nk1;
   old_rec.card_types_nk2 := :old.card_types_nk2;
   new_rec.card_types_nk2 := :new.card_types_nk2;
   cards_dml.upd(old_rec, new_rec);
   util.trc_time_interval('cards_act_iou trigger ID:' || :old.id, start_tstamp);
end cards_act_iou;
/
select 'CARDS_ACT_IOU' as "Trigger:"
 from  user_errors
 where name  = 'CARDS_ACT_IOU'
  and  type  = 'TRIGGER'
  and  rownum = 1
/
select '('||line||'/'||position||') '||text as error
 from  user_errors
 where name = 'CARDS_ACT_IOU'
  and  type = 'TRIGGER'
 order by sequence
/

create TRIGGER cards_act_iod
   instead of delete on cards_act
   for each row
declare

   -- Trigger Cards_Act_Iod

   -- Application: Clue Notes For Oracle
   -- Generated by DTGen (http://dmstex.com/services/dtgen)
   -- December  16, 2013  11:32:31 AM

   --
   --
   -- © Duane.Dieterich@DMSTEX.com 2013
   --
   -- All Rights Reserved
   --
   -- No part of this software may be reproduced, copied, modified or adapted,
   -- without the prior written consent of the author, unless otherwise
   -- indicated for stand-alone materials.
   --
   -- You may quote extracts from this software with attribution to
   -- Duane.Dieterich@DMSTEX.com
   --
   -- For any other mode of sharing, please contact Duane.Dieterich@DMSTEX.com.
   --
   -- Commercial use and distribution of this software is not allowed without
   -- express and prior written consent of the author.
   --
   -- THE SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
   -- INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY
   -- AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL
   -- THE COPYRIGHT HOLDER OR DMSTEX BUSINESS SOLUTIONS LLC, ITS MEMBERS,
   -- MANAGERS, OR EMPLOYEES BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
   -- SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
   -- TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
   -- PROFITS; CORRUPTION OF DATA, OR BUSINESS INTERRUPTION) HOWEVER CAUSED
   -- AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
   -- OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF
   -- THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH
   -- DAMAGE.
   --
   --


   start_tstamp  timestamp := systimestamp;
begin
   cards_tab.del(:old.id);
   util.trc_time_interval('cards_act_iod trigger ID:' || :old.id, start_tstamp);
end cards_act_iod;
/
select 'CARDS_ACT_IOD' as "Trigger:"
 from  user_errors
 where name  = 'CARDS_ACT_IOD'
  and  type  = 'TRIGGER'
  and  rownum = 1
/
select '('||line||'/'||position||') '||text as error
 from  user_errors
 where name = 'CARDS_ACT_IOD'
  and  type = 'TRIGGER'
 order by sequence
/


create view actions_a
      (id
      ,player_id
      ,players_nk1
      ,players_nk2
      ,players_nk3
      ,seq
      )
   as select
       ACT.id
      ,ACT.player_id
      ,PLY.games_nk1
      ,PLY.games_nk2
      ,PLY.name
      ,ACT.seq
 from             actions ACT
       inner join players_act PLY on PLY.id = ACT.player_id
/
select 'ACTIONS_A' as "View:"
 from  user_errors
 where name  = 'ACTIONS_A'
  and  type  = 'VIEW'
  and  rownum = 1
/
select '('||line||'/'||position||') '||text as error
 from  user_errors
 where name = 'ACTIONS_A'
  and  type = 'VIEW'
 order by sequence
/

comment on table actions_a is 'Natural Keys for Player''s Suggestions for each User''s Game'
/

comment on column actions_a.id is 'Surrogate Primary Key for these actions'
/
comment on column actions_a.player_id is 'Player that took this Action'
/
comment on column actions_a.players_nk1 is 'PLAYERS Natural Key 1: GAMES NK1: USERS NK1: Clue Notes User Name'
/
comment on column actions_a.players_nk2 is 'PLAYERS Natural Key 2: GAMES NK2: User''s Game Name'
/
comment on column actions_a.players_nk3 is 'PLAYERS Natural Key 3: Player''s Name'
/
comment on column actions_a.seq is 'Sequence Number for this Action'
/

alter view actions_a add constraint actions_a_pk
   primary key (id) disable
/

alter view actions_a add constraint actions_a_fk1
   foreign key (player_id) references players_act (id) disable
/

create trigger actions_a_ioi
   instead of insert on actions_a
   for each row
declare

   -- Trigger Actions_A_Ioi

   -- Application: Clue Notes For Oracle
   -- Generated by DTGen (http://dmstex.com/services/dtgen)
   -- December  16, 2013  11:32:31 AM

   --
   --
   -- © Duane.Dieterich@DMSTEX.com 2013
   --
   -- All Rights Reserved
   --
   -- No part of this software may be reproduced, copied, modified or adapted,
   -- without the prior written consent of the author, unless otherwise
   -- indicated for stand-alone materials.
   --
   -- You may quote extracts from this software with attribution to
   -- Duane.Dieterich@DMSTEX.com
   --
   -- For any other mode of sharing, please contact Duane.Dieterich@DMSTEX.com.
   --
   -- Commercial use and distribution of this software is not allowed without
   -- express and prior written consent of the author.
   --
   -- THE SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
   -- INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY
   -- AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL
   -- THE COPYRIGHT HOLDER OR DMSTEX BUSINESS SOLUTIONS LLC, ITS MEMBERS,
   -- MANAGERS, OR EMPLOYEES BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
   -- SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
   -- TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
   -- PROFITS; CORRUPTION OF DATA, OR BUSINESS INTERRUPTION) HOWEVER CAUSED
   -- AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
   -- OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF
   -- THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH
   -- DAMAGE.
   --
   --


begin
   -- util.log('Trigger actions_a_ioi');
   raise_application_error(-20001,
              'actions_a_ioi trigger: insert is not allowed on this view.');

end actions_a_ioi;
/
select 'ACTIONS_A_IOI' as "Trigger:"
 from  user_errors
 where name  = 'ACTIONS_A_IOI'
  and  type  = 'TRIGGER'
  and  rownum = 1
/
select '('||line||'/'||position||') '||text as error
 from  user_errors
 where name = 'ACTIONS_A_IOI'
  and  type = 'TRIGGER'
 order by sequence
/

create trigger actions_a_iou
   instead of update on actions_a
   for each row
declare

   -- Trigger Actions_A_Iou

   -- Application: Clue Notes For Oracle
   -- Generated by DTGen (http://dmstex.com/services/dtgen)
   -- December  16, 2013  11:32:31 AM

   --
   --
   -- © Duane.Dieterich@DMSTEX.com 2013
   --
   -- All Rights Reserved
   --
   -- No part of this software may be reproduced, copied, modified or adapted,
   -- without the prior written consent of the author, unless otherwise
   -- indicated for stand-alone materials.
   --
   -- You may quote extracts from this software with attribution to
   -- Duane.Dieterich@DMSTEX.com
   --
   -- For any other mode of sharing, please contact Duane.Dieterich@DMSTEX.com.
   --
   -- Commercial use and distribution of this software is not allowed without
   -- express and prior written consent of the author.
   --
   -- THE SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
   -- INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY
   -- AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL
   -- THE COPYRIGHT HOLDER OR DMSTEX BUSINESS SOLUTIONS LLC, ITS MEMBERS,
   -- MANAGERS, OR EMPLOYEES BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
   -- SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
   -- TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
   -- PROFITS; CORRUPTION OF DATA, OR BUSINESS INTERRUPTION) HOWEVER CAUSED
   -- AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
   -- OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF
   -- THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH
   -- DAMAGE.
   --
   --


begin
   -- util.log('Trigger actions_a_iou');
   raise_application_error(-20001,
              'actions_a_iou trigger: update is not allowed on this view.');

end actions_a_iou;
/
select 'ACTIONS_A_IOU' as "Trigger:"
 from  user_errors
 where name  = 'ACTIONS_A_IOU'
  and  type  = 'TRIGGER'
  and  rownum = 1
/
select '('||line||'/'||position||') '||text as error
 from  user_errors
 where name = 'ACTIONS_A_IOU'
  and  type = 'TRIGGER'
 order by sequence
/

create trigger actions_a_iod
   instead of delete on actions_a
   for each row
declare

   -- Trigger Actions_A_Iod

   -- Application: Clue Notes For Oracle
   -- Generated by DTGen (http://dmstex.com/services/dtgen)
   -- December  16, 2013  11:32:31 AM

   --
   --
   -- © Duane.Dieterich@DMSTEX.com 2013
   --
   -- All Rights Reserved
   --
   -- No part of this software may be reproduced, copied, modified or adapted,
   -- without the prior written consent of the author, unless otherwise
   -- indicated for stand-alone materials.
   --
   -- You may quote extracts from this software with attribution to
   -- Duane.Dieterich@DMSTEX.com
   --
   -- For any other mode of sharing, please contact Duane.Dieterich@DMSTEX.com.
   --
   -- Commercial use and distribution of this software is not allowed without
   -- express and prior written consent of the author.
   --
   -- THE SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
   -- INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY
   -- AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL
   -- THE COPYRIGHT HOLDER OR DMSTEX BUSINESS SOLUTIONS LLC, ITS MEMBERS,
   -- MANAGERS, OR EMPLOYEES BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
   -- SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
   -- TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
   -- PROFITS; CORRUPTION OF DATA, OR BUSINESS INTERRUPTION) HOWEVER CAUSED
   -- AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
   -- OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF
   -- THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH
   -- DAMAGE.
   --
   --


begin
   -- util.log('Trigger actions_a_iod');
   raise_application_error(-20001,
              'actions_a_iod trigger: delete is not allowed on this view.');

end actions_a_iod;
/
select 'ACTIONS_A_IOD' as "Trigger:"
 from  user_errors
 where name  = 'ACTIONS_A_IOD'
  and  type  = 'TRIGGER'
  and  rownum = 1
/
select '('||line||'/'||position||') '||text as error
 from  user_errors
 where name = 'ACTIONS_A_IOD'
  and  type = 'TRIGGER'
 order by sequence
/

create view actions_act
      (id
      ,actions_sub_type
      ,player_id
      ,players_nk1
      ,players_nk2
      ,players_nk3
      ,seq
      ,resolved
      ,res_action_id
      ,res_id_path
      ,res_nk_path
      ,res_actions_nk1
      ,res_actions_nk2
      ,res_actions_nk3
      ,res_actions_nk4
      ,rev_player_id
      ,rev_players_nk1
      ,rev_players_nk2
      ,rev_players_nk3
      )
   as select
       ACT.id
      ,ACT.actions_sub_type
      ,ACT.player_id
      ,PLY.games_nk1
      ,PLY.games_nk2
      ,PLY.name
      ,ACT.seq
      ,ACT.resolved
      ,ACT.res_action_id
      ,actions_tab.get_res_id_path(res_ACT.id)
      ,actions_tab.get_res_nk_path(res_ACT.id)
      ,res_ACT.players_nk1
      ,res_ACT.players_nk2
      ,res_ACT.players_nk3
      ,res_ACT.seq
      ,ACT.rev_player_id
      ,rev_PLY.games_nk1
      ,rev_PLY.games_nk2
      ,rev_PLY.name
 from             actions ACT
       inner join players_act PLY on PLY.id = ACT.player_id
  left outer join actions_a res_ACT on res_ACT.id = ACT.res_action_id
  left outer join players_act rev_PLY on rev_PLY.id = ACT.rev_player_id
/
select 'ACTIONS_ACT' as "View:"
 from  user_errors
 where name  = 'ACTIONS_ACT'
  and  type  = 'VIEW'
  and  rownum = 1
/
select '('||line||'/'||position||') '||text as error
 from  user_errors
 where name = 'ACTIONS_ACT'
  and  type = 'VIEW'
 order by sequence
/

comment on table actions_act is 'Player''s Suggestions for each User''s Game'
/

comment on column actions_act.id is 'Surrogate Primary Key for these actions'
/
comment on column actions_act.actions_sub_type is 'Sub-type for these actions'
/
comment on column actions_act.player_id is 'Player that took this Action'
/
comment on column actions_act.players_nk1 is 'PLAYERS Natural Key 1: GAMES NK1: USERS NK1: Clue Notes User Name'
/
comment on column actions_act.players_nk2 is 'PLAYERS Natural Key 2: GAMES NK2: User''s Game Name'
/
comment on column actions_act.players_nk3 is 'PLAYERS Natural Key 3: Player''s Name'
/
comment on column actions_act.seq is 'Sequence Number for this Action'
/
comment on column actions_act.resolved is 'Resolved Status for this Action'
/
comment on column actions_act.res_action_id is '(suggestion Sub-type) The current Action when this Suggestion was resolved'
/
comment on column actions_act.res_id_path is '(suggestion Sub-type) Path of ancestor IDs hierarchy for this record'
/
comment on column actions_act.res_nk_path is '(suggestion Sub-type) Path of ancestor Natural Keys hierarchy for this record'
/
comment on column actions_act.res_actions_nk1 is '(suggestion Sub-type) ACTIONS Natural Key 1: PLAYERS NK1: GAMES NK1: USERS NK1: Clue Notes User Name'
/
comment on column actions_act.res_actions_nk2 is '(suggestion Sub-type) ACTIONS Natural Key 2: PLAYERS NK2: GAMES NK2: User''s Game Name'
/
comment on column actions_act.res_actions_nk3 is '(suggestion Sub-type) ACTIONS Natural Key 3: PLAYERS NK3: Player''s Name'
/
comment on column actions_act.res_actions_nk4 is '(suggestion Sub-type) ACTIONS Natural Key 4: Sequence Number for this Action'
/
comment on column actions_act.rev_player_id is '(suggestion Sub-type) Player that reveled a card for this Suggestion'
/
comment on column actions_act.rev_players_nk1 is '(suggestion Sub-type) PLAYERS Natural Key 1: GAMES NK1: USERS NK1: Clue Notes User Name'
/
comment on column actions_act.rev_players_nk2 is '(suggestion Sub-type) PLAYERS Natural Key 2: GAMES NK2: User''s Game Name'
/
comment on column actions_act.rev_players_nk3 is '(suggestion Sub-type) PLAYERS Natural Key 3: Player''s Name'
/

alter view actions_act add constraint actions_act_pk
   primary key (id) disable
/

alter view actions_act add constraint actions_act_fk1
   foreign key (player_id) references players_act (id) disable
/
alter view actions_act add constraint actions_act_fk4
   foreign key (res_action_id) references actions_act (id) disable
/
alter view actions_act add constraint actions_act_fk5
   foreign key (rev_player_id) references players_act (id) disable
/

CREATE type actions_vobj
is
   -- Actions Active View (Virtual) Record Type
object
   (id  NUMBER(38)
   ,actions_sub_type  VARCHAR2(25)
   ,player_id  NUMBER(38)
   ,players_nk1  VARCHAR2(320)
   ,players_nk2  VARCHAR2(320)
   ,players_nk3  VARCHAR2(15)
   ,seq  NUMBER(3)
   ,resolved  VARCHAR2(3)
   ,res_action_id  NUMBER(38)
   ,res_id_path  VARCHAR2(4000)
   ,res_nk_path  VARCHAR2(32767)
   ,res_actions_nk1  VARCHAR2(320)
   ,res_actions_nk2  VARCHAR2(320)
   ,res_actions_nk3  VARCHAR2(15)
   ,res_actions_nk4  NUMBER(3)
   ,rev_player_id  NUMBER(38)
   ,rev_players_nk1  VARCHAR2(320)
   ,rev_players_nk2  VARCHAR2(320)
   ,rev_players_nk3  VARCHAR2(15)
   )
/
select 'ACTIONS_VOBJ' as "Type:"
 from  user_errors
 where name  = 'ACTIONS_VOBJ'
  and  type  = 'TYPE'
  and  rownum = 1
/
select '('||line||'/'||position||') '||text as error
 from  user_errors
 where name = 'ACTIONS_VOBJ'
  and  type = 'TYPE'
 order by sequence
/

CREATE type actions_vtab
is
   -- Actions Active View (Virtual) Table Type
table of actions_vobj
/
select 'ACTIONS_VTAB' as "Type:"
 from  user_errors
 where name  = 'ACTIONS_VTAB'
  and  type  = 'TYPE'
  and  rownum = 1
/
select '('||line||'/'||position||') '||text as error
 from  user_errors
 where name = 'ACTIONS_VTAB'
  and  type = 'TYPE'
 order by sequence
/

create or replace package actions_dml
is

   -- Package Actions_Dml
   -- (Data Manipulation Language, Foreign Key and Path Lookup)

   -- Application: Clue Notes For Oracle
   -- Generated by DTGen (http://dmstex.com/services/dtgen)
   -- December  16, 2013  11:32:31 AM

   --
   --
   -- © Duane.Dieterich@DMSTEX.com 2013
   --
   -- All Rights Reserved
   --
   -- No part of this software may be reproduced, copied, modified or adapted,
   -- without the prior written consent of the author, unless otherwise
   -- indicated for stand-alone materials.
   --
   -- You may quote extracts from this software with attribution to
   -- Duane.Dieterich@DMSTEX.com
   --
   -- For any other mode of sharing, please contact Duane.Dieterich@DMSTEX.com.
   --
   -- Commercial use and distribution of this software is not allowed without
   -- express and prior written consent of the author.
   --
   -- THE SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
   -- INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY
   -- AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL
   -- THE COPYRIGHT HOLDER OR DMSTEX BUSINESS SOLUTIONS LLC, ITS MEMBERS,
   -- MANAGERS, OR EMPLOYEES BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
   -- SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
   -- TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
   -- PROFITS; CORRUPTION OF DATA, OR BUSINESS INTERRUPTION) HOWEVER CAUSED
   -- AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
   -- OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF
   -- THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH
   -- DAMAGE.
   --
   --


   -- Return the next Surrogate Key ID for actions
   function get_next_id
      return NUMBER;
   -- Return the current Surrogate Key ID for actions
   --   NOTE: This will return an ERROR if get_next_id has not been called
   function get_curr_id
      return NUMBER;

   -- Return the next Surrogate Key ID for the Natural Keys of actions
   --   NOTE: The fields used in this function are the Natural Keys for actions
   --         Alternatively, the Natural Key IDs for actions are:
   --            -) player_id
   --            -) seq
   function get_id
      (players_nk1  in  VARCHAR2
      ,players_nk2  in  VARCHAR2
      ,players_nk3  in  VARCHAR2
      ,seq  in  NUMBER
      ) return NUMBER;
   -- For all the Natural Key Column IDs, Return an ID
   function get_id2
      (player_id_in  in  NUMBER
      ,seq_in  in  NUMBER
      ) return NUMBER;
   -- Return a concatenated string of Natural Keys for a actions id
   function get_nk
      (id_in  in  NUMBER
      ) return VARCHAR2;

   -- Return an ID path string for a actions id
   function get_res_id_path
      (id_in  in  NUMBER
      ) return VARCHAR2;
   -- Return a Natural Key path string for a actions id
   function get_res_nk_path
      (id_in  in  NUMBER
      ) return CLOB;
   -- Return an ID for a actions ID path
   function get_res_id_by_id_path
      (id_path_in  VARCHAR2
      ) return NUMBER;
   -- Return an ID for a actions Natural Key path
   function get_res_id_by_nk_path
      (nk_path_in  in  VARCHAR2
      ) return NUMBER;

   -- Set a "view" record to null
   procedure clear
      (n_rec  in out nocopy  actions_ACT%ROWTYPE
      );
   -- This function traps and returns any error message from the clear procedure
   function clear
      (n_rec  in out nocopy  actions_ACT%ROWTYPE
      ) return varchar2;
   -- Set a "table" record to null
   procedure clear
      (n_tab  in out nocopy  actions%ROWTYPE
      );
   -- This function traps and returns any error message from the clear procedure
   function clear
      (n_tab  in out nocopy  actions%ROWTYPE
      ) return varchar2;

   -- Set a "view" record from a actions ID
   procedure get_rec_by_id
      (n_rec  in out nocopy  actions_ACT%ROWTYPE
      );
   -- This function traps and returns any error message from the get_rec_by_id procedure
   function get_rec_by_id
      (n_rec  in out nocopy  actions_ACT%ROWTYPE
      ) return varchar2;
   -- Set a "table" record from a actions ID
   procedure get_rec_by_id
      (n_tab  in out nocopy  actions%ROWTYPE
      );
   -- This function traps and returns any error message from the get_rec_by_id procedure
   function get_rec_by_id
      (n_tab  in out nocopy  actions%ROWTYPE
      ) return varchar2;

   -- actions requires the following sub-types
   --   -) accusation
   --   -) revelation
   --   -) suggestion

   -- NOTE: All INS procedures will run faster with a null ID
   --       because it avoids a history search for duplicate IDs
   --
   -- Insert a actions ACTIVE View Record
   -- NOTE: If UPD_VALS_IN is set to FALSE, the function will run faster,
   --       but the returned record may contain invalid data
   procedure ins
      (new_rec  in out nocopy  actions_act%ROWTYPE
      ,upd_vals_in  in  boolean default TRUE
      );
   -- This function traps and returns any error message from the ins procedure
   function ins
      (new_rec  in out nocopy  actions_act%ROWTYPE
      ,upd_vals_in  in  boolean default TRUE
      ) return varchar2;
   -- Insert a actions Table Record
   --  (Fastest insert procedure and returned data is always valid)
   procedure ins
      (new_tab  in out nocopy  actions%ROWTYPE
      );
   -- This function traps and returns any error message from the ins procedure
   function ins
      (new_tab  in out nocopy  actions%ROWTYPE
      ) return varchar2;
   -- Insert columns for actions ACTIVE View
   --   without returning updated data in each column
   procedure ins
      (id_in  in  NUMBER default null
      ,actions_sub_type_in  in  VARCHAR2 default null
      ,player_id_in  in  NUMBER default null
      ,players_nk1_in  in  VARCHAR2 default null
      ,players_nk2_in  in  VARCHAR2 default null
      ,players_nk3_in  in  VARCHAR2 default null
      ,seq_in  in  NUMBER default null
      ,resolved_in  in  VARCHAR2 default null
      ,res_action_id_in  in  NUMBER default null
      ,res_id_path_in  in  VARCHAR2 default null
      ,res_nk_path_in  in  VARCHAR2 default null
      ,res_actions_nk1_in  in  VARCHAR2 default null
      ,res_actions_nk2_in  in  VARCHAR2 default null
      ,res_actions_nk3_in  in  VARCHAR2 default null
      ,res_actions_nk4_in  in  NUMBER default null
      ,rev_player_id_in  in  NUMBER default null
      ,rev_players_nk1_in  in  VARCHAR2 default null
      ,rev_players_nk2_in  in  VARCHAR2 default null
      ,rev_players_nk3_in  in  VARCHAR2 default null
      );
   -- This function traps and returns any error message from the ins procedure
   function ins
      (id_in  in  NUMBER default null
      ,actions_sub_type_in  in  VARCHAR2 default null
      ,player_id_in  in  NUMBER default null
      ,players_nk1_in  in  VARCHAR2 default null
      ,players_nk2_in  in  VARCHAR2 default null
      ,players_nk3_in  in  VARCHAR2 default null
      ,seq_in  in  NUMBER default null
      ,resolved_in  in  VARCHAR2 default null
      ,res_action_id_in  in  NUMBER default null
      ,res_id_path_in  in  VARCHAR2 default null
      ,res_nk_path_in  in  VARCHAR2 default null
      ,res_actions_nk1_in  in  VARCHAR2 default null
      ,res_actions_nk2_in  in  VARCHAR2 default null
      ,res_actions_nk3_in  in  VARCHAR2 default null
      ,res_actions_nk4_in  in  NUMBER default null
      ,rev_player_id_in  in  NUMBER default null
      ,rev_players_nk1_in  in  VARCHAR2 default null
      ,rev_players_nk2_in  in  VARCHAR2 default null
      ,rev_players_nk3_in  in  VARCHAR2 default null
      ) return varchar2;
   -- Insert columns for actions ACTIVE View
   --   with updated data returned in each column
   procedure ins2
      (id_io  in out nocopy  NUMBER
      ,actions_sub_type_io  in out nocopy  VARCHAR2
      ,player_id_io  in out nocopy  NUMBER
      ,players_nk1_io  in out nocopy  VARCHAR2
      ,players_nk2_io  in out nocopy  VARCHAR2
      ,players_nk3_io  in out nocopy  VARCHAR2
      ,seq_io  in out nocopy  NUMBER
      ,resolved_io  in out nocopy  VARCHAR2
      ,res_action_id_io  in out nocopy  NUMBER
      ,res_id_path_io  in out nocopy  VARCHAR2
      ,res_nk_path_io  in out nocopy  VARCHAR2
      ,res_actions_nk1_io  in out nocopy  VARCHAR2
      ,res_actions_nk2_io  in out nocopy  VARCHAR2
      ,res_actions_nk3_io  in out nocopy  VARCHAR2
      ,res_actions_nk4_io  in out nocopy  NUMBER
      ,rev_player_id_io  in out nocopy  NUMBER
      ,rev_players_nk1_io  in out nocopy  VARCHAR2
      ,rev_players_nk2_io  in out nocopy  VARCHAR2
      ,rev_players_nk3_io  in out nocopy  VARCHAR2
      );
   -- This function traps and returns any error message from the ins2 procedure
   function ins2
      (id_io  in out nocopy  NUMBER
      ,actions_sub_type_io  in out nocopy  VARCHAR2
      ,player_id_io  in out nocopy  NUMBER
      ,players_nk1_io  in out nocopy  VARCHAR2
      ,players_nk2_io  in out nocopy  VARCHAR2
      ,players_nk3_io  in out nocopy  VARCHAR2
      ,seq_io  in out nocopy  NUMBER
      ,resolved_io  in out nocopy  VARCHAR2
      ,res_action_id_io  in out nocopy  NUMBER
      ,res_id_path_io  in out nocopy  VARCHAR2
      ,res_nk_path_io  in out nocopy  VARCHAR2
      ,res_actions_nk1_io  in out nocopy  VARCHAR2
      ,res_actions_nk2_io  in out nocopy  VARCHAR2
      ,res_actions_nk3_io  in out nocopy  VARCHAR2
      ,res_actions_nk4_io  in out nocopy  NUMBER
      ,rev_player_id_io  in out nocopy  NUMBER
      ,rev_players_nk1_io  in out nocopy  VARCHAR2
      ,rev_players_nk2_io  in out nocopy  VARCHAR2
      ,rev_players_nk3_io  in out nocopy  VARCHAR2
      ) return varchar2;
   -- Insert columns for actions Table
   --   with updated data returned in each column
   procedure ins2
      (id_io  in out nocopy  NUMBER
      ,actions_sub_type_io  in out nocopy  VARCHAR2
      ,player_id_io  in out nocopy  NUMBER
      ,seq_io  in out nocopy  NUMBER
      ,resolved_io  in out nocopy  VARCHAR2
      ,res_action_id_io  in out nocopy  NUMBER
      ,rev_player_id_io  in out nocopy  NUMBER
      );
   -- This function traps and returns any error message from the ins2 procedure
   function ins2
      (id_io  in out nocopy  NUMBER
      ,actions_sub_type_io  in out nocopy  VARCHAR2
      ,player_id_io  in out nocopy  NUMBER
      ,seq_io  in out nocopy  NUMBER
      ,resolved_io  in out nocopy  VARCHAR2
      ,res_action_id_io  in out nocopy  NUMBER
      ,rev_player_id_io  in out nocopy  NUMBER
      ) return varchar2;

   -- Special Use Update for Specific Column Updates.
   --   Only differences between old and new data will be updated.
   --   Set upd_val_in TRUE to get updated data in new_rec
   procedure upd
      (old_rec  in  actions_act%ROWTYPE
      ,new_rec  in out nocopy  actions_act%ROWTYPE
      ,upd_vals_in  in  boolean default FALSE
      );
   -- This function traps and returns any error message from the upd procedure
   function upd
      (old_rec  in  actions_act%ROWTYPE
      ,new_rec  in out nocopy  actions_act%ROWTYPE
      ,upd_vals_in  in  boolean default FALSE
      ) return varchar2;
   -- Special Use Update for Specific Column Updates.
   --   Only differences between old and new data will be updated.
   --   Set upd_val_in TRUE to get updated data in new_rec
   procedure upd
      (old_tab  in  actions%ROWTYPE
      ,new_tab  in out nocopy  actions%ROWTYPE
      );
   -- This function traps and returns any error message from the upd procedure
   function upd
      (old_tab  in  actions%ROWTYPE
      ,new_tab  in out nocopy  actions%ROWTYPE
      ) return varchar2;
   -- Update a actions ACTIVE View Record
   -- NOTE: If UPD_VALS_IN is set to FALSE, the returned record
   --       may contain invalid data
   -- NOTE: Only FK NKs that are part of this NK will be used to find
   --       this ID from its NKs (FK IDs will be ignored)
   procedure upd
      (new_rec  in out nocopy  actions_act%ROWTYPE
      ,upd_vals_in  in  boolean default TRUE
      );
   -- This function traps and returns any error message from the upd procedure
   function upd
      (new_rec  in out nocopy  actions_act%ROWTYPE
      ,upd_vals_in  in  boolean default TRUE
      ) return varchar2;
   -- Update a actions Table Record
   --  (Fastest update procedure and returned data is always valid)
   -- NOTE: actionsID must be supplied (NK lookup will not be performed)
   procedure upd
      (new_tab  in out nocopy  actions%ROWTYPE
      );
   -- This function traps and returns any error message from the upd procedure
   function upd
      (new_tab  in out nocopy  actions%ROWTYPE
      ) return varchar2;
   -- Update columns for actions ACTIVE View
   --   without returning updated data in each column
   procedure upd
      (id_in  in  NUMBER default null
      ,actions_sub_type_in  in  VARCHAR2 default null
      ,player_id_in  in  NUMBER default null
      ,players_nk1_in  in  VARCHAR2 default null
      ,players_nk2_in  in  VARCHAR2 default null
      ,players_nk3_in  in  VARCHAR2 default null
      ,seq_in  in  NUMBER default null
      ,resolved_in  in  VARCHAR2 default null
      ,res_action_id_in  in  NUMBER default null
      ,res_id_path_in  in  VARCHAR2 default null
      ,res_nk_path_in  in  VARCHAR2 default null
      ,res_actions_nk1_in  in  VARCHAR2 default null
      ,res_actions_nk2_in  in  VARCHAR2 default null
      ,res_actions_nk3_in  in  VARCHAR2 default null
      ,res_actions_nk4_in  in  NUMBER default null
      ,rev_player_id_in  in  NUMBER default null
      ,rev_players_nk1_in  in  VARCHAR2 default null
      ,rev_players_nk2_in  in  VARCHAR2 default null
      ,rev_players_nk3_in  in  VARCHAR2 default null
      );
   -- This function traps and returns any error message from the upd procedure
   function upd
      (id_in  in  NUMBER default null
      ,actions_sub_type_in  in  VARCHAR2 default null
      ,player_id_in  in  NUMBER default null
      ,players_nk1_in  in  VARCHAR2 default null
      ,players_nk2_in  in  VARCHAR2 default null
      ,players_nk3_in  in  VARCHAR2 default null
      ,seq_in  in  NUMBER default null
      ,resolved_in  in  VARCHAR2 default null
      ,res_action_id_in  in  NUMBER default null
      ,res_id_path_in  in  VARCHAR2 default null
      ,res_nk_path_in  in  VARCHAR2 default null
      ,res_actions_nk1_in  in  VARCHAR2 default null
      ,res_actions_nk2_in  in  VARCHAR2 default null
      ,res_actions_nk3_in  in  VARCHAR2 default null
      ,res_actions_nk4_in  in  NUMBER default null
      ,rev_player_id_in  in  NUMBER default null
      ,rev_players_nk1_in  in  VARCHAR2 default null
      ,rev_players_nk2_in  in  VARCHAR2 default null
      ,rev_players_nk3_in  in  VARCHAR2 default null
      ) return varchar2;
   -- Update columns for actions ACTIVE View
   --   with updated data returned in each column
   procedure upd2
      (id_io  in out nocopy  NUMBER
      ,actions_sub_type_io  in out nocopy  VARCHAR2
      ,player_id_io  in out nocopy  NUMBER
      ,players_nk1_io  in out nocopy  VARCHAR2
      ,players_nk2_io  in out nocopy  VARCHAR2
      ,players_nk3_io  in out nocopy  VARCHAR2
      ,seq_io  in out nocopy  NUMBER
      ,resolved_io  in out nocopy  VARCHAR2
      ,res_action_id_io  in out nocopy  NUMBER
      ,res_id_path_io  in out nocopy  VARCHAR2
      ,res_nk_path_io  in out nocopy  VARCHAR2
      ,res_actions_nk1_io  in out nocopy  VARCHAR2
      ,res_actions_nk2_io  in out nocopy  VARCHAR2
      ,res_actions_nk3_io  in out nocopy  VARCHAR2
      ,res_actions_nk4_io  in out nocopy  NUMBER
      ,rev_player_id_io  in out nocopy  NUMBER
      ,rev_players_nk1_io  in out nocopy  VARCHAR2
      ,rev_players_nk2_io  in out nocopy  VARCHAR2
      ,rev_players_nk3_io  in out nocopy  VARCHAR2
      );
   -- This function traps and returns any error message from the upd2 procedure
   function upd2
      (id_io  in out nocopy  NUMBER
      ,actions_sub_type_io  in out nocopy  VARCHAR2
      ,player_id_io  in out nocopy  NUMBER
      ,players_nk1_io  in out nocopy  VARCHAR2
      ,players_nk2_io  in out nocopy  VARCHAR2
      ,players_nk3_io  in out nocopy  VARCHAR2
      ,seq_io  in out nocopy  NUMBER
      ,resolved_io  in out nocopy  VARCHAR2
      ,res_action_id_io  in out nocopy  NUMBER
      ,res_id_path_io  in out nocopy  VARCHAR2
      ,res_nk_path_io  in out nocopy  VARCHAR2
      ,res_actions_nk1_io  in out nocopy  VARCHAR2
      ,res_actions_nk2_io  in out nocopy  VARCHAR2
      ,res_actions_nk3_io  in out nocopy  VARCHAR2
      ,res_actions_nk4_io  in out nocopy  NUMBER
      ,rev_player_id_io  in out nocopy  NUMBER
      ,rev_players_nk1_io  in out nocopy  VARCHAR2
      ,rev_players_nk2_io  in out nocopy  VARCHAR2
      ,rev_players_nk3_io  in out nocopy  VARCHAR2
      ) return varchar2;
   -- Update columns for actions Table
   --   with updated data returned in each column
   procedure upd2
      (id_io  in out nocopy  NUMBER
      ,actions_sub_type_io  in out nocopy  VARCHAR2
      ,player_id_io  in out nocopy  NUMBER
      ,seq_io  in out nocopy  NUMBER
      ,resolved_io  in out nocopy  VARCHAR2
      ,res_action_id_io  in out nocopy  NUMBER
      ,rev_player_id_io  in out nocopy  NUMBER
      );
   -- This function traps and returns any error message from the upd2 procedure
   function upd2
      (id_io  in out nocopy  NUMBER
      ,actions_sub_type_io  in out nocopy  VARCHAR2
      ,player_id_io  in out nocopy  NUMBER
      ,seq_io  in out nocopy  NUMBER
      ,resolved_io  in out nocopy  VARCHAR2
      ,res_action_id_io  in out nocopy  NUMBER
      ,rev_player_id_io  in out nocopy  NUMBER
      ) return varchar2;

   -- Application Delete procedure without updated parameters
   procedure del
      (id_in  in  NUMBER default null
      ,player_id_in  in  NUMBER default null
      ,players_nk1_in  in  VARCHAR2 default null
      ,players_nk2_in  in  VARCHAR2 default null
      ,players_nk3_in  in  VARCHAR2 default null
      ,seq_in  in  NUMBER default null
      );
   -- This function traps and returns any error message from the del procedure
   function del
      (id_in  in  NUMBER default null
      ,player_id_in  in  NUMBER default null
      ,players_nk1_in  in  VARCHAR2 default null
      ,players_nk2_in  in  VARCHAR2 default null
      ,players_nk3_in  in  VARCHAR2 default null
      ,seq_in  in  NUMBER default null
      ) return varchar2;
   -- Application Delete procedure with updated parameters
   procedure del2
      (id_io  in out nocopy  NUMBER
      ,player_id_in  in NUMBER default null
      ,players_nk1_in  in VARCHAR2 default null
      ,players_nk2_in  in VARCHAR2 default null
      ,players_nk3_in  in VARCHAR2 default null
      ,seq_in  in NUMBER default null
      );
   -- This function traps and returns any error message from the del2 procedure
   function del2
      (id_io  in out nocopy  NUMBER
      ,player_id_in  in NUMBER default null
      ,players_nk1_in  in VARCHAR2 default null
      ,players_nk2_in  in VARCHAR2 default null
      ,players_nk3_in  in VARCHAR2 default null
      ,seq_in  in NUMBER default null
      ) return varchar2;

   -- Special Data Warehouse Dimension Function
   --   Attempts to find matching record based on natural keys
   --   If found, performs updates on non-NK columns that changed
   --   If not found, inserts new record
   --   Returns ID of record
   procedure load_dim
      (dim_tab  in out nocopy  actions%ROWTYPE
      );
   -- This function traps and returns any error message from the load_dim procedure
   function load_dim
      (dim_tab  in out nocopy  actions%ROWTYPE
      ) return varchar2;

end actions_dml;
/
select 'ACTIONS_DML' as "Package:"
 from  user_errors
 where name  = 'ACTIONS_DML'
  and  type  = 'PACKAGE'
  and  rownum = 1
/
select '('||line||'/'||position||') '||text as error
 from  user_errors
 where name = 'ACTIONS_DML'
  and  type = 'PACKAGE'
 order by sequence
/

create package body actions_dml
is

 -- Package Body Actions_Dml
 -- (Data Manipulation Language, Foreign Key and Path Lookup)

   -- Application: Clue Notes For Oracle
   -- Generated by DTGen (http://dmstex.com/services/dtgen)
   -- December  16, 2013  11:32:31 AM

   --
   --
   -- © Duane.Dieterich@DMSTEX.com 2013
   --
   -- All Rights Reserved
   --
   -- No part of this software may be reproduced, copied, modified or adapted,
   -- without the prior written consent of the author, unless otherwise
   -- indicated for stand-alone materials.
   --
   -- You may quote extracts from this software with attribution to
   -- Duane.Dieterich@DMSTEX.com
   --
   -- For any other mode of sharing, please contact Duane.Dieterich@DMSTEX.com.
   --
   -- Commercial use and distribution of this software is not allowed without
   -- express and prior written consent of the author.
   --
   -- THE SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
   -- INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY
   -- AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL
   -- THE COPYRIGHT HOLDER OR DMSTEX BUSINESS SOLUTIONS LLC, ITS MEMBERS,
   -- MANAGERS, OR EMPLOYEES BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
   -- SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
   -- TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
   -- PROFITS; CORRUPTION OF DATA, OR BUSINESS INTERRUPTION) HOWEVER CAUSED
   -- AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
   -- OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF
   -- THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH
   -- DAMAGE.
   --
   --


----------------------------------------
function get_next_id
      return NUMBER
is
   retid  NUMBER;
begin
   select actions_seq.nextval
    into  retid from dual;
   return retid;
end get_next_id;
----------------------------------------
function get_curr_id
      return NUMBER
is
   retid  NUMBER;
begin
   select actions_seq.currval
    into  retid from dual;
   return retid;
end get_curr_id;
----------------------------------------
function get_id
      (players_nk1  in  VARCHAR2
      ,players_nk2  in  VARCHAR2
      ,players_nk3  in  VARCHAR2
      ,seq  in  NUMBER
      ) return number
   -- For all the Natural Key Columns, Return an ID
is
begin
   return actions_tab.get_id
      (players_nk1
      ,players_nk2
      ,players_nk3
      ,seq
      );
end get_id;
----------------------------------------
-- For all the Natural Key Column IDs, Return an ID
function get_id2
      (player_id_in  in  NUMBER
      ,seq_in  in  NUMBER
      ) return NUMBER
is
   retid  NUMBER(38);
begin
   select id
    into  retid
    from  actions  ACT
    where player_id_in = ACT.player_id
     and  seq_in = ACT.seq
    ;
   return retid;
exception when no_data_found then return null;
end get_id2;
----------------------------------------
function get_nk
      (id_in  in  NUMBER)
   return VARCHAR2
   -- For an ID, return a delimited list of Natural Key Values
is
begin
   return actions_tab.get_nk(id_in);
end get_nk;
----------------------------------------
function get_res_id_path
      (id_in  in  NUMBER)
   return VARCHAR2
   -- For a hierarchy ID, return a delimited list of IDs
is
begin
   return actions_tab.get_res_id_path(id_in);
end get_res_id_path;
----------------------------------------
function get_res_nk_path
      (id_in  in  NUMBER)
   return CLOB
   -- For a hierarchy ID, return a delimited list of
   --    Natural Key sets
is
begin
   return actions_tab.get_res_nk_path(id_in);
end get_res_nk_path;
----------------------------------------
function get_res_id_by_id_path
      (id_path_in  VARCHAR2
      ) return NUMBER
is
begin
   return actions_tab.get_res_id_by_id_path(id_path_in);
end get_res_id_by_id_path;
----------------------------------------
function get_res_id_by_nk_path
      (nk_path_in  in  VARCHAR2
      ) return NUMBER
is
   path_len   number;          -- Length of nk_path_in
   ps_occ     number;          -- Path Seperator substring search occurance
   ps_pos     number;          -- Path Seperator position in nk_path_in
   path_frag  VARCHAR2(32767);  -- Concatenated Natural Key Path Fragment
   ns_pos     number;          -- Natural Key Seperator position in nk_path_in
   nk_frag    VARCHAR2(4000);  -- First Natural Key String from path_frag
begin
   if nk_path_in is null then return null; end if;
   path_len := length(nk_path_in);
   ps_occ := 0;
   -- To account for embedded path_sep chars in nk_path_in,
   while ps_occ < 1 loop   -- increase this ps_occ limit
      ps_occ := ps_occ + 1;
      -- Attempt to find the last conatenated Natural Key in nk_path_in
      ps_pos := instr(nk_path_in, util.path_sep, -1, ps_occ);
      -- Don't search beyond 4000 characters in the path
      if path_len - ps_pos > 4001 then return null; end if;
      -- This should be the last concatenated Natural Key in nk_path_in
      path_frag := substr(nk_path_in, ps_pos+1);
      ns_pos := instr(path_frag, util.nk_sep, 1, 1);
      -- This should the first Natural Key value in the last concatenated Natural Key
      nk_frag := substr(path_frag, 1, ns_pos-1);
      -- This will find cadidates for nk_path_in checks
      for buff in (
         select ACT.id
               ,get_res_nk_path(ACT.id) check_path
          from  actions_A ACT
          where players_nk1 like nk_frag || '%' )
      loop
         if buff.check_path = nk_path_in then return buff.id; end if;
      end loop;
      if ps_pos = 0 then
         -- ps_pos is 0, so there is nothing more to search
         return null;
      end if;
   end loop;
   return null;
end get_res_id_by_nk_path;
----------------------------------------
procedure clear
      (n_rec  in out nocopy  actions_act%ROWTYPE
      )
is
begin
   n_rec.id := null;
   n_rec.actions_sub_type := null;
   n_rec.player_id := null;
   n_rec.players_nk1 := null;
   n_rec.players_nk2 := null;
   n_rec.players_nk3 := null;
   n_rec.seq := null;
   n_rec.resolved := null;
   n_rec.res_action_id := null;
   n_rec.res_id_path := null;
   n_rec.res_nk_path := null;
   n_rec.res_actions_nk1 := null;
   n_rec.res_actions_nk2 := null;
   n_rec.res_actions_nk3 := null;
   n_rec.res_actions_nk4 := null;
   n_rec.rev_player_id := null;
   n_rec.rev_players_nk1 := null;
   n_rec.rev_players_nk2 := null;
   n_rec.rev_players_nk3 := null;
end clear;
----------
function clear
      (n_rec  in out nocopy  actions_act%ROWTYPE
      ) return varchar2
is
begin
   clear(n_rec);
   return '';
exception when others then return sqlerrm;
end clear;
----------------------------------------
procedure clear
      (n_tab  in out nocopy  actions%ROWTYPE
      )
is
begin
   n_tab.id := null;
   n_tab.actions_sub_type := null;
   n_tab.player_id := null;
   n_tab.seq := null;
   n_tab.resolved := null;
   n_tab.res_action_id := null;
   n_tab.rev_player_id := null;
end clear;
----------
function clear
      (n_tab  in out nocopy  actions%ROWTYPE
      ) return varchar2
is
begin
   clear(n_tab);
   return '';
exception when others then return sqlerrm;
end clear;
----------------------------------------
procedure get_rec_by_id
      (n_rec  in out nocopy  actions_act%ROWTYPE
      )
is
   start_tstamp  timestamp := systimestamp;
begin
   if n_rec.id is null then
      clear(n_rec);
   else
      select * into n_rec from actions_act
       where id = n_rec.id;
   end if;
   return;
   util.trc_time_interval('actions_dml.get_rec_by_id(act rec) ID:' || n_rec.id, start_tstamp);
end get_rec_by_id;
----------
function get_rec_by_id
      (n_rec  in out nocopy  actions_act%ROWTYPE
      ) return varchar2
is
begin
   get_rec_by_id(n_rec);
   return '';
exception when others then return sqlerrm;
end get_rec_by_id;
----------------------------------------
procedure get_rec_by_id
      (n_tab  in out nocopy  actions%ROWTYPE
      )
is
   start_tstamp  timestamp := systimestamp;
begin
   if n_tab.id is null then
      clear(n_tab);
   else
      select * into n_tab from actions
       where id = n_tab.id;
   end if;
   return;
   util.trc_time_interval('actions_dml.get_rec_by_id(tab rec) ID:' || n_tab.id, start_tstamp);
end get_rec_by_id;
----------
function get_rec_by_id
      (n_tab  in out nocopy  actions%ROWTYPE
      ) return varchar2
is
begin
   get_rec_by_id(n_tab);
   return '';
exception when others then return sqlerrm;
end get_rec_by_id;
----------------------------------------
-- Insert a actions ACTIVE View Record
procedure ins
      (new_rec  in out nocopy  actions_act%ROWTYPE
      ,upd_vals_in  in  boolean default TRUE
      )
is
   new_tab  actions%ROWTYPE;
   start_tstamp  timestamp := systimestamp;
begin
   -- Set self-referencing n_res_action_id, if needed
   if new_rec.res_action_id is null then
      if    new_rec.res_actions_nk1 = new_rec.players_nk1
        and new_rec.res_actions_nk2 = new_rec.players_nk2
        and new_rec.res_actions_nk3 = new_rec.players_nk3
        and new_rec.res_actions_nk4 = new_rec.seq
      then
         if new_rec.id is not null then
            new_rec.res_action_id := new_rec.id;
         else
            -- An ID of "0" during insert is a flag to the actions_TAB
            --   package to duplicate the new ID in this self-referenced ID
            new_rec.res_action_id := 0;
         end if;
      end if;
   end if;
   -- Set new_rec.res_action_id from new_rec.res_id_path, if needed
   if new_rec.res_action_id is null then
      if new_rec.res_id_path is not null then
         new_rec.res_action_id := actions_tab.get_res_id_by_id_path(new_rec.res_id_path);
         if new_rec.res_action_id is null then
            raise_application_error(-20020, 'Null ID was returned from actions_tab.get_res_id_by_id_path');
         end if;
      -- Set new_rec.res_action_id from new_rec.res_nk_path, if needed
      elsif new_rec.res_nk_path is not null then
         new_rec.res_action_id := get_res_id_by_nk_path(new_rec.res_nk_path);
         if new_rec.res_action_id is null then
            raise_application_error(-20020, 'Null ID was returned from get_res_id_by_nk_path');
         end if;
      else
      -- Lack of proper indentation is for convenience of generator
      if    new_rec.res_actions_nk1 is not null
        and new_rec.res_actions_nk2 is not null
        and new_rec.res_actions_nk3 is not null
        and new_rec.res_actions_nk4 is not null
      then
         new_rec.res_action_id := actions_tab.get_id
            (new_rec.res_actions_nk1
            ,new_rec.res_actions_nk2
            ,new_rec.res_actions_nk3
            ,new_rec.res_actions_nk4
            );
         if new_rec.res_action_id is null then
            raise_application_error(-20020, 'Null ID was returned from actions_tab.get_id');
         end if;
      end if;
      -- Lack of proper indentation is for convenience of generator
      end if;
   end if;
   -- Set new_rec.player_id, if needed
   if new_rec.player_id is null then
      if    new_rec.players_nk1 is not null
        and new_rec.players_nk2 is not null
        and new_rec.players_nk3 is not null
      then
         new_rec.player_id := players_tab.get_id
            (new_rec.players_nk1
            ,new_rec.players_nk2
            ,new_rec.players_nk3
            );
         if new_rec.player_id is null then
            raise_application_error(-20020, 'Null ID was returned from players_tab.get_id');
         end if;
      end if;
   end if;
   -- Set new_rec.rev_player_id, if needed
   if new_rec.rev_player_id is null then
      if    new_rec.rev_players_nk1 is not null
        and new_rec.rev_players_nk2 is not null
        and new_rec.rev_players_nk3 is not null
      then
         new_rec.rev_player_id := players_tab.get_id
            (new_rec.rev_players_nk1
            ,new_rec.rev_players_nk2
            ,new_rec.rev_players_nk3
            );
         if new_rec.rev_player_id is null then
            raise_application_error(-20020, 'Null ID was returned from players_tab.get_id');
         end if;
      end if;
   end if;
   new_tab.id := new_rec.id;
   new_tab.actions_sub_type := new_rec.actions_sub_type;
   new_tab.player_id := new_rec.player_id;
   new_tab.seq := new_rec.seq;
   new_tab.resolved := new_rec.resolved;
   new_tab.res_action_id := new_rec.res_action_id;
   new_tab.rev_player_id := new_rec.rev_player_id;
   actions_tab.ins(new_tab);
   if upd_vals_in then
      -- actions_tab.ins returns a new ID, if needed
      select * into new_rec from actions_act
       where id = new_tab.id;
   end if;
   return;
   util.trc_time_interval('actions_dml.ins(act rec) ID:' || new_rec.id, start_tstamp);
end ins;
----------
function ins
      (new_rec  in out nocopy  actions_act%ROWTYPE
      ,upd_vals_in  in  boolean default TRUE
      ) return varchar2
is
begin
   ins(new_rec, upd_vals_in);
   return '';
exception when others then return sqlerrm;
end ins;
----------------------------------------
-- Insert a actions Table Record
procedure ins
      (new_tab   in out nocopy  actions%ROWTYPE
      )
is
   start_tstamp  timestamp := systimestamp;
begin
   actions_tab.ins(new_tab);
   return;
   util.trc_time_interval('actions_dml.ins(tab rec) ID:' || new_tab.id, start_tstamp);
end ins;
----------
function ins
      (new_tab   in out nocopy  actions%ROWTYPE
      ) return varchar2
is
begin
   ins(new_tab);
   return '';
exception when others then return sqlerrm;
end ins;
----------------------------------------
-- Insert columns for actions ACTIVE View
--   without returning updated data in each column
procedure ins
      (id_in  in  NUMBER default null
      ,actions_sub_type_in  in  VARCHAR2 default null
      ,player_id_in  in  NUMBER default null
      ,players_nk1_in  in  VARCHAR2 default null
      ,players_nk2_in  in  VARCHAR2 default null
      ,players_nk3_in  in  VARCHAR2 default null
      ,seq_in  in  NUMBER default null
      ,resolved_in  in  VARCHAR2 default null
      ,res_action_id_in  in  NUMBER default null
      ,res_id_path_in  in  VARCHAR2 default null
      ,res_nk_path_in  in  VARCHAR2 default null
      ,res_actions_nk1_in  in  VARCHAR2 default null
      ,res_actions_nk2_in  in  VARCHAR2 default null
      ,res_actions_nk3_in  in  VARCHAR2 default null
      ,res_actions_nk4_in  in  NUMBER default null
      ,rev_player_id_in  in  NUMBER default null
      ,rev_players_nk1_in  in  VARCHAR2 default null
      ,rev_players_nk2_in  in  VARCHAR2 default null
      ,rev_players_nk3_in  in  VARCHAR2 default null
      )
is
   new_rec  actions_act%ROWTYPE;
   start_tstamp  timestamp := systimestamp;
begin
   new_rec.id := id_in;
   new_rec.actions_sub_type := actions_sub_type_in;
   new_rec.player_id := player_id_in;
   new_rec.players_nk1 := players_nk1_in;
   new_rec.players_nk2 := players_nk2_in;
   new_rec.players_nk3 := players_nk3_in;
   new_rec.seq := seq_in;
   new_rec.resolved := resolved_in;
   new_rec.res_action_id := res_action_id_in;
   new_rec.res_id_path := res_id_path_in;
   new_rec.res_nk_path := res_nk_path_in;
   new_rec.res_actions_nk1 := res_actions_nk1_in;
   new_rec.res_actions_nk2 := res_actions_nk2_in;
   new_rec.res_actions_nk3 := res_actions_nk3_in;
   new_rec.res_actions_nk4 := res_actions_nk4_in;
   new_rec.rev_player_id := rev_player_id_in;
   new_rec.rev_players_nk1 := rev_players_nk1_in;
   new_rec.rev_players_nk2 := rev_players_nk2_in;
   new_rec.rev_players_nk3 := rev_players_nk3_in;
   ins(new_rec, FALSE);
   return;
   util.trc_time_interval('actions_dml.ins(tab col) ID:' || id_in, start_tstamp);
end ins;
----------
function ins
      (id_in  in  NUMBER default null
      ,actions_sub_type_in  in  VARCHAR2 default null
      ,player_id_in  in  NUMBER default null
      ,players_nk1_in  in  VARCHAR2 default null
      ,players_nk2_in  in  VARCHAR2 default null
      ,players_nk3_in  in  VARCHAR2 default null
      ,seq_in  in  NUMBER default null
      ,resolved_in  in  VARCHAR2 default null
      ,res_action_id_in  in  NUMBER default null
      ,res_id_path_in  in  VARCHAR2 default null
      ,res_nk_path_in  in  VARCHAR2 default null
      ,res_actions_nk1_in  in  VARCHAR2 default null
      ,res_actions_nk2_in  in  VARCHAR2 default null
      ,res_actions_nk3_in  in  VARCHAR2 default null
      ,res_actions_nk4_in  in  NUMBER default null
      ,rev_player_id_in  in  NUMBER default null
      ,rev_players_nk1_in  in  VARCHAR2 default null
      ,rev_players_nk2_in  in  VARCHAR2 default null
      ,rev_players_nk3_in  in  VARCHAR2 default null
      ) return varchar2
is
begin
   ins
      (id_in
      ,actions_sub_type_in
      ,player_id_in
      ,players_nk1_in
      ,players_nk2_in
      ,players_nk3_in
      ,seq_in
      ,resolved_in
      ,res_action_id_in
      ,res_id_path_in
      ,res_nk_path_in
      ,res_actions_nk1_in
      ,res_actions_nk2_in
      ,res_actions_nk3_in
      ,res_actions_nk4_in
      ,rev_player_id_in
      ,rev_players_nk1_in
      ,rev_players_nk2_in
      ,rev_players_nk3_in
      );
   return '';
exception when others then return sqlerrm;
end ins;
----------------------------------------
-- Insert columns for actions ACTIVE View
--   with updated data returned in each column
procedure ins2
      (id_io  in out nocopy  NUMBER
      ,actions_sub_type_io  in out nocopy  VARCHAR2
      ,player_id_io  in out nocopy  NUMBER
      ,players_nk1_io  in out nocopy  VARCHAR2
      ,players_nk2_io  in out nocopy  VARCHAR2
      ,players_nk3_io  in out nocopy  VARCHAR2
      ,seq_io  in out nocopy  NUMBER
      ,resolved_io  in out nocopy  VARCHAR2
      ,res_action_id_io  in out nocopy  NUMBER
      ,res_id_path_io  in out nocopy  VARCHAR2
      ,res_nk_path_io  in out nocopy  VARCHAR2
      ,res_actions_nk1_io  in out nocopy  VARCHAR2
      ,res_actions_nk2_io  in out nocopy  VARCHAR2
      ,res_actions_nk3_io  in out nocopy  VARCHAR2
      ,res_actions_nk4_io  in out nocopy  NUMBER
      ,rev_player_id_io  in out nocopy  NUMBER
      ,rev_players_nk1_io  in out nocopy  VARCHAR2
      ,rev_players_nk2_io  in out nocopy  VARCHAR2
      ,rev_players_nk3_io  in out nocopy  VARCHAR2
      )
is
   new_rec  actions_act%ROWTYPE;
   start_tstamp  timestamp := systimestamp;
begin
   new_rec.id := id_io;
   new_rec.actions_sub_type := actions_sub_type_io;
   new_rec.player_id := player_id_io;
   new_rec.players_nk1 := players_nk1_io;
   new_rec.players_nk2 := players_nk2_io;
   new_rec.players_nk3 := players_nk3_io;
   new_rec.seq := seq_io;
   new_rec.resolved := resolved_io;
   new_rec.res_action_id := res_action_id_io;
   new_rec.res_id_path := res_id_path_io;
   new_rec.res_nk_path := res_nk_path_io;
   new_rec.res_actions_nk1 := res_actions_nk1_io;
   new_rec.res_actions_nk2 := res_actions_nk2_io;
   new_rec.res_actions_nk3 := res_actions_nk3_io;
   new_rec.res_actions_nk4 := res_actions_nk4_io;
   new_rec.rev_player_id := rev_player_id_io;
   new_rec.rev_players_nk1 := rev_players_nk1_io;
   new_rec.rev_players_nk2 := rev_players_nk2_io;
   new_rec.rev_players_nk3 := rev_players_nk3_io;
   --
   ins(new_rec);
   --
   id_io := new_rec.id;
   actions_sub_type_io := new_rec.actions_sub_type;
   player_id_io := new_rec.player_id;
   players_nk1_io := new_rec.players_nk1;
   players_nk2_io := new_rec.players_nk2;
   players_nk3_io := new_rec.players_nk3;
   seq_io := new_rec.seq;
   resolved_io := new_rec.resolved;
   res_action_id_io := new_rec.res_action_id;
   res_id_path_io := new_rec.res_id_path;
   res_nk_path_io := new_rec.res_nk_path;
   res_actions_nk1_io := new_rec.res_actions_nk1;
   res_actions_nk2_io := new_rec.res_actions_nk2;
   res_actions_nk3_io := new_rec.res_actions_nk3;
   res_actions_nk4_io := new_rec.res_actions_nk4;
   rev_player_id_io := new_rec.rev_player_id;
   rev_players_nk1_io := new_rec.rev_players_nk1;
   rev_players_nk2_io := new_rec.rev_players_nk2;
   rev_players_nk3_io := new_rec.rev_players_nk3;
   return;
   util.trc_time_interval('actions_dml.ins2(tab col) ID:' || id_io, start_tstamp);
end ins2;
----------
function ins2
      (id_io  in out nocopy  NUMBER
      ,actions_sub_type_io  in out nocopy  VARCHAR2
      ,player_id_io  in out nocopy  NUMBER
      ,players_nk1_io  in out nocopy  VARCHAR2
      ,players_nk2_io  in out nocopy  VARCHAR2
      ,players_nk3_io  in out nocopy  VARCHAR2
      ,seq_io  in out nocopy  NUMBER
      ,resolved_io  in out nocopy  VARCHAR2
      ,res_action_id_io  in out nocopy  NUMBER
      ,res_id_path_io  in out nocopy  VARCHAR2
      ,res_nk_path_io  in out nocopy  VARCHAR2
      ,res_actions_nk1_io  in out nocopy  VARCHAR2
      ,res_actions_nk2_io  in out nocopy  VARCHAR2
      ,res_actions_nk3_io  in out nocopy  VARCHAR2
      ,res_actions_nk4_io  in out nocopy  NUMBER
      ,rev_player_id_io  in out nocopy  NUMBER
      ,rev_players_nk1_io  in out nocopy  VARCHAR2
      ,rev_players_nk2_io  in out nocopy  VARCHAR2
      ,rev_players_nk3_io  in out nocopy  VARCHAR2
      ) return varchar2
is
begin
   ins2
      (id_io
      ,actions_sub_type_io
      ,player_id_io
      ,players_nk1_io
      ,players_nk2_io
      ,players_nk3_io
      ,seq_io
      ,resolved_io
      ,res_action_id_io
      ,res_id_path_io
      ,res_nk_path_io
      ,res_actions_nk1_io
      ,res_actions_nk2_io
      ,res_actions_nk3_io
      ,res_actions_nk4_io
      ,rev_player_id_io
      ,rev_players_nk1_io
      ,rev_players_nk2_io
      ,rev_players_nk3_io
      );
   return '';
exception when others then return sqlerrm;
end ins2;
----------------------------------------
-- Insert columns for actions Table
--   with updated data returned in each column
procedure ins2
      (id_io  in out nocopy  NUMBER
      ,actions_sub_type_io  in out nocopy  VARCHAR2
      ,player_id_io  in out nocopy  NUMBER
      ,seq_io  in out nocopy  NUMBER
      ,resolved_io  in out nocopy  VARCHAR2
      ,res_action_id_io  in out nocopy  NUMBER
      ,rev_player_id_io  in out nocopy  NUMBER
      )
is
   new_rec  actions%ROWTYPE;
   start_tstamp  timestamp := systimestamp;
begin
   new_rec.id := id_io;
   new_rec.actions_sub_type := actions_sub_type_io;
   new_rec.player_id := player_id_io;
   new_rec.seq := seq_io;
   new_rec.resolved := resolved_io;
   new_rec.res_action_id := res_action_id_io;
   new_rec.rev_player_id := rev_player_id_io;
   --
   actions_tab.ins(new_rec);
   --
   id_io := new_rec.id;
   actions_sub_type_io := new_rec.actions_sub_type;
   player_id_io := new_rec.player_id;
   seq_io := new_rec.seq;
   resolved_io := new_rec.resolved;
   res_action_id_io := new_rec.res_action_id;
   rev_player_id_io := new_rec.rev_player_id;
   return;
   util.trc_time_interval('actions_dml.ins2(tab col) ID:' || id_io, start_tstamp);
end ins2;
----------
function ins2
      (id_io  in out nocopy  NUMBER
      ,actions_sub_type_io  in out nocopy  VARCHAR2
      ,player_id_io  in out nocopy  NUMBER
      ,seq_io  in out nocopy  NUMBER
      ,resolved_io  in out nocopy  VARCHAR2
      ,res_action_id_io  in out nocopy  NUMBER
      ,rev_player_id_io  in out nocopy  NUMBER
      ) return varchar2
is
begin
   ins2
      (id_io
      ,actions_sub_type_io
      ,player_id_io
      ,seq_io
      ,resolved_io
      ,res_action_id_io
      ,rev_player_id_io
      );
   return '';
exception when others then return sqlerrm;
end ins2;
----------------------------------------
-- Special Use Update for Specific Column Updates.
--   Only differences between old and new data will be updated.
--   Set upd_val_in TRUE to get updated data in new_rec
procedure upd
      (old_rec  in  actions_act%ROWTYPE
      ,new_rec  in out nocopy  actions_act%ROWTYPE
      ,upd_vals_in  in  boolean default FALSE
      )
is
   old_tab  actions%ROWTYPE;
   new_tab  actions%ROWTYPE;
   start_tstamp  timestamp := systimestamp;
begin
   if old_rec.id is null then
      raise_application_error (-20023, 'ID is null');
   end if;
   -- Set self-referencing n_res_action_id, if needed
   if new_rec.res_action_id is null then
      if    new_rec.res_actions_nk1 = new_rec.players_nk1
        and new_rec.res_actions_nk2 = new_rec.players_nk2
        and new_rec.res_actions_nk3 = new_rec.players_nk3
        and new_rec.res_actions_nk4 = new_rec.seq
      then
         if new_rec.id is not null then
            new_rec.res_action_id := new_rec.id;
         else
            -- An ID of "0" during insert is a flag to the actions_TAB
            --   package to duplicate the new ID in this self-referenced ID
            new_rec.res_action_id := 0;
         end if;
      end if;
   end if;
   -- Set new_rec.res_action_id from new_rec.res_id_path, if needed
   if new_rec.res_action_id is null then
      if new_rec.res_id_path is not null then
         new_rec.res_action_id := actions_tab.get_res_id_by_id_path(new_rec.res_id_path);
         if new_rec.res_action_id is null then
            raise_application_error(-20020, 'Null ID was returned from actions_tab.get_res_id_by_id_path');
         end if;
      -- Set new_rec.res_action_id from new_rec.res_nk_path, if needed
      elsif new_rec.res_nk_path is not null then
         new_rec.res_action_id := get_res_id_by_nk_path(new_rec.res_nk_path);
         if new_rec.res_action_id is null then
            raise_application_error(-20020, 'Null ID was returned from get_res_id_by_nk_path');
         end if;
      else
      -- Lack of proper indentation is for convenience of generator
      if    new_rec.res_actions_nk1 is not null
        and new_rec.res_actions_nk2 is not null
        and new_rec.res_actions_nk3 is not null
        and new_rec.res_actions_nk4 is not null
      then
         new_rec.res_action_id := actions_tab.get_id
            (new_rec.res_actions_nk1
            ,new_rec.res_actions_nk2
            ,new_rec.res_actions_nk3
            ,new_rec.res_actions_nk4
            );
         if new_rec.res_action_id is null then
            raise_application_error(-20020, 'Null ID was returned from actions_tab.get_id');
         end if;
      end if;
      -- Lack of proper indentation is for convenience of generator
      end if;
   end if;
   -- Set new_rec.player_id, if needed
   if new_rec.player_id is null then
      if    new_rec.players_nk1 is not null
        and new_rec.players_nk2 is not null
        and new_rec.players_nk3 is not null
      then
         new_rec.player_id := players_tab.get_id
            (new_rec.players_nk1
            ,new_rec.players_nk2
            ,new_rec.players_nk3
            );
         if new_rec.player_id is null then
            raise_application_error(-20020, 'Null ID was returned from players_tab.get_id');
         end if;
      end if;
   end if;
   -- Set new_rec.rev_player_id, if needed
   if new_rec.rev_player_id is null then
      if    new_rec.rev_players_nk1 is not null
        and new_rec.rev_players_nk2 is not null
        and new_rec.rev_players_nk3 is not null
      then
         new_rec.rev_player_id := players_tab.get_id
            (new_rec.rev_players_nk1
            ,new_rec.rev_players_nk2
            ,new_rec.rev_players_nk3
            );
         if new_rec.rev_player_id is null then
            raise_application_error(-20020, 'Null ID was returned from players_tab.get_id');
         end if;
      end if;
   end if;
   -- Set self-referencing n_res_action_id, if needed
   if util.is_equal(new_rec.res_action_id, old_rec.res_action_id) then
      if    new_rec.res_actions_nk1 = new_rec.players_nk1
        and new_rec.res_actions_nk2 = new_rec.players_nk2
        and new_rec.res_actions_nk3 = new_rec.players_nk3
        and new_rec.res_actions_nk4 = new_rec.seq
      then
         new_rec.res_action_id := old_rec.id;
      end if;
   end if;
   -- Set new_rec.res_action_id from new_rec.res_id_path, if needed
   if util.is_equal(new_rec.res_action_id, old_rec.res_action_id) then
      if not util.is_equal(new_rec.res_id_path, actions_tab.get_res_id_path(old_rec.id)) and
         not util.is_equal(new_rec.res_id_path, old_rec.res_id_path)
      then
         new_rec.res_action_id := actions_tab.get_res_id_by_id_path(new_rec.res_id_path);
         if new_rec.res_action_id is null then
            raise_application_error(-20020, 'Null ID was returned from actions_tab.get_res_id_by_id_path');
         end if;
      -- Set new_rec.res_action_id from new_rec.res_nk_path, if needed
      elsif util.is_equal(new_rec.res_action_id, old_rec.res_action_id) and
            not util.is_equal(new_rec.res_nk_path, actions_tab.get_res_nk_path(old_rec.id)) and
            not util.is_equal(new_rec.res_nk_path, old_rec.res_nk_path)
      then
         new_rec.res_action_id := get_res_id_by_nk_path(new_rec.res_nk_path);
         if new_rec.res_action_id is null then
            raise_application_error(-20020, 'Null ID was returned from get_res_id_by_nk_path');
         end if;
      else
      -- Lack of proper indentation is for convenience of generator
      if    not util.is_equal(new_rec.res_actions_nk1, old_rec.res_actions_nk1)
        or  not util.is_equal(new_rec.res_actions_nk2, old_rec.res_actions_nk2)
        or  not util.is_equal(new_rec.res_actions_nk3, old_rec.res_actions_nk3)
        or  not util.is_equal(new_rec.res_actions_nk4, old_rec.res_actions_nk4)
      then
         new_rec.res_action_id := actions_tab.get_id
            (new_rec.res_actions_nk1
            ,new_rec.res_actions_nk2
            ,new_rec.res_actions_nk3
            ,new_rec.res_actions_nk4
            );
         if new_rec.res_action_id is null then
            raise_application_error(-20020, 'Null ID was returned from actions_tab.get_id');
         end if;
      end if;
      -- Lack of proper indentation is for convenience of generator
      end if;
   end if;
   -- Set new_rec.player_id, if needed
   if new_rec.player_id = old_rec.player_id then
      if    not (new_rec.players_nk1 = old_rec.players_nk1)
        or  not (new_rec.players_nk2 = old_rec.players_nk2)
        or  not (new_rec.players_nk3 = old_rec.players_nk3)
      then
         new_rec.player_id := players_tab.get_id
            (new_rec.players_nk1
            ,new_rec.players_nk2
            ,new_rec.players_nk3
            );
         if new_rec.player_id is null then
            raise_application_error(-20020, 'Null ID was returned from players_tab.get_id');
         end if;
      end if;
   end if;
   -- Set new_rec.rev_player_id, if needed
   if util.is_equal(new_rec.rev_player_id, old_rec.rev_player_id) then
      if    not util.is_equal(new_rec.rev_players_nk1, old_rec.rev_players_nk1)
        or  not util.is_equal(new_rec.rev_players_nk2, old_rec.rev_players_nk2)
        or  not util.is_equal(new_rec.rev_players_nk3, old_rec.rev_players_nk3)
      then
         new_rec.rev_player_id := players_tab.get_id
            (new_rec.rev_players_nk1
            ,new_rec.rev_players_nk2
            ,new_rec.rev_players_nk3
            );
         if new_rec.rev_player_id is null then
            raise_application_error(-20020, 'Null ID was returned from players_tab.get_id');
         end if;
      end if;
   end if;
   -- Load the Table Record from the View Record
   old_tab.id := old_rec.id;
   new_tab.id := new_rec.id;
   old_tab.actions_sub_type := old_rec.actions_sub_type;
   new_tab.actions_sub_type := new_rec.actions_sub_type;
   old_tab.player_id := old_rec.player_id;
   new_tab.player_id := new_rec.player_id;
   old_tab.seq := old_rec.seq;
   new_tab.seq := new_rec.seq;
   old_tab.resolved := old_rec.resolved;
   new_tab.resolved := new_rec.resolved;
   old_tab.res_action_id := old_rec.res_action_id;
   new_tab.res_action_id := new_rec.res_action_id;
   old_tab.rev_player_id := old_rec.rev_player_id;
   new_tab.rev_player_id := new_rec.rev_player_id;
   -- Run the update
   actions_tab.upd(old_tab, new_tab);
   if upd_vals_in then
      -- Load the View Record from the Returned (new) Table Record
      -- actions_tab.upd should have set new ID = old ID
      select * into new_rec from actions_act
       where id = old_tab.id;
   end if;
   return;
   util.trc_time_interval('actions_dml.upd(trigger) ID:' || old_tab.id, start_tstamp);
end upd;
----------
function upd
      (old_rec  in  actions_act%ROWTYPE
      ,new_rec  in out nocopy  actions_act%ROWTYPE
      ,upd_vals_in  in  boolean default FALSE
      ) return varchar2
is
begin
   upd(old_rec, new_rec, upd_vals_in);
   return '';
exception when others then return sqlerrm;
end upd;
----------------------------------------
-- Special Use Update for Specific Column Updates.
--   Only differences between old and new data will be updated.
--   Set upd_val_in TRUE to get updated data in new_rec
procedure upd
      (old_tab  in  actions%ROWTYPE
      ,new_tab  in out nocopy  actions%ROWTYPE
      )
is
   start_tstamp  timestamp := systimestamp;
begin
   if old_tab.id is null then
      raise_application_error (-20023, 'ID is null');
   end if;
   -- Run the update
   actions_tab.upd(old_tab, new_tab);
   return;
   util.trc_time_interval('actions_dml.upd(trigger) ID:' || old_tab.id, start_tstamp);
end upd;
----------
function upd
      (old_tab  in  actions%ROWTYPE
      ,new_tab  in out nocopy  actions%ROWTYPE
      ) return varchar2
is
begin
   upd(old_tab, new_tab);
   return '';
exception when others then return sqlerrm;
end upd;
----------------------------------------
-- Update a actions ACTIVE View Record
procedure upd
      (new_rec  in out nocopy  actions_act%ROWTYPE
      ,upd_vals_in  in  boolean default TRUE
      )
is
   old_rec  actions_act%ROWTYPE;
   start_tstamp  timestamp := systimestamp;
begin
   if new_rec.id is null then
      if    new_rec.players_nk1 is not null
        and new_rec.players_nk2 is not null
        and new_rec.players_nk3 is not null
        and new_rec.seq is not null
      then
         new_rec.id := actions_tab.get_id
            (new_rec.players_nk1
            ,new_rec.players_nk2
            ,new_rec.players_nk3
            ,new_rec.seq
            );
      end if;
   end if;
   if new_rec.id is null then
      if    new_rec.player_id is not null
        and new_rec.seq is not null
      then
         begin
            select id into new_rec.id from actions
             where player_id = new_rec.player_id
              and  seq = new_rec.seq
               ;
         exception when NO_DATA_FOUND then new_rec.id := null;
         end;
      end if;
   end if;
   if new_rec.id is null then
      raise_application_error (-20023, 'ID is null and could not be found from Natural Keys');
   end if;
   select * into old_rec from actions_act
    where id = new_rec.id;
   upd(old_rec, new_rec, upd_vals_in);
   return;
   util.trc_time_interval('actions_dml.upd(act rec) ID:' || new_rec.id, start_tstamp);
end upd;
----------
function upd
      (new_rec  in out nocopy  actions_act%ROWTYPE
      ,upd_vals_in  in  boolean default TRUE
      ) return varchar2
is
begin
   upd(new_rec, upd_vals_in);
   return '';
exception when others then return sqlerrm;
end upd;
----------------------------------------
-- Update a actions Table Record
procedure upd
      (new_tab   in out nocopy  actions%ROWTYPE
      )
is
   start_tstamp  timestamp := systimestamp;
begin
   if new_tab.id is null then
      if    new_tab.player_id is not null
        and new_tab.seq is not null
      then
         begin
            select id into new_tab.id from actions
             where player_id = new_tab.player_id
              and  seq = new_tab.seq
               ;
         exception when NO_DATA_FOUND then new_tab.id := null;
         end;
      end if;
   end if;
   if new_tab.id is null then
      raise_application_error (-20023, 'ID is null and could not be found from Natural Keys');
   end if;
   actions_tab.upd(new_tab);
   return;
   util.trc_time_interval('actions_dml.upd(tab rec) ID:' || new_tab.id, start_tstamp);
end upd;
----------
function upd
      (new_tab   in out nocopy  actions%ROWTYPE
      ) return varchar2
is
begin
   upd(new_tab);
   return '';
exception when others then return sqlerrm;
end upd;
----------------------------------------
-- Update columns for actions ACTIVE View
--   without returning updated data in each column
procedure upd
      (id_in  in  NUMBER default null
      ,actions_sub_type_in  in  VARCHAR2 default null
      ,player_id_in  in  NUMBER default null
      ,players_nk1_in  in  VARCHAR2 default null
      ,players_nk2_in  in  VARCHAR2 default null
      ,players_nk3_in  in  VARCHAR2 default null
      ,seq_in  in  NUMBER default null
      ,resolved_in  in  VARCHAR2 default null
      ,res_action_id_in  in  NUMBER default null
      ,res_id_path_in  in  VARCHAR2 default null
      ,res_nk_path_in  in  VARCHAR2 default null
      ,res_actions_nk1_in  in  VARCHAR2 default null
      ,res_actions_nk2_in  in  VARCHAR2 default null
      ,res_actions_nk3_in  in  VARCHAR2 default null
      ,res_actions_nk4_in  in  NUMBER default null
      ,rev_player_id_in  in  NUMBER default null
      ,rev_players_nk1_in  in  VARCHAR2 default null
      ,rev_players_nk2_in  in  VARCHAR2 default null
      ,rev_players_nk3_in  in  VARCHAR2 default null
      )
is
   new_rec  actions_act%ROWTYPE;
   start_tstamp  timestamp := systimestamp;
begin
   new_rec.id := id_in;
   new_rec.actions_sub_type := actions_sub_type_in;
   new_rec.player_id := player_id_in;
   new_rec.players_nk1 := players_nk1_in;
   new_rec.players_nk2 := players_nk2_in;
   new_rec.players_nk3 := players_nk3_in;
   new_rec.seq := seq_in;
   new_rec.resolved := resolved_in;
   new_rec.res_action_id := res_action_id_in;
   new_rec.res_id_path := res_id_path_in;
   new_rec.res_nk_path := res_nk_path_in;
   new_rec.res_actions_nk1 := res_actions_nk1_in;
   new_rec.res_actions_nk2 := res_actions_nk2_in;
   new_rec.res_actions_nk3 := res_actions_nk3_in;
   new_rec.res_actions_nk4 := res_actions_nk4_in;
   new_rec.rev_player_id := rev_player_id_in;
   new_rec.rev_players_nk1 := rev_players_nk1_in;
   new_rec.rev_players_nk2 := rev_players_nk2_in;
   new_rec.rev_players_nk3 := rev_players_nk3_in;
   -- Make corrections when ID is supplied, but NK is missing
   if    new_rec.ID is not null
     and new_rec.players_nk1 is null
     and new_rec.players_nk2 is null
     and new_rec.players_nk3 is null
     and new_rec.seq is null
   then
      select ACT.players_nk1
            ,ACT.players_nk2
            ,ACT.players_nk3
            ,ACT.seq
       into  new_rec.players_nk1
            ,new_rec.players_nk2
            ,new_rec.players_nk3
            ,new_rec.seq
       from  actions_act  ACT
       where ACT.id = new_rec.ID;
   end if;
   -- Make corrections when player_id is supplied, but the Natural Key is missing
   if    new_rec.player_id is not null
     and new_rec.players_nk1 is null
     and new_rec.players_nk2 is null
     and new_rec.players_nk3 is null
   then
      select PLY.games_nk1
            ,PLY.games_nk2
            ,PLY.name
       into  new_rec.players_nk1
            ,new_rec.players_nk2
            ,new_rec.players_nk3
       from  players_act  PLY
       where PLY.id = new_rec.player_id;
   end if;
   -- Make corrections when res_action_id is supplied, but the Natural Key is missing
   if    new_rec.res_action_id is not null
     and new_rec.res_actions_nk1 is null
     and new_rec.res_actions_nk2 is null
     and new_rec.res_actions_nk3 is null
     and new_rec.res_actions_nk4 is null
   then
      select ACT.players_nk1
            ,ACT.players_nk2
            ,ACT.players_nk3
            ,ACT.seq
       into  new_rec.res_actions_nk1
            ,new_rec.res_actions_nk2
            ,new_rec.res_actions_nk3
            ,new_rec.res_actions_nk4
       from  actions_act  ACT
       where ACT.id = new_rec.res_action_id;
   end if;
   -- Make corrections when rev_player_id is supplied, but the Natural Key is missing
   if    new_rec.rev_player_id is not null
     and new_rec.rev_players_nk1 is null
     and new_rec.rev_players_nk2 is null
     and new_rec.rev_players_nk3 is null
   then
      select PLY.games_nk1
            ,PLY.games_nk2
            ,PLY.name
       into  new_rec.rev_players_nk1
            ,new_rec.rev_players_nk2
            ,new_rec.rev_players_nk3
       from  players_act  PLY
       where PLY.id = new_rec.rev_player_id;
   end if;
   upd(new_rec, FALSE);
   return;
   util.trc_time_interval('actions_dml.upd(act col) ID:' || id_in, start_tstamp);
end upd;
----------
function upd
      (id_in  in  NUMBER default null
      ,actions_sub_type_in  in  VARCHAR2 default null
      ,player_id_in  in  NUMBER default null
      ,players_nk1_in  in  VARCHAR2 default null
      ,players_nk2_in  in  VARCHAR2 default null
      ,players_nk3_in  in  VARCHAR2 default null
      ,seq_in  in  NUMBER default null
      ,resolved_in  in  VARCHAR2 default null
      ,res_action_id_in  in  NUMBER default null
      ,res_id_path_in  in  VARCHAR2 default null
      ,res_nk_path_in  in  VARCHAR2 default null
      ,res_actions_nk1_in  in  VARCHAR2 default null
      ,res_actions_nk2_in  in  VARCHAR2 default null
      ,res_actions_nk3_in  in  VARCHAR2 default null
      ,res_actions_nk4_in  in  NUMBER default null
      ,rev_player_id_in  in  NUMBER default null
      ,rev_players_nk1_in  in  VARCHAR2 default null
      ,rev_players_nk2_in  in  VARCHAR2 default null
      ,rev_players_nk3_in  in  VARCHAR2 default null
      ) return varchar2
is
begin
   upd
      (id_in
      ,actions_sub_type_in
      ,player_id_in
      ,players_nk1_in
      ,players_nk2_in
      ,players_nk3_in
      ,seq_in
      ,resolved_in
      ,res_action_id_in
      ,res_id_path_in
      ,res_nk_path_in
      ,res_actions_nk1_in
      ,res_actions_nk2_in
      ,res_actions_nk3_in
      ,res_actions_nk4_in
      ,rev_player_id_in
      ,rev_players_nk1_in
      ,rev_players_nk2_in
      ,rev_players_nk3_in
      );
   return '';
exception when others then return sqlerrm;
end upd;
----------------------------------------
-- Update columns for actions ACTIVE View
--   with updated data returned in each column
procedure upd2
      (id_io  in out nocopy  NUMBER
      ,actions_sub_type_io  in out nocopy  VARCHAR2
      ,player_id_io  in out nocopy  NUMBER
      ,players_nk1_io  in out nocopy  VARCHAR2
      ,players_nk2_io  in out nocopy  VARCHAR2
      ,players_nk3_io  in out nocopy  VARCHAR2
      ,seq_io  in out nocopy  NUMBER
      ,resolved_io  in out nocopy  VARCHAR2
      ,res_action_id_io  in out nocopy  NUMBER
      ,res_id_path_io  in out nocopy  VARCHAR2
      ,res_nk_path_io  in out nocopy  VARCHAR2
      ,res_actions_nk1_io  in out nocopy  VARCHAR2
      ,res_actions_nk2_io  in out nocopy  VARCHAR2
      ,res_actions_nk3_io  in out nocopy  VARCHAR2
      ,res_actions_nk4_io  in out nocopy  NUMBER
      ,rev_player_id_io  in out nocopy  NUMBER
      ,rev_players_nk1_io  in out nocopy  VARCHAR2
      ,rev_players_nk2_io  in out nocopy  VARCHAR2
      ,rev_players_nk3_io  in out nocopy  VARCHAR2
      )
is
   new_rec  actions_act%ROWTYPE;
   start_tstamp  timestamp := systimestamp;
begin
   new_rec.id := id_io;
   new_rec.actions_sub_type := actions_sub_type_io;
   new_rec.player_id := player_id_io;
   new_rec.players_nk1 := players_nk1_io;
   new_rec.players_nk2 := players_nk2_io;
   new_rec.players_nk3 := players_nk3_io;
   new_rec.seq := seq_io;
   new_rec.resolved := resolved_io;
   new_rec.res_action_id := res_action_id_io;
   new_rec.res_id_path := res_id_path_io;
   new_rec.res_nk_path := res_nk_path_io;
   new_rec.res_actions_nk1 := res_actions_nk1_io;
   new_rec.res_actions_nk2 := res_actions_nk2_io;
   new_rec.res_actions_nk3 := res_actions_nk3_io;
   new_rec.res_actions_nk4 := res_actions_nk4_io;
   new_rec.rev_player_id := rev_player_id_io;
   new_rec.rev_players_nk1 := rev_players_nk1_io;
   new_rec.rev_players_nk2 := rev_players_nk2_io;
   new_rec.rev_players_nk3 := rev_players_nk3_io;
   --
   --  upd(new_rec) will set new_rec.id as needed
   upd(new_rec);
   --
   id_io := new_rec.id;
   actions_sub_type_io := new_rec.actions_sub_type;
   player_id_io := new_rec.player_id;
   players_nk1_io := new_rec.players_nk1;
   players_nk2_io := new_rec.players_nk2;
   players_nk3_io := new_rec.players_nk3;
   seq_io := new_rec.seq;
   resolved_io := new_rec.resolved;
   res_action_id_io := new_rec.res_action_id;
   res_id_path_io := new_rec.res_id_path;
   res_nk_path_io := new_rec.res_nk_path;
   res_actions_nk1_io := new_rec.res_actions_nk1;
   res_actions_nk2_io := new_rec.res_actions_nk2;
   res_actions_nk3_io := new_rec.res_actions_nk3;
   res_actions_nk4_io := new_rec.res_actions_nk4;
   rev_player_id_io := new_rec.rev_player_id;
   rev_players_nk1_io := new_rec.rev_players_nk1;
   rev_players_nk2_io := new_rec.rev_players_nk2;
   rev_players_nk3_io := new_rec.rev_players_nk3;
   return;
   util.trc_time_interval('actions_dml.upd2(act col) ID:' || id_io, start_tstamp);
end upd2;
----------
function upd2
      (id_io  in out nocopy  NUMBER
      ,actions_sub_type_io  in out nocopy  VARCHAR2
      ,player_id_io  in out nocopy  NUMBER
      ,players_nk1_io  in out nocopy  VARCHAR2
      ,players_nk2_io  in out nocopy  VARCHAR2
      ,players_nk3_io  in out nocopy  VARCHAR2
      ,seq_io  in out nocopy  NUMBER
      ,resolved_io  in out nocopy  VARCHAR2
      ,res_action_id_io  in out nocopy  NUMBER
      ,res_id_path_io  in out nocopy  VARCHAR2
      ,res_nk_path_io  in out nocopy  VARCHAR2
      ,res_actions_nk1_io  in out nocopy  VARCHAR2
      ,res_actions_nk2_io  in out nocopy  VARCHAR2
      ,res_actions_nk3_io  in out nocopy  VARCHAR2
      ,res_actions_nk4_io  in out nocopy  NUMBER
      ,rev_player_id_io  in out nocopy  NUMBER
      ,rev_players_nk1_io  in out nocopy  VARCHAR2
      ,rev_players_nk2_io  in out nocopy  VARCHAR2
      ,rev_players_nk3_io  in out nocopy  VARCHAR2
      ) return varchar2
is
begin
   upd2
      (id_io
      ,actions_sub_type_io
      ,player_id_io
      ,players_nk1_io
      ,players_nk2_io
      ,players_nk3_io
      ,seq_io
      ,resolved_io
      ,res_action_id_io
      ,res_id_path_io
      ,res_nk_path_io
      ,res_actions_nk1_io
      ,res_actions_nk2_io
      ,res_actions_nk3_io
      ,res_actions_nk4_io
      ,rev_player_id_io
      ,rev_players_nk1_io
      ,rev_players_nk2_io
      ,rev_players_nk3_io
      );
   return '';
exception when others then return sqlerrm;
end upd2;
----------------------------------------
-- Update columns for actions Table
--   with updated data returned in each column
procedure upd2
      (id_io  in out nocopy  NUMBER
      ,actions_sub_type_io  in out nocopy  VARCHAR2
      ,player_id_io  in out nocopy  NUMBER
      ,seq_io  in out nocopy  NUMBER
      ,resolved_io  in out nocopy  VARCHAR2
      ,res_action_id_io  in out nocopy  NUMBER
      ,rev_player_id_io  in out nocopy  NUMBER
      )
is
   new_rec  actions%ROWTYPE;
   start_tstamp  timestamp := systimestamp;
begin
   if id_io is null then
      if    player_id_io is not null
        and seq_io is not null
      then
         begin
            select id into id_io from actions
             where player_id = player_id_io
              and  seq = seq_io
               ;
         exception when NO_DATA_FOUND then id_io := null;
         end;
      end if;
   end if;
   if id_io is null then
      raise_application_error (-20023, 'ID is null and could not be found from Natural Keys');
   end if;
   new_rec.id := id_io;
   new_rec.actions_sub_type := actions_sub_type_io;
   new_rec.player_id := player_id_io;
   new_rec.seq := seq_io;
   new_rec.resolved := resolved_io;
   new_rec.res_action_id := res_action_id_io;
   new_rec.rev_player_id := rev_player_id_io;
   --
   actions_tab.upd(new_rec);
   --
   id_io := new_rec.id;
   actions_sub_type_io := new_rec.actions_sub_type;
   player_id_io := new_rec.player_id;
   seq_io := new_rec.seq;
   resolved_io := new_rec.resolved;
   res_action_id_io := new_rec.res_action_id;
   rev_player_id_io := new_rec.rev_player_id;
   return;
   util.trc_time_interval('actions_dml.upd2(tab col) ID:' || id_io, start_tstamp);
end upd2;
----------
function upd2
      (id_io  in out nocopy  NUMBER
      ,actions_sub_type_io  in out nocopy  VARCHAR2
      ,player_id_io  in out nocopy  NUMBER
      ,seq_io  in out nocopy  NUMBER
      ,resolved_io  in out nocopy  VARCHAR2
      ,res_action_id_io  in out nocopy  NUMBER
      ,rev_player_id_io  in out nocopy  NUMBER
      ) return varchar2
is
begin
    upd2
      (id_io
      ,actions_sub_type_io
      ,player_id_io
      ,seq_io
      ,resolved_io
      ,res_action_id_io
      ,rev_player_id_io
      );
   return '';
exception when others then return sqlerrm;
end upd2;

----------------------------------------
-- Application Delete procedure without updated parameters
procedure del
      (id_in  in  NUMBER default null
      ,player_id_in  in  NUMBER default null
      ,players_nk1_in  in  VARCHAR2 default null
      ,players_nk2_in  in  VARCHAR2 default null
      ,players_nk3_in  in  VARCHAR2 default null
      ,seq_in  in  NUMBER default null
      )
is
   start_tstamp  timestamp := systimestamp;
   tmp_id  NUMBER;
begin
   tmp_id := id_in;
   if tmp_id is null then
      if    players_nk1_in is not null
        and players_nk2_in is not null
        and players_nk3_in is not null
        and seq_in is not null
      then
         tmp_id := actions_tab.get_id
            (players_nk1_in
            ,players_nk2_in
            ,players_nk3_in
            ,seq_in
            );
      end if;
   end if;
   if tmp_id is null then
      if    player_id_in is not null
        and seq_in is not null
      then
         begin
            select id into tmp_id from actions
             where player_id = player_id_in
              and  seq = seq_in
               ;
         exception when NO_DATA_FOUND then tmp_id := null;
         end;
      end if;
   end if;
   if tmp_id is null then
      raise_application_error (-20023, 'ID is null and could not be found from Natural Keys');
   end if;
   actions_tab.del(tmp_id);
   return;
   util.trc_time_interval('actions_dml.del ID:' || id_in, start_tstamp);
end del;
----------
function del
      (id_in  in  NUMBER default null
      ,player_id_in  in  NUMBER default null
      ,players_nk1_in  in  VARCHAR2 default null
      ,players_nk2_in  in  VARCHAR2 default null
      ,players_nk3_in  in  VARCHAR2 default null
      ,seq_in  in  NUMBER default null
      ) return varchar2
is
begin
   del
      (id_in
      ,player_id_in
      ,players_nk1_in
      ,players_nk2_in
      ,players_nk3_in
      ,seq_in
      );
   return '';
exception when others then return sqlerrm;
end del;
----------------------------------------
-- Application Delete procedure with updated parameters
procedure del2
      (id_io  in out nocopy  NUMBER
      ,player_id_in  in  NUMBER default null
      ,players_nk1_in  in  VARCHAR2 default null
      ,players_nk2_in  in  VARCHAR2 default null
      ,players_nk3_in  in  VARCHAR2 default null
      ,seq_in  in  NUMBER default null
      )
is
   start_tstamp  timestamp := systimestamp;
begin
   if id_io is null then
      if    players_nk1_in is not null
        and players_nk2_in is not null
        and players_nk3_in is not null
        and seq_in is not null
      then
         id_io := actions_tab.get_id
            (players_nk1_in
            ,players_nk2_in
            ,players_nk3_in
            ,seq_in
            );
      end if;
   end if;
   if id_io is null then
      if    player_id_in is not null
        and seq_in is not null
      then
         begin
            select id into id_io from actions
             where player_id = player_id_in
              and  seq = seq_in
               ;
         exception when NO_DATA_FOUND then id_io := null;
         end;
      end if;
   end if;
   if id_io is null then
      raise_application_error (-20023, 'ID is null and could not be found from Natural Keys');
   end if;
   actions_tab.del(id_io);
   return;
   util.trc_time_interval('actions_dml.del2 ID:' || id_io, start_tstamp);
end del2;
----------
function del2
      (id_io  in out nocopy  NUMBER
      ,player_id_in  in  NUMBER default null
      ,players_nk1_in  in  VARCHAR2 default null
      ,players_nk2_in  in  VARCHAR2 default null
      ,players_nk3_in  in  VARCHAR2 default null
      ,seq_in  in  NUMBER default null
      ) return varchar2
is
begin
   del2
      (id_io
      ,player_id_in
      ,players_nk1_in
      ,players_nk2_in
      ,players_nk3_in
      ,seq_in
      );
   return '';
exception when others then return sqlerrm;
end del2;
----------------------------------------
procedure load_dim
      (dim_tab  in out nocopy  actions%ROWTYPE
      )
is
   -- Special Data Warehouse Dimension Function
   start_tstamp  timestamp := systimestamp;
   procedure private_upd is
      saved_inc  boolean := util.get_ignore_no_change;
   begin
      util.set_ignore_no_change(TRUE);
      upd (dim_tab);
      util.set_ignore_no_change(saved_inc);
   exception
      when others then
         util.set_ignore_no_change(saved_inc);
         raise;
   end private_upd;
begin
   -- Attempt to find matching record based on natural keys
   if dim_tab.id is null then
      begin
         select id
          into  dim_tab.id
          from  actions
          where player_id = dim_tab.player_id
           and  player_id = dim_tab.player_id
           and  seq = dim_tab.seq
         ;
      exception
         when NO_DATA_FOUND then dim_tab.id := null;
      end;
   end if;
   if dim_tab.id is not null then
      -- If found, perform update on non-NK columns that changed
      private_upd;
      return;
      util.trc_time_interval('actions_dml.load_dimE ID:' || dim_tab.id, start_tstamp);
   end if;
   -- If not found, insert new record
   begin
      ins(dim_tab);
   exception
      when DUP_VAL_ON_INDEX then
         -- Since this can run multi-threaded, another thread
         --   may have already populated this value.
         private_upd;
   end;
   return;
   util.trc_time_interval('actions_dml.load_dim ID:' || dim_tab.id, start_tstamp);
end load_dim;
----------
function load_dim
      (dim_tab  in out nocopy  actions%ROWTYPE
      ) return varchar2
is
begin
   load_dim(dim_tab);
   return '';
exception when others then return sqlerrm;
end load_dim;
----------------------------------------
end actions_dml;
/
select 'ACTIONS_DML' as "Package Body:"
 from  user_errors
 where name  = 'ACTIONS_DML'
  and  type  = 'PACKAGE BODY'
  and  rownum = 1
/
select '('||line||'/'||position||') '||text as error
 from  user_errors
 where name = 'ACTIONS_DML'
  and  type = 'PACKAGE BODY'
 order by sequence
/

create TRIGGER actions_act_ioi
   instead of insert on actions_act
   for each row
declare

   -- Trigger Actions_Act_Ioi

   -- Application: Clue Notes For Oracle
   -- Generated by DTGen (http://dmstex.com/services/dtgen)
   -- December  16, 2013  11:32:31 AM

   --
   --
   -- © Duane.Dieterich@DMSTEX.com 2013
   --
   -- All Rights Reserved
   --
   -- No part of this software may be reproduced, copied, modified or adapted,
   -- without the prior written consent of the author, unless otherwise
   -- indicated for stand-alone materials.
   --
   -- You may quote extracts from this software with attribution to
   -- Duane.Dieterich@DMSTEX.com
   --
   -- For any other mode of sharing, please contact Duane.Dieterich@DMSTEX.com.
   --
   -- Commercial use and distribution of this software is not allowed without
   -- express and prior written consent of the author.
   --
   -- THE SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
   -- INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY
   -- AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL
   -- THE COPYRIGHT HOLDER OR DMSTEX BUSINESS SOLUTIONS LLC, ITS MEMBERS,
   -- MANAGERS, OR EMPLOYEES BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
   -- SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
   -- TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
   -- PROFITS; CORRUPTION OF DATA, OR BUSINESS INTERRUPTION) HOWEVER CAUSED
   -- AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
   -- OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF
   -- THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH
   -- DAMAGE.
   --
   --


   new_rec  actions_act%ROWTYPE;
   start_tstamp  timestamp := systimestamp;
begin
   new_rec.id := :new.id;
   new_rec.actions_sub_type := :new.actions_sub_type;
   new_rec.player_id := :new.player_id;
   new_rec.players_nk1 := :new.players_nk1;
   new_rec.players_nk2 := :new.players_nk2;
   new_rec.players_nk3 := :new.players_nk3;
   new_rec.seq := :new.seq;
   new_rec.resolved := :new.resolved;
   new_rec.res_action_id := :new.res_action_id;
   new_rec.res_id_path := :new.res_id_path;
   new_rec.res_nk_path := :new.res_nk_path;
   new_rec.res_actions_nk1 := :new.res_actions_nk1;
   new_rec.res_actions_nk2 := :new.res_actions_nk2;
   new_rec.res_actions_nk3 := :new.res_actions_nk3;
   new_rec.res_actions_nk4 := :new.res_actions_nk4;
   new_rec.rev_player_id := :new.rev_player_id;
   new_rec.rev_players_nk1 := :new.rev_players_nk1;
   new_rec.rev_players_nk2 := :new.rev_players_nk2;
   new_rec.rev_players_nk3 := :new.rev_players_nk3;
   actions_dml.ins(new_rec, FALSE);
   util.trc_time_interval('actions_act_ioi trigger ID:' || :new.id, start_tstamp);
end actions_act_ioi;
/
select 'ACTIONS_ACT_IOI' as "Trigger:"
 from  user_errors
 where name  = 'ACTIONS_ACT_IOI'
  and  type  = 'TRIGGER'
  and  rownum = 1
/
select '('||line||'/'||position||') '||text as error
 from  user_errors
 where name = 'ACTIONS_ACT_IOI'
  and  type = 'TRIGGER'
 order by sequence
/

create TRIGGER actions_act_iou
   instead of update on actions_act
   for each row
declare

   -- Trigger Actions_Act_Iou

   -- Application: Clue Notes For Oracle
   -- Generated by DTGen (http://dmstex.com/services/dtgen)
   -- December  16, 2013  11:32:31 AM

   --
   --
   -- © Duane.Dieterich@DMSTEX.com 2013
   --
   -- All Rights Reserved
   --
   -- No part of this software may be reproduced, copied, modified or adapted,
   -- without the prior written consent of the author, unless otherwise
   -- indicated for stand-alone materials.
   --
   -- You may quote extracts from this software with attribution to
   -- Duane.Dieterich@DMSTEX.com
   --
   -- For any other mode of sharing, please contact Duane.Dieterich@DMSTEX.com.
   --
   -- Commercial use and distribution of this software is not allowed without
   -- express and prior written consent of the author.
   --
   -- THE SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
   -- INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY
   -- AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL
   -- THE COPYRIGHT HOLDER OR DMSTEX BUSINESS SOLUTIONS LLC, ITS MEMBERS,
   -- MANAGERS, OR EMPLOYEES BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
   -- SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
   -- TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
   -- PROFITS; CORRUPTION OF DATA, OR BUSINESS INTERRUPTION) HOWEVER CAUSED
   -- AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
   -- OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF
   -- THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH
   -- DAMAGE.
   --
   --


   old_rec  actions_act%ROWTYPE;
   new_rec  actions_act%ROWTYPE;
   start_tstamp  timestamp := systimestamp;
begin
   -- NOTE: Column Specified Update DML works without this lock
   --select btab.id into new_rec.id from actions btab
   -- where btab.id = :old.id for update;
   old_rec.id := :old.id;
   new_rec.id := :new.id;
   old_rec.actions_sub_type := :old.actions_sub_type;
   new_rec.actions_sub_type := :new.actions_sub_type;
   old_rec.player_id := :old.player_id;
   new_rec.player_id := :new.player_id;
   old_rec.players_nk1 := :old.players_nk1;
   new_rec.players_nk1 := :new.players_nk1;
   old_rec.players_nk2 := :old.players_nk2;
   new_rec.players_nk2 := :new.players_nk2;
   old_rec.players_nk3 := :old.players_nk3;
   new_rec.players_nk3 := :new.players_nk3;
   old_rec.seq := :old.seq;
   new_rec.seq := :new.seq;
   old_rec.resolved := :old.resolved;
   new_rec.resolved := :new.resolved;
   old_rec.res_action_id := :old.res_action_id;
   new_rec.res_action_id := :new.res_action_id;
   old_rec.res_id_path := :old.res_id_path;
   new_rec.res_id_path := :new.res_id_path;
   old_rec.res_nk_path := :old.res_nk_path;
   new_rec.res_nk_path := :new.res_nk_path;
   old_rec.res_actions_nk1 := :old.res_actions_nk1;
   new_rec.res_actions_nk1 := :new.res_actions_nk1;
   old_rec.res_actions_nk2 := :old.res_actions_nk2;
   new_rec.res_actions_nk2 := :new.res_actions_nk2;
   old_rec.res_actions_nk3 := :old.res_actions_nk3;
   new_rec.res_actions_nk3 := :new.res_actions_nk3;
   old_rec.res_actions_nk4 := :old.res_actions_nk4;
   new_rec.res_actions_nk4 := :new.res_actions_nk4;
   old_rec.rev_player_id := :old.rev_player_id;
   new_rec.rev_player_id := :new.rev_player_id;
   old_rec.rev_players_nk1 := :old.rev_players_nk1;
   new_rec.rev_players_nk1 := :new.rev_players_nk1;
   old_rec.rev_players_nk2 := :old.rev_players_nk2;
   new_rec.rev_players_nk2 := :new.rev_players_nk2;
   old_rec.rev_players_nk3 := :old.rev_players_nk3;
   new_rec.rev_players_nk3 := :new.rev_players_nk3;
   actions_dml.upd(old_rec, new_rec);
   util.trc_time_interval('actions_act_iou trigger ID:' || :old.id, start_tstamp);
end actions_act_iou;
/
select 'ACTIONS_ACT_IOU' as "Trigger:"
 from  user_errors
 where name  = 'ACTIONS_ACT_IOU'
  and  type  = 'TRIGGER'
  and  rownum = 1
/
select '('||line||'/'||position||') '||text as error
 from  user_errors
 where name = 'ACTIONS_ACT_IOU'
  and  type = 'TRIGGER'
 order by sequence
/

create TRIGGER actions_act_iod
   instead of delete on actions_act
   for each row
declare

   -- Trigger Actions_Act_Iod

   -- Application: Clue Notes For Oracle
   -- Generated by DTGen (http://dmstex.com/services/dtgen)
   -- December  16, 2013  11:32:31 AM

   --
   --
   -- © Duane.Dieterich@DMSTEX.com 2013
   --
   -- All Rights Reserved
   --
   -- No part of this software may be reproduced, copied, modified or adapted,
   -- without the prior written consent of the author, unless otherwise
   -- indicated for stand-alone materials.
   --
   -- You may quote extracts from this software with attribution to
   -- Duane.Dieterich@DMSTEX.com
   --
   -- For any other mode of sharing, please contact Duane.Dieterich@DMSTEX.com.
   --
   -- Commercial use and distribution of this software is not allowed without
   -- express and prior written consent of the author.
   --
   -- THE SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
   -- INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY
   -- AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL
   -- THE COPYRIGHT HOLDER OR DMSTEX BUSINESS SOLUTIONS LLC, ITS MEMBERS,
   -- MANAGERS, OR EMPLOYEES BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
   -- SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
   -- TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
   -- PROFITS; CORRUPTION OF DATA, OR BUSINESS INTERRUPTION) HOWEVER CAUSED
   -- AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
   -- OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF
   -- THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH
   -- DAMAGE.
   --
   --


   start_tstamp  timestamp := systimestamp;
begin
   actions_tab.del(:old.id);
   util.trc_time_interval('actions_act_iod trigger ID:' || :old.id, start_tstamp);
end actions_act_iod;
/
select 'ACTIONS_ACT_IOD' as "Trigger:"
 from  user_errors
 where name  = 'ACTIONS_ACT_IOD'
  and  type  = 'TRIGGER'
  and  rownum = 1
/
select '('||line||'/'||position||') '||text as error
 from  user_errors
 where name = 'ACTIONS_ACT_IOD'
  and  type = 'TRIGGER'
 order by sequence
/


create view action_cards_act
      (id
      ,action_id
      ,actions_nk1
      ,actions_nk2
      ,actions_nk3
      ,actions_nk4
      ,card_id
      ,cards_nk1
      ,cards_nk2
      ,cards_nk3
      )
   as select
       ACTC.id
      ,ACTC.action_id
      ,ACT.players_nk1
      ,ACT.players_nk2
      ,ACT.players_nk3
      ,ACT.seq
      ,ACTC.card_id
      ,CRD.games_nk1
      ,CRD.games_nk2
      ,CRD.name
 from             action_cards ACTC
       inner join actions_a ACT on ACT.id = ACTC.action_id
       inner join cards_act CRD on CRD.id = ACTC.card_id
/
select 'ACTION_CARDS_ACT' as "View:"
 from  user_errors
 where name  = 'ACTION_CARDS_ACT'
  and  type  = 'VIEW'
  and  rownum = 1
/
select '('||line||'/'||position||') '||text as error
 from  user_errors
 where name = 'ACTION_CARDS_ACT'
  and  type = 'VIEW'
 order by sequence
/

comment on table action_cards_act is 'Player''s Card Suggestions for each User''s Game'
/

comment on column action_cards_act.id is 'Surrogate Primary Key for these action_cards'
/
comment on column action_cards_act.action_id is 'Action for this Card'
/
comment on column action_cards_act.actions_nk1 is 'ACTIONS Natural Key 1: PLAYERS NK1: GAMES NK1: USERS NK1: Clue Notes User Name'
/
comment on column action_cards_act.actions_nk2 is 'ACTIONS Natural Key 2: PLAYERS NK2: GAMES NK2: User''s Game Name'
/
comment on column action_cards_act.actions_nk3 is 'ACTIONS Natural Key 3: PLAYERS NK3: Player''s Name'
/
comment on column action_cards_act.actions_nk4 is 'ACTIONS Natural Key 4: Sequence Number for this Action'
/
comment on column action_cards_act.card_id is 'Card for this Action'
/
comment on column action_cards_act.cards_nk1 is 'CARDS Natural Key 1: GAMES NK1: USERS NK1: Clue Notes User Name'
/
comment on column action_cards_act.cards_nk2 is 'CARDS Natural Key 2: GAMES NK2: User''s Game Name'
/
comment on column action_cards_act.cards_nk3 is 'CARDS Natural Key 3: Card Name'
/

alter view action_cards_act add constraint action_cards_act_pk
   primary key (id) disable
/

alter view action_cards_act add constraint action_cards_act_fk1
   foreign key (action_id) references actions_act (id) disable
/
alter view action_cards_act add constraint action_cards_act_fk2
   foreign key (card_id) references cards_act (id) disable
/

CREATE type action_cards_vobj
is
   -- Action_Cards Active View (Virtual) Record Type
object
   (id  NUMBER(38)
   ,action_id  NUMBER(38)
   ,actions_nk1  VARCHAR2(320)
   ,actions_nk2  VARCHAR2(320)
   ,actions_nk3  VARCHAR2(15)
   ,actions_nk4  NUMBER(3)
   ,card_id  NUMBER(38)
   ,cards_nk1  VARCHAR2(320)
   ,cards_nk2  VARCHAR2(320)
   ,cards_nk3  VARCHAR2(15)
   )
/
select 'ACTION_CARDS_VOBJ' as "Type:"
 from  user_errors
 where name  = 'ACTION_CARDS_VOBJ'
  and  type  = 'TYPE'
  and  rownum = 1
/
select '('||line||'/'||position||') '||text as error
 from  user_errors
 where name = 'ACTION_CARDS_VOBJ'
  and  type = 'TYPE'
 order by sequence
/

CREATE type action_cards_vtab
is
   -- Action_Cards Active View (Virtual) Table Type
table of action_cards_vobj
/
select 'ACTION_CARDS_VTAB' as "Type:"
 from  user_errors
 where name  = 'ACTION_CARDS_VTAB'
  and  type  = 'TYPE'
  and  rownum = 1
/
select '('||line||'/'||position||') '||text as error
 from  user_errors
 where name = 'ACTION_CARDS_VTAB'
  and  type = 'TYPE'
 order by sequence
/

create package action_cards_dml
is

   -- Package Action_Cards_Dml
   -- (Data Manipulation Language, Foreign Key and Path Lookup)

   -- Application: Clue Notes For Oracle
   -- Generated by DTGen (http://dmstex.com/services/dtgen)
   -- December  16, 2013  11:32:31 AM

   --
   --
   -- © Duane.Dieterich@DMSTEX.com 2013
   --
   -- All Rights Reserved
   --
   -- No part of this software may be reproduced, copied, modified or adapted,
   -- without the prior written consent of the author, unless otherwise
   -- indicated for stand-alone materials.
   --
   -- You may quote extracts from this software with attribution to
   -- Duane.Dieterich@DMSTEX.com
   --
   -- For any other mode of sharing, please contact Duane.Dieterich@DMSTEX.com.
   --
   -- Commercial use and distribution of this software is not allowed without
   -- express and prior written consent of the author.
   --
   -- THE SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
   -- INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY
   -- AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL
   -- THE COPYRIGHT HOLDER OR DMSTEX BUSINESS SOLUTIONS LLC, ITS MEMBERS,
   -- MANAGERS, OR EMPLOYEES BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
   -- SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
   -- TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
   -- PROFITS; CORRUPTION OF DATA, OR BUSINESS INTERRUPTION) HOWEVER CAUSED
   -- AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
   -- OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF
   -- THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH
   -- DAMAGE.
   --
   --


   -- Return the next Surrogate Key ID for action_cards
   function get_next_id
      return NUMBER;
   -- Return the current Surrogate Key ID for action_cards
   --   NOTE: This will return an ERROR if get_next_id has not been called
   function get_curr_id
      return NUMBER;

   -- Return the next Surrogate Key ID for the Natural Keys of action_cards
   --   NOTE: The fields used in this function are the Natural Keys for action_cards
   --         Alternatively, the Natural Key IDs for action_cards are:
   --            -) action_id
   --            -) card_id
   function get_id
      (actions_nk1  in  VARCHAR2
      ,actions_nk2  in  VARCHAR2
      ,actions_nk3  in  VARCHAR2
      ,actions_nk4  in  NUMBER
      ,cards_nk1  in  VARCHAR2
      ,cards_nk2  in  VARCHAR2
      ,cards_nk3  in  VARCHAR2
      ) return NUMBER;
   -- For all the Natural Key Column IDs, Return an ID
   function get_id2
      (action_id_in  in  NUMBER
      ,card_id_in  in  NUMBER
      ) return NUMBER;
   -- Return a concatenated string of Natural Keys for a action_cards id
   function get_nk
      (id_in  in  NUMBER
      ) return VARCHAR2;

   -- Set a "view" record to null
   procedure clear
      (n_rec  in out nocopy  action_cards_ACT%ROWTYPE
      );
   -- This function traps and returns any error message from the clear procedure
   function clear
      (n_rec  in out nocopy  action_cards_ACT%ROWTYPE
      ) return varchar2;
   -- Set a "table" record to null
   procedure clear
      (n_tab  in out nocopy  action_cards%ROWTYPE
      );
   -- This function traps and returns any error message from the clear procedure
   function clear
      (n_tab  in out nocopy  action_cards%ROWTYPE
      ) return varchar2;

   -- Set a "view" record from a action_cards ID
   procedure get_rec_by_id
      (n_rec  in out nocopy  action_cards_ACT%ROWTYPE
      );
   -- This function traps and returns any error message from the get_rec_by_id procedure
   function get_rec_by_id
      (n_rec  in out nocopy  action_cards_ACT%ROWTYPE
      ) return varchar2;
   -- Set a "table" record from a action_cards ID
   procedure get_rec_by_id
      (n_tab  in out nocopy  action_cards%ROWTYPE
      );
   -- This function traps and returns any error message from the get_rec_by_id procedure
   function get_rec_by_id
      (n_tab  in out nocopy  action_cards%ROWTYPE
      ) return varchar2;

   -- NOTE: All INS procedures will run faster with a null ID
   --       because it avoids a history search for duplicate IDs
   --
   -- Insert a action_cards ACTIVE View Record
   -- NOTE: If UPD_VALS_IN is set to FALSE, the function will run faster,
   --       but the returned record may contain invalid data
   procedure ins
      (new_rec  in out nocopy  action_cards_act%ROWTYPE
      ,upd_vals_in  in  boolean default TRUE
      );
   -- This function traps and returns any error message from the ins procedure
   function ins
      (new_rec  in out nocopy  action_cards_act%ROWTYPE
      ,upd_vals_in  in  boolean default TRUE
      ) return varchar2;
   -- Insert a action_cards Table Record
   --  (Fastest insert procedure and returned data is always valid)
   procedure ins
      (new_tab  in out nocopy  action_cards%ROWTYPE
      );
   -- This function traps and returns any error message from the ins procedure
   function ins
      (new_tab  in out nocopy  action_cards%ROWTYPE
      ) return varchar2;
   -- Insert columns for action_cards ACTIVE View
   --   without returning updated data in each column
   procedure ins
      (id_in  in  NUMBER default null
      ,action_id_in  in  NUMBER default null
      ,actions_nk1_in  in  VARCHAR2 default null
      ,actions_nk2_in  in  VARCHAR2 default null
      ,actions_nk3_in  in  VARCHAR2 default null
      ,actions_nk4_in  in  NUMBER default null
      ,card_id_in  in  NUMBER default null
      ,cards_nk1_in  in  VARCHAR2 default null
      ,cards_nk2_in  in  VARCHAR2 default null
      ,cards_nk3_in  in  VARCHAR2 default null
      );
   -- This function traps and returns any error message from the ins procedure
   function ins
      (id_in  in  NUMBER default null
      ,action_id_in  in  NUMBER default null
      ,actions_nk1_in  in  VARCHAR2 default null
      ,actions_nk2_in  in  VARCHAR2 default null
      ,actions_nk3_in  in  VARCHAR2 default null
      ,actions_nk4_in  in  NUMBER default null
      ,card_id_in  in  NUMBER default null
      ,cards_nk1_in  in  VARCHAR2 default null
      ,cards_nk2_in  in  VARCHAR2 default null
      ,cards_nk3_in  in  VARCHAR2 default null
      ) return varchar2;
   -- Insert columns for action_cards ACTIVE View
   --   with updated data returned in each column
   procedure ins2
      (id_io  in out nocopy  NUMBER
      ,action_id_io  in out nocopy  NUMBER
      ,actions_nk1_io  in out nocopy  VARCHAR2
      ,actions_nk2_io  in out nocopy  VARCHAR2
      ,actions_nk3_io  in out nocopy  VARCHAR2
      ,actions_nk4_io  in out nocopy  NUMBER
      ,card_id_io  in out nocopy  NUMBER
      ,cards_nk1_io  in out nocopy  VARCHAR2
      ,cards_nk2_io  in out nocopy  VARCHAR2
      ,cards_nk3_io  in out nocopy  VARCHAR2
      );
   -- This function traps and returns any error message from the ins2 procedure
   function ins2
      (id_io  in out nocopy  NUMBER
      ,action_id_io  in out nocopy  NUMBER
      ,actions_nk1_io  in out nocopy  VARCHAR2
      ,actions_nk2_io  in out nocopy  VARCHAR2
      ,actions_nk3_io  in out nocopy  VARCHAR2
      ,actions_nk4_io  in out nocopy  NUMBER
      ,card_id_io  in out nocopy  NUMBER
      ,cards_nk1_io  in out nocopy  VARCHAR2
      ,cards_nk2_io  in out nocopy  VARCHAR2
      ,cards_nk3_io  in out nocopy  VARCHAR2
      ) return varchar2;
   -- Insert columns for action_cards Table
   --   with updated data returned in each column
   procedure ins2
      (id_io  in out nocopy  NUMBER
      ,action_id_io  in out nocopy  NUMBER
      ,card_id_io  in out nocopy  NUMBER
      );
   -- This function traps and returns any error message from the ins2 procedure
   function ins2
      (id_io  in out nocopy  NUMBER
      ,action_id_io  in out nocopy  NUMBER
      ,card_id_io  in out nocopy  NUMBER
      ) return varchar2;

   -- Special Use Update for Specific Column Updates.
   --   Only differences between old and new data will be updated.
   --   Set upd_val_in TRUE to get updated data in new_rec
   procedure upd
      (old_rec  in  action_cards_act%ROWTYPE
      ,new_rec  in out nocopy  action_cards_act%ROWTYPE
      ,upd_vals_in  in  boolean default FALSE
      );
   -- This function traps and returns any error message from the upd procedure
   function upd
      (old_rec  in  action_cards_act%ROWTYPE
      ,new_rec  in out nocopy  action_cards_act%ROWTYPE
      ,upd_vals_in  in  boolean default FALSE
      ) return varchar2;
   -- Special Use Update for Specific Column Updates.
   --   Only differences between old and new data will be updated.
   --   Set upd_val_in TRUE to get updated data in new_rec
   procedure upd
      (old_tab  in  action_cards%ROWTYPE
      ,new_tab  in out nocopy  action_cards%ROWTYPE
      );
   -- This function traps and returns any error message from the upd procedure
   function upd
      (old_tab  in  action_cards%ROWTYPE
      ,new_tab  in out nocopy  action_cards%ROWTYPE
      ) return varchar2;
   -- Update a action_cards ACTIVE View Record
   -- NOTE: If UPD_VALS_IN is set to FALSE, the returned record
   --       may contain invalid data
   -- NOTE: Only FK NKs that are part of this NK will be used to find
   --       this ID from its NKs (FK IDs will be ignored)
   procedure upd
      (new_rec  in out nocopy  action_cards_act%ROWTYPE
      ,upd_vals_in  in  boolean default TRUE
      );
   -- This function traps and returns any error message from the upd procedure
   function upd
      (new_rec  in out nocopy  action_cards_act%ROWTYPE
      ,upd_vals_in  in  boolean default TRUE
      ) return varchar2;
   -- Update a action_cards Table Record
   --  (Fastest update procedure and returned data is always valid)
   -- NOTE: action_cardsID must be supplied (NK lookup will not be performed)
   procedure upd
      (new_tab  in out nocopy  action_cards%ROWTYPE
      );
   -- This function traps and returns any error message from the upd procedure
   function upd
      (new_tab  in out nocopy  action_cards%ROWTYPE
      ) return varchar2;
   -- Update columns for action_cards ACTIVE View
   --   without returning updated data in each column
   procedure upd
      (id_in  in  NUMBER default null
      ,action_id_in  in  NUMBER default null
      ,actions_nk1_in  in  VARCHAR2 default null
      ,actions_nk2_in  in  VARCHAR2 default null
      ,actions_nk3_in  in  VARCHAR2 default null
      ,actions_nk4_in  in  NUMBER default null
      ,card_id_in  in  NUMBER default null
      ,cards_nk1_in  in  VARCHAR2 default null
      ,cards_nk2_in  in  VARCHAR2 default null
      ,cards_nk3_in  in  VARCHAR2 default null
      );
   -- This function traps and returns any error message from the upd procedure
   function upd
      (id_in  in  NUMBER default null
      ,action_id_in  in  NUMBER default null
      ,actions_nk1_in  in  VARCHAR2 default null
      ,actions_nk2_in  in  VARCHAR2 default null
      ,actions_nk3_in  in  VARCHAR2 default null
      ,actions_nk4_in  in  NUMBER default null
      ,card_id_in  in  NUMBER default null
      ,cards_nk1_in  in  VARCHAR2 default null
      ,cards_nk2_in  in  VARCHAR2 default null
      ,cards_nk3_in  in  VARCHAR2 default null
      ) return varchar2;
   -- Update columns for action_cards ACTIVE View
   --   with updated data returned in each column
   procedure upd2
      (id_io  in out nocopy  NUMBER
      ,action_id_io  in out nocopy  NUMBER
      ,actions_nk1_io  in out nocopy  VARCHAR2
      ,actions_nk2_io  in out nocopy  VARCHAR2
      ,actions_nk3_io  in out nocopy  VARCHAR2
      ,actions_nk4_io  in out nocopy  NUMBER
      ,card_id_io  in out nocopy  NUMBER
      ,cards_nk1_io  in out nocopy  VARCHAR2
      ,cards_nk2_io  in out nocopy  VARCHAR2
      ,cards_nk3_io  in out nocopy  VARCHAR2
      );
   -- This function traps and returns any error message from the upd2 procedure
   function upd2
      (id_io  in out nocopy  NUMBER
      ,action_id_io  in out nocopy  NUMBER
      ,actions_nk1_io  in out nocopy  VARCHAR2
      ,actions_nk2_io  in out nocopy  VARCHAR2
      ,actions_nk3_io  in out nocopy  VARCHAR2
      ,actions_nk4_io  in out nocopy  NUMBER
      ,card_id_io  in out nocopy  NUMBER
      ,cards_nk1_io  in out nocopy  VARCHAR2
      ,cards_nk2_io  in out nocopy  VARCHAR2
      ,cards_nk3_io  in out nocopy  VARCHAR2
      ) return varchar2;
   -- Update columns for action_cards Table
   --   with updated data returned in each column
   procedure upd2
      (id_io  in out nocopy  NUMBER
      ,action_id_io  in out nocopy  NUMBER
      ,card_id_io  in out nocopy  NUMBER
      );
   -- This function traps and returns any error message from the upd2 procedure
   function upd2
      (id_io  in out nocopy  NUMBER
      ,action_id_io  in out nocopy  NUMBER
      ,card_id_io  in out nocopy  NUMBER
      ) return varchar2;

   -- Application Delete procedure without updated parameters
   procedure del
      (id_in  in  NUMBER default null
      ,action_id_in  in  NUMBER default null
      ,actions_nk1_in  in  VARCHAR2 default null
      ,actions_nk2_in  in  VARCHAR2 default null
      ,actions_nk3_in  in  VARCHAR2 default null
      ,actions_nk4_in  in  NUMBER default null
      ,card_id_in  in  NUMBER default null
      ,cards_nk1_in  in  VARCHAR2 default null
      ,cards_nk2_in  in  VARCHAR2 default null
      ,cards_nk3_in  in  VARCHAR2 default null
      );
   -- This function traps and returns any error message from the del procedure
   function del
      (id_in  in  NUMBER default null
      ,action_id_in  in  NUMBER default null
      ,actions_nk1_in  in  VARCHAR2 default null
      ,actions_nk2_in  in  VARCHAR2 default null
      ,actions_nk3_in  in  VARCHAR2 default null
      ,actions_nk4_in  in  NUMBER default null
      ,card_id_in  in  NUMBER default null
      ,cards_nk1_in  in  VARCHAR2 default null
      ,cards_nk2_in  in  VARCHAR2 default null
      ,cards_nk3_in  in  VARCHAR2 default null
      ) return varchar2;
   -- Application Delete procedure with updated parameters
   procedure del2
      (id_io  in out nocopy  NUMBER
      ,action_id_in  in NUMBER default null
      ,actions_nk1_in  in VARCHAR2 default null
      ,actions_nk2_in  in VARCHAR2 default null
      ,actions_nk3_in  in VARCHAR2 default null
      ,actions_nk4_in  in NUMBER default null
      ,card_id_in  in NUMBER default null
      ,cards_nk1_in  in VARCHAR2 default null
      ,cards_nk2_in  in VARCHAR2 default null
      ,cards_nk3_in  in VARCHAR2 default null
      );
   -- This function traps and returns any error message from the del2 procedure
   function del2
      (id_io  in out nocopy  NUMBER
      ,action_id_in  in NUMBER default null
      ,actions_nk1_in  in VARCHAR2 default null
      ,actions_nk2_in  in VARCHAR2 default null
      ,actions_nk3_in  in VARCHAR2 default null
      ,actions_nk4_in  in NUMBER default null
      ,card_id_in  in NUMBER default null
      ,cards_nk1_in  in VARCHAR2 default null
      ,cards_nk2_in  in VARCHAR2 default null
      ,cards_nk3_in  in VARCHAR2 default null
      ) return varchar2;

   -- Special Data Warehouse Dimension Function
   --   Attempts to find matching record based on natural keys
   --   If found, performs updates on non-NK columns that changed
   --   If not found, inserts new record
   --   Returns ID of record
   procedure load_dim
      (dim_tab  in out nocopy  action_cards%ROWTYPE
      );
   -- This function traps and returns any error message from the load_dim procedure
   function load_dim
      (dim_tab  in out nocopy  action_cards%ROWTYPE
      ) return varchar2;

end action_cards_dml;
/
select 'ACTION_CARDS_DML' as "Package:"
 from  user_errors
 where name  = 'ACTION_CARDS_DML'
  and  type  = 'PACKAGE'
  and  rownum = 1
/
select '('||line||'/'||position||') '||text as error
 from  user_errors
 where name = 'ACTION_CARDS_DML'
  and  type = 'PACKAGE'
 order by sequence
/

create package body action_cards_dml
is

 -- Package Body Action_Cards_Dml
 -- (Data Manipulation Language, Foreign Key and Path Lookup)

   -- Application: Clue Notes For Oracle
   -- Generated by DTGen (http://dmstex.com/services/dtgen)
   -- December  16, 2013  11:32:31 AM

   --
   --
   -- © Duane.Dieterich@DMSTEX.com 2013
   --
   -- All Rights Reserved
   --
   -- No part of this software may be reproduced, copied, modified or adapted,
   -- without the prior written consent of the author, unless otherwise
   -- indicated for stand-alone materials.
   --
   -- You may quote extracts from this software with attribution to
   -- Duane.Dieterich@DMSTEX.com
   --
   -- For any other mode of sharing, please contact Duane.Dieterich@DMSTEX.com.
   --
   -- Commercial use and distribution of this software is not allowed without
   -- express and prior written consent of the author.
   --
   -- THE SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
   -- INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY
   -- AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL
   -- THE COPYRIGHT HOLDER OR DMSTEX BUSINESS SOLUTIONS LLC, ITS MEMBERS,
   -- MANAGERS, OR EMPLOYEES BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
   -- SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
   -- TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
   -- PROFITS; CORRUPTION OF DATA, OR BUSINESS INTERRUPTION) HOWEVER CAUSED
   -- AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
   -- OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF
   -- THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH
   -- DAMAGE.
   --
   --


----------------------------------------
function get_next_id
      return NUMBER
is
   retid  NUMBER;
begin
   select action_cards_seq.nextval
    into  retid from dual;
   return retid;
end get_next_id;
----------------------------------------
function get_curr_id
      return NUMBER
is
   retid  NUMBER;
begin
   select action_cards_seq.currval
    into  retid from dual;
   return retid;
end get_curr_id;
----------------------------------------
function get_id
      (actions_nk1  in  VARCHAR2
      ,actions_nk2  in  VARCHAR2
      ,actions_nk3  in  VARCHAR2
      ,actions_nk4  in  NUMBER
      ,cards_nk1  in  VARCHAR2
      ,cards_nk2  in  VARCHAR2
      ,cards_nk3  in  VARCHAR2
      ) return number
   -- For all the Natural Key Columns, Return an ID
is
begin
   return action_cards_tab.get_id
      (actions_nk1
      ,actions_nk2
      ,actions_nk3
      ,actions_nk4
      ,cards_nk1
      ,cards_nk2
      ,cards_nk3
      );
end get_id;
----------------------------------------
-- For all the Natural Key Column IDs, Return an ID
function get_id2
      (action_id_in  in  NUMBER
      ,card_id_in  in  NUMBER
      ) return NUMBER
is
   retid  NUMBER(38);
begin
   select id
    into  retid
    from  action_cards  ACTC
    where action_id_in = ACTC.action_id
     and  card_id_in = ACTC.card_id
    ;
   return retid;
exception when no_data_found then return null;
end get_id2;
----------------------------------------
function get_nk
      (id_in  in  NUMBER)
   return VARCHAR2
   -- For an ID, return a delimited list of Natural Key Values
is
begin
   return action_cards_tab.get_nk(id_in);
end get_nk;
----------------------------------------
procedure clear
      (n_rec  in out nocopy  action_cards_act%ROWTYPE
      )
is
begin
   n_rec.id := null;
   n_rec.action_id := null;
   n_rec.actions_nk1 := null;
   n_rec.actions_nk2 := null;
   n_rec.actions_nk3 := null;
   n_rec.actions_nk4 := null;
   n_rec.card_id := null;
   n_rec.cards_nk1 := null;
   n_rec.cards_nk2 := null;
   n_rec.cards_nk3 := null;
end clear;
----------
function clear
      (n_rec  in out nocopy  action_cards_act%ROWTYPE
      ) return varchar2
is
begin
   clear(n_rec);
   return '';
exception when others then return sqlerrm;
end clear;
----------------------------------------
procedure clear
      (n_tab  in out nocopy  action_cards%ROWTYPE
      )
is
begin
   n_tab.id := null;
   n_tab.action_id := null;
   n_tab.card_id := null;
end clear;
----------
function clear
      (n_tab  in out nocopy  action_cards%ROWTYPE
      ) return varchar2
is
begin
   clear(n_tab);
   return '';
exception when others then return sqlerrm;
end clear;
----------------------------------------
procedure get_rec_by_id
      (n_rec  in out nocopy  action_cards_act%ROWTYPE
      )
is
   start_tstamp  timestamp := systimestamp;
begin
   if n_rec.id is null then
      clear(n_rec);
   else
      select * into n_rec from action_cards_act
       where id = n_rec.id;
   end if;
   return;
   util.trc_time_interval('action_cards_dml.get_rec_by_id(act rec) ID:' || n_rec.id, start_tstamp);
end get_rec_by_id;
----------
function get_rec_by_id
      (n_rec  in out nocopy  action_cards_act%ROWTYPE
      ) return varchar2
is
begin
   get_rec_by_id(n_rec);
   return '';
exception when others then return sqlerrm;
end get_rec_by_id;
----------------------------------------
procedure get_rec_by_id
      (n_tab  in out nocopy  action_cards%ROWTYPE
      )
is
   start_tstamp  timestamp := systimestamp;
begin
   if n_tab.id is null then
      clear(n_tab);
   else
      select * into n_tab from action_cards
       where id = n_tab.id;
   end if;
   return;
   util.trc_time_interval('action_cards_dml.get_rec_by_id(tab rec) ID:' || n_tab.id, start_tstamp);
end get_rec_by_id;
----------
function get_rec_by_id
      (n_tab  in out nocopy  action_cards%ROWTYPE
      ) return varchar2
is
begin
   get_rec_by_id(n_tab);
   return '';
exception when others then return sqlerrm;
end get_rec_by_id;
----------------------------------------
-- Insert a action_cards ACTIVE View Record
procedure ins
      (new_rec  in out nocopy  action_cards_act%ROWTYPE
      ,upd_vals_in  in  boolean default TRUE
      )
is
   new_tab  action_cards%ROWTYPE;
   start_tstamp  timestamp := systimestamp;
begin
   -- Set new_rec.action_id, if needed
   if new_rec.action_id is null then
      if    new_rec.actions_nk1 is not null
        and new_rec.actions_nk2 is not null
        and new_rec.actions_nk3 is not null
        and new_rec.actions_nk4 is not null
      then
         new_rec.action_id := actions_tab.get_id
            (new_rec.actions_nk1
            ,new_rec.actions_nk2
            ,new_rec.actions_nk3
            ,new_rec.actions_nk4
            );
         if new_rec.action_id is null then
            raise_application_error(-20020, 'Null ID was returned from actions_tab.get_id');
         end if;
      end if;
   end if;
   -- Set new_rec.card_id, if needed
   if new_rec.card_id is null then
      if    new_rec.cards_nk1 is not null
        and new_rec.cards_nk2 is not null
        and new_rec.cards_nk3 is not null
      then
         new_rec.card_id := cards_tab.get_id
            (new_rec.cards_nk1
            ,new_rec.cards_nk2
            ,new_rec.cards_nk3
            );
         if new_rec.card_id is null then
            raise_application_error(-20020, 'Null ID was returned from cards_tab.get_id');
         end if;
      end if;
   end if;
   new_tab.id := new_rec.id;
   new_tab.action_id := new_rec.action_id;
   new_tab.card_id := new_rec.card_id;
   action_cards_tab.ins(new_tab);
   if upd_vals_in then
      -- action_cards_tab.ins returns a new ID, if needed
      select * into new_rec from action_cards_act
       where id = new_tab.id;
   end if;
   return;
   util.trc_time_interval('action_cards_dml.ins(act rec) ID:' || new_rec.id, start_tstamp);
end ins;
----------
function ins
      (new_rec  in out nocopy  action_cards_act%ROWTYPE
      ,upd_vals_in  in  boolean default TRUE
      ) return varchar2
is
begin
   ins(new_rec, upd_vals_in);
   return '';
exception when others then return sqlerrm;
end ins;
----------------------------------------
-- Insert a action_cards Table Record
procedure ins
      (new_tab   in out nocopy  action_cards%ROWTYPE
      )
is
   start_tstamp  timestamp := systimestamp;
begin
   action_cards_tab.ins(new_tab);
   return;
   util.trc_time_interval('action_cards_dml.ins(tab rec) ID:' || new_tab.id, start_tstamp);
end ins;
----------
function ins
      (new_tab   in out nocopy  action_cards%ROWTYPE
      ) return varchar2
is
begin
   ins(new_tab);
   return '';
exception when others then return sqlerrm;
end ins;
----------------------------------------
-- Insert columns for action_cards ACTIVE View
--   without returning updated data in each column
procedure ins
      (id_in  in  NUMBER default null
      ,action_id_in  in  NUMBER default null
      ,actions_nk1_in  in  VARCHAR2 default null
      ,actions_nk2_in  in  VARCHAR2 default null
      ,actions_nk3_in  in  VARCHAR2 default null
      ,actions_nk4_in  in  NUMBER default null
      ,card_id_in  in  NUMBER default null
      ,cards_nk1_in  in  VARCHAR2 default null
      ,cards_nk2_in  in  VARCHAR2 default null
      ,cards_nk3_in  in  VARCHAR2 default null
      )
is
   new_rec  action_cards_act%ROWTYPE;
   start_tstamp  timestamp := systimestamp;
begin
   new_rec.id := id_in;
   new_rec.action_id := action_id_in;
   new_rec.actions_nk1 := actions_nk1_in;
   new_rec.actions_nk2 := actions_nk2_in;
   new_rec.actions_nk3 := actions_nk3_in;
   new_rec.actions_nk4 := actions_nk4_in;
   new_rec.card_id := card_id_in;
   new_rec.cards_nk1 := cards_nk1_in;
   new_rec.cards_nk2 := cards_nk2_in;
   new_rec.cards_nk3 := cards_nk3_in;
   ins(new_rec, FALSE);
   return;
   util.trc_time_interval('action_cards_dml.ins(tab col) ID:' || id_in, start_tstamp);
end ins;
----------
function ins
      (id_in  in  NUMBER default null
      ,action_id_in  in  NUMBER default null
      ,actions_nk1_in  in  VARCHAR2 default null
      ,actions_nk2_in  in  VARCHAR2 default null
      ,actions_nk3_in  in  VARCHAR2 default null
      ,actions_nk4_in  in  NUMBER default null
      ,card_id_in  in  NUMBER default null
      ,cards_nk1_in  in  VARCHAR2 default null
      ,cards_nk2_in  in  VARCHAR2 default null
      ,cards_nk3_in  in  VARCHAR2 default null
      ) return varchar2
is
begin
   ins
      (id_in
      ,action_id_in
      ,actions_nk1_in
      ,actions_nk2_in
      ,actions_nk3_in
      ,actions_nk4_in
      ,card_id_in
      ,cards_nk1_in
      ,cards_nk2_in
      ,cards_nk3_in
      );
   return '';
exception when others then return sqlerrm;
end ins;
----------------------------------------
-- Insert columns for action_cards ACTIVE View
--   with updated data returned in each column
procedure ins2
      (id_io  in out nocopy  NUMBER
      ,action_id_io  in out nocopy  NUMBER
      ,actions_nk1_io  in out nocopy  VARCHAR2
      ,actions_nk2_io  in out nocopy  VARCHAR2
      ,actions_nk3_io  in out nocopy  VARCHAR2
      ,actions_nk4_io  in out nocopy  NUMBER
      ,card_id_io  in out nocopy  NUMBER
      ,cards_nk1_io  in out nocopy  VARCHAR2
      ,cards_nk2_io  in out nocopy  VARCHAR2
      ,cards_nk3_io  in out nocopy  VARCHAR2
      )
is
   new_rec  action_cards_act%ROWTYPE;
   start_tstamp  timestamp := systimestamp;
begin
   new_rec.id := id_io;
   new_rec.action_id := action_id_io;
   new_rec.actions_nk1 := actions_nk1_io;
   new_rec.actions_nk2 := actions_nk2_io;
   new_rec.actions_nk3 := actions_nk3_io;
   new_rec.actions_nk4 := actions_nk4_io;
   new_rec.card_id := card_id_io;
   new_rec.cards_nk1 := cards_nk1_io;
   new_rec.cards_nk2 := cards_nk2_io;
   new_rec.cards_nk3 := cards_nk3_io;
   --
   ins(new_rec);
   --
   id_io := new_rec.id;
   action_id_io := new_rec.action_id;
   actions_nk1_io := new_rec.actions_nk1;
   actions_nk2_io := new_rec.actions_nk2;
   actions_nk3_io := new_rec.actions_nk3;
   actions_nk4_io := new_rec.actions_nk4;
   card_id_io := new_rec.card_id;
   cards_nk1_io := new_rec.cards_nk1;
   cards_nk2_io := new_rec.cards_nk2;
   cards_nk3_io := new_rec.cards_nk3;
   return;
   util.trc_time_interval('action_cards_dml.ins2(tab col) ID:' || id_io, start_tstamp);
end ins2;
----------
function ins2
      (id_io  in out nocopy  NUMBER
      ,action_id_io  in out nocopy  NUMBER
      ,actions_nk1_io  in out nocopy  VARCHAR2
      ,actions_nk2_io  in out nocopy  VARCHAR2
      ,actions_nk3_io  in out nocopy  VARCHAR2
      ,actions_nk4_io  in out nocopy  NUMBER
      ,card_id_io  in out nocopy  NUMBER
      ,cards_nk1_io  in out nocopy  VARCHAR2
      ,cards_nk2_io  in out nocopy  VARCHAR2
      ,cards_nk3_io  in out nocopy  VARCHAR2
      ) return varchar2
is
begin
   ins2
      (id_io
      ,action_id_io
      ,actions_nk1_io
      ,actions_nk2_io
      ,actions_nk3_io
      ,actions_nk4_io
      ,card_id_io
      ,cards_nk1_io
      ,cards_nk2_io
      ,cards_nk3_io
      );
   return '';
exception when others then return sqlerrm;
end ins2;
----------------------------------------
-- Insert columns for action_cards Table
--   with updated data returned in each column
procedure ins2
      (id_io  in out nocopy  NUMBER
      ,action_id_io  in out nocopy  NUMBER
      ,card_id_io  in out nocopy  NUMBER
      )
is
   new_rec  action_cards%ROWTYPE;
   start_tstamp  timestamp := systimestamp;
begin
   new_rec.id := id_io;
   new_rec.action_id := action_id_io;
   new_rec.card_id := card_id_io;
   --
   action_cards_tab.ins(new_rec);
   --
   id_io := new_rec.id;
   action_id_io := new_rec.action_id;
   card_id_io := new_rec.card_id;
   return;
   util.trc_time_interval('action_cards_dml.ins2(tab col) ID:' || id_io, start_tstamp);
end ins2;
----------
function ins2
      (id_io  in out nocopy  NUMBER
      ,action_id_io  in out nocopy  NUMBER
      ,card_id_io  in out nocopy  NUMBER
      ) return varchar2
is
begin
   ins2
      (id_io
      ,action_id_io
      ,card_id_io
      );
   return '';
exception when others then return sqlerrm;
end ins2;
----------------------------------------
-- Special Use Update for Specific Column Updates.
--   Only differences between old and new data will be updated.
--   Set upd_val_in TRUE to get updated data in new_rec
procedure upd
      (old_rec  in  action_cards_act%ROWTYPE
      ,new_rec  in out nocopy  action_cards_act%ROWTYPE
      ,upd_vals_in  in  boolean default FALSE
      )
is
   old_tab  action_cards%ROWTYPE;
   new_tab  action_cards%ROWTYPE;
   start_tstamp  timestamp := systimestamp;
begin
   if old_rec.id is null then
      raise_application_error (-20023, 'ID is null');
   end if;
   -- Set new_rec.action_id, if needed
   if new_rec.action_id is null then
      if    new_rec.actions_nk1 is not null
        and new_rec.actions_nk2 is not null
        and new_rec.actions_nk3 is not null
        and new_rec.actions_nk4 is not null
      then
         new_rec.action_id := actions_tab.get_id
            (new_rec.actions_nk1
            ,new_rec.actions_nk2
            ,new_rec.actions_nk3
            ,new_rec.actions_nk4
            );
         if new_rec.action_id is null then
            raise_application_error(-20020, 'Null ID was returned from actions_tab.get_id');
         end if;
      end if;
   end if;
   -- Set new_rec.card_id, if needed
   if new_rec.card_id is null then
      if    new_rec.cards_nk1 is not null
        and new_rec.cards_nk2 is not null
        and new_rec.cards_nk3 is not null
      then
         new_rec.card_id := cards_tab.get_id
            (new_rec.cards_nk1
            ,new_rec.cards_nk2
            ,new_rec.cards_nk3
            );
         if new_rec.card_id is null then
            raise_application_error(-20020, 'Null ID was returned from cards_tab.get_id');
         end if;
      end if;
   end if;
   -- Set new_rec.action_id, if needed
   if new_rec.action_id = old_rec.action_id then
      if    not (new_rec.actions_nk1 = old_rec.actions_nk1)
        or  not (new_rec.actions_nk2 = old_rec.actions_nk2)
        or  not (new_rec.actions_nk3 = old_rec.actions_nk3)
        or  not (new_rec.actions_nk4 = old_rec.actions_nk4)
      then
         new_rec.action_id := actions_tab.get_id
            (new_rec.actions_nk1
            ,new_rec.actions_nk2
            ,new_rec.actions_nk3
            ,new_rec.actions_nk4
            );
         if new_rec.action_id is null then
            raise_application_error(-20020, 'Null ID was returned from actions_tab.get_id');
         end if;
      end if;
   end if;
   -- Set new_rec.card_id, if needed
   if new_rec.card_id = old_rec.card_id then
      if    not (new_rec.cards_nk1 = old_rec.cards_nk1)
        or  not (new_rec.cards_nk2 = old_rec.cards_nk2)
        or  not (new_rec.cards_nk3 = old_rec.cards_nk3)
      then
         new_rec.card_id := cards_tab.get_id
            (new_rec.cards_nk1
            ,new_rec.cards_nk2
            ,new_rec.cards_nk3
            );
         if new_rec.card_id is null then
            raise_application_error(-20020, 'Null ID was returned from cards_tab.get_id');
         end if;
      end if;
   end if;
   -- Load the Table Record from the View Record
   old_tab.id := old_rec.id;
   new_tab.id := new_rec.id;
   old_tab.action_id := old_rec.action_id;
   new_tab.action_id := new_rec.action_id;
   old_tab.card_id := old_rec.card_id;
   new_tab.card_id := new_rec.card_id;
   -- Run the update
   action_cards_tab.upd(old_tab, new_tab);
   if upd_vals_in then
      -- Load the View Record from the Returned (new) Table Record
      -- action_cards_tab.upd should have set new ID = old ID
      select * into new_rec from action_cards_act
       where id = old_tab.id;
   end if;
   return;
   util.trc_time_interval('action_cards_dml.upd(trigger) ID:' || old_tab.id, start_tstamp);
end upd;
----------
function upd
      (old_rec  in  action_cards_act%ROWTYPE
      ,new_rec  in out nocopy  action_cards_act%ROWTYPE
      ,upd_vals_in  in  boolean default FALSE
      ) return varchar2
is
begin
   upd(old_rec, new_rec, upd_vals_in);
   return '';
exception when others then return sqlerrm;
end upd;
----------------------------------------
-- Special Use Update for Specific Column Updates.
--   Only differences between old and new data will be updated.
--   Set upd_val_in TRUE to get updated data in new_rec
procedure upd
      (old_tab  in  action_cards%ROWTYPE
      ,new_tab  in out nocopy  action_cards%ROWTYPE
      )
is
   start_tstamp  timestamp := systimestamp;
begin
   if old_tab.id is null then
      raise_application_error (-20023, 'ID is null');
   end if;
   -- Run the update
   action_cards_tab.upd(old_tab, new_tab);
   return;
   util.trc_time_interval('action_cards_dml.upd(trigger) ID:' || old_tab.id, start_tstamp);
end upd;
----------
function upd
      (old_tab  in  action_cards%ROWTYPE
      ,new_tab  in out nocopy  action_cards%ROWTYPE
      ) return varchar2
is
begin
   upd(old_tab, new_tab);
   return '';
exception when others then return sqlerrm;
end upd;
----------------------------------------
-- Update a action_cards ACTIVE View Record
procedure upd
      (new_rec  in out nocopy  action_cards_act%ROWTYPE
      ,upd_vals_in  in  boolean default TRUE
      )
is
   old_rec  action_cards_act%ROWTYPE;
   start_tstamp  timestamp := systimestamp;
begin
   if new_rec.id is null then
      if    new_rec.actions_nk1 is not null
        and new_rec.actions_nk2 is not null
        and new_rec.actions_nk3 is not null
        and new_rec.actions_nk4 is not null
        and new_rec.cards_nk1 is not null
        and new_rec.cards_nk2 is not null
        and new_rec.cards_nk3 is not null
      then
         new_rec.id := action_cards_tab.get_id
            (new_rec.actions_nk1
            ,new_rec.actions_nk2
            ,new_rec.actions_nk3
            ,new_rec.actions_nk4
            ,new_rec.cards_nk1
            ,new_rec.cards_nk2
            ,new_rec.cards_nk3
            );
      end if;
   end if;
   if new_rec.id is null then
      if    new_rec.action_id is not null
        and new_rec.card_id is not null
      then
         begin
            select id into new_rec.id from action_cards
             where action_id = new_rec.action_id
              and  card_id = new_rec.card_id
               ;
         exception when NO_DATA_FOUND then new_rec.id := null;
         end;
      end if;
   end if;
   if new_rec.id is null then
      raise_application_error (-20023, 'ID is null and could not be found from Natural Keys');
   end if;
   select * into old_rec from action_cards_act
    where id = new_rec.id;
   upd(old_rec, new_rec, upd_vals_in);
   return;
   util.trc_time_interval('action_cards_dml.upd(act rec) ID:' || new_rec.id, start_tstamp);
end upd;
----------
function upd
      (new_rec  in out nocopy  action_cards_act%ROWTYPE
      ,upd_vals_in  in  boolean default TRUE
      ) return varchar2
is
begin
   upd(new_rec, upd_vals_in);
   return '';
exception when others then return sqlerrm;
end upd;
----------------------------------------
-- Update a action_cards Table Record
procedure upd
      (new_tab   in out nocopy  action_cards%ROWTYPE
      )
is
   start_tstamp  timestamp := systimestamp;
begin
   if new_tab.id is null then
      if    new_tab.action_id is not null
        and new_tab.card_id is not null
      then
         begin
            select id into new_tab.id from action_cards
             where action_id = new_tab.action_id
              and  card_id = new_tab.card_id
               ;
         exception when NO_DATA_FOUND then new_tab.id := null;
         end;
      end if;
   end if;
   if new_tab.id is null then
      raise_application_error (-20023, 'ID is null and could not be found from Natural Keys');
   end if;
   action_cards_tab.upd(new_tab);
   return;
   util.trc_time_interval('action_cards_dml.upd(tab rec) ID:' || new_tab.id, start_tstamp);
end upd;
----------
function upd
      (new_tab   in out nocopy  action_cards%ROWTYPE
      ) return varchar2
is
begin
   upd(new_tab);
   return '';
exception when others then return sqlerrm;
end upd;
----------------------------------------
-- Update columns for action_cards ACTIVE View
--   without returning updated data in each column
procedure upd
      (id_in  in  NUMBER default null
      ,action_id_in  in  NUMBER default null
      ,actions_nk1_in  in  VARCHAR2 default null
      ,actions_nk2_in  in  VARCHAR2 default null
      ,actions_nk3_in  in  VARCHAR2 default null
      ,actions_nk4_in  in  NUMBER default null
      ,card_id_in  in  NUMBER default null
      ,cards_nk1_in  in  VARCHAR2 default null
      ,cards_nk2_in  in  VARCHAR2 default null
      ,cards_nk3_in  in  VARCHAR2 default null
      )
is
   new_rec  action_cards_act%ROWTYPE;
   start_tstamp  timestamp := systimestamp;
begin
   new_rec.id := id_in;
   new_rec.action_id := action_id_in;
   new_rec.actions_nk1 := actions_nk1_in;
   new_rec.actions_nk2 := actions_nk2_in;
   new_rec.actions_nk3 := actions_nk3_in;
   new_rec.actions_nk4 := actions_nk4_in;
   new_rec.card_id := card_id_in;
   new_rec.cards_nk1 := cards_nk1_in;
   new_rec.cards_nk2 := cards_nk2_in;
   new_rec.cards_nk3 := cards_nk3_in;
   -- Make corrections when ID is supplied, but NK is missing
   if    new_rec.ID is not null
     and new_rec.actions_nk1 is null
     and new_rec.actions_nk2 is null
     and new_rec.actions_nk3 is null
     and new_rec.actions_nk4 is null
     and new_rec.cards_nk1 is null
     and new_rec.cards_nk2 is null
     and new_rec.cards_nk3 is null
   then
      select ACTC.actions_nk1
            ,ACTC.actions_nk2
            ,ACTC.actions_nk3
            ,ACTC.actions_nk4
            ,ACTC.cards_nk1
            ,ACTC.cards_nk2
            ,ACTC.cards_nk3
       into  new_rec.actions_nk1
            ,new_rec.actions_nk2
            ,new_rec.actions_nk3
            ,new_rec.actions_nk4
            ,new_rec.cards_nk1
            ,new_rec.cards_nk2
            ,new_rec.cards_nk3
       from  action_cards_act  ACTC
       where ACTC.id = new_rec.ID;
   end if;
   -- Make corrections when action_id is supplied, but the Natural Key is missing
   if    new_rec.action_id is not null
     and new_rec.actions_nk1 is null
     and new_rec.actions_nk2 is null
     and new_rec.actions_nk3 is null
     and new_rec.actions_nk4 is null
   then
      select ACT.players_nk1
            ,ACT.players_nk2
            ,ACT.players_nk3
            ,ACT.seq
       into  new_rec.actions_nk1
            ,new_rec.actions_nk2
            ,new_rec.actions_nk3
            ,new_rec.actions_nk4
       from  actions_act  ACT
       where ACT.id = new_rec.action_id;
   end if;
   -- Make corrections when card_id is supplied, but the Natural Key is missing
   if    new_rec.card_id is not null
     and new_rec.cards_nk1 is null
     and new_rec.cards_nk2 is null
     and new_rec.cards_nk3 is null
   then
      select CRD.games_nk1
            ,CRD.games_nk2
            ,CRD.name
       into  new_rec.cards_nk1
            ,new_rec.cards_nk2
            ,new_rec.cards_nk3
       from  cards_act  CRD
       where CRD.id = new_rec.card_id;
   end if;
   upd(new_rec, FALSE);
   return;
   util.trc_time_interval('action_cards_dml.upd(act col) ID:' || id_in, start_tstamp);
end upd;
----------
function upd
      (id_in  in  NUMBER default null
      ,action_id_in  in  NUMBER default null
      ,actions_nk1_in  in  VARCHAR2 default null
      ,actions_nk2_in  in  VARCHAR2 default null
      ,actions_nk3_in  in  VARCHAR2 default null
      ,actions_nk4_in  in  NUMBER default null
      ,card_id_in  in  NUMBER default null
      ,cards_nk1_in  in  VARCHAR2 default null
      ,cards_nk2_in  in  VARCHAR2 default null
      ,cards_nk3_in  in  VARCHAR2 default null
      ) return varchar2
is
begin
   upd
      (id_in
      ,action_id_in
      ,actions_nk1_in
      ,actions_nk2_in
      ,actions_nk3_in
      ,actions_nk4_in
      ,card_id_in
      ,cards_nk1_in
      ,cards_nk2_in
      ,cards_nk3_in
      );
   return '';
exception when others then return sqlerrm;
end upd;
----------------------------------------
-- Update columns for action_cards ACTIVE View
--   with updated data returned in each column
procedure upd2
      (id_io  in out nocopy  NUMBER
      ,action_id_io  in out nocopy  NUMBER
      ,actions_nk1_io  in out nocopy  VARCHAR2
      ,actions_nk2_io  in out nocopy  VARCHAR2
      ,actions_nk3_io  in out nocopy  VARCHAR2
      ,actions_nk4_io  in out nocopy  NUMBER
      ,card_id_io  in out nocopy  NUMBER
      ,cards_nk1_io  in out nocopy  VARCHAR2
      ,cards_nk2_io  in out nocopy  VARCHAR2
      ,cards_nk3_io  in out nocopy  VARCHAR2
      )
is
   new_rec  action_cards_act%ROWTYPE;
   start_tstamp  timestamp := systimestamp;
begin
   new_rec.id := id_io;
   new_rec.action_id := action_id_io;
   new_rec.actions_nk1 := actions_nk1_io;
   new_rec.actions_nk2 := actions_nk2_io;
   new_rec.actions_nk3 := actions_nk3_io;
   new_rec.actions_nk4 := actions_nk4_io;
   new_rec.card_id := card_id_io;
   new_rec.cards_nk1 := cards_nk1_io;
   new_rec.cards_nk2 := cards_nk2_io;
   new_rec.cards_nk3 := cards_nk3_io;
   --
   --  upd(new_rec) will set new_rec.id as needed
   upd(new_rec);
   --
   id_io := new_rec.id;
   action_id_io := new_rec.action_id;
   actions_nk1_io := new_rec.actions_nk1;
   actions_nk2_io := new_rec.actions_nk2;
   actions_nk3_io := new_rec.actions_nk3;
   actions_nk4_io := new_rec.actions_nk4;
   card_id_io := new_rec.card_id;
   cards_nk1_io := new_rec.cards_nk1;
   cards_nk2_io := new_rec.cards_nk2;
   cards_nk3_io := new_rec.cards_nk3;
   return;
   util.trc_time_interval('action_cards_dml.upd2(act col) ID:' || id_io, start_tstamp);
end upd2;
----------
function upd2
      (id_io  in out nocopy  NUMBER
      ,action_id_io  in out nocopy  NUMBER
      ,actions_nk1_io  in out nocopy  VARCHAR2
      ,actions_nk2_io  in out nocopy  VARCHAR2
      ,actions_nk3_io  in out nocopy  VARCHAR2
      ,actions_nk4_io  in out nocopy  NUMBER
      ,card_id_io  in out nocopy  NUMBER
      ,cards_nk1_io  in out nocopy  VARCHAR2
      ,cards_nk2_io  in out nocopy  VARCHAR2
      ,cards_nk3_io  in out nocopy  VARCHAR2
      ) return varchar2
is
begin
   upd2
      (id_io
      ,action_id_io
      ,actions_nk1_io
      ,actions_nk2_io
      ,actions_nk3_io
      ,actions_nk4_io
      ,card_id_io
      ,cards_nk1_io
      ,cards_nk2_io
      ,cards_nk3_io
      );
   return '';
exception when others then return sqlerrm;
end upd2;
----------------------------------------
-- Update columns for action_cards Table
--   with updated data returned in each column
procedure upd2
      (id_io  in out nocopy  NUMBER
      ,action_id_io  in out nocopy  NUMBER
      ,card_id_io  in out nocopy  NUMBER
      )
is
   new_rec  action_cards%ROWTYPE;
   start_tstamp  timestamp := systimestamp;
begin
   if id_io is null then
      if    action_id_io is not null
        and card_id_io is not null
      then
         begin
            select id into id_io from action_cards
             where action_id = action_id_io
              and  card_id = card_id_io
               ;
         exception when NO_DATA_FOUND then id_io := null;
         end;
      end if;
   end if;
   if id_io is null then
      raise_application_error (-20023, 'ID is null and could not be found from Natural Keys');
   end if;
   new_rec.id := id_io;
   new_rec.action_id := action_id_io;
   new_rec.card_id := card_id_io;
   --
   action_cards_tab.upd(new_rec);
   --
   id_io := new_rec.id;
   action_id_io := new_rec.action_id;
   card_id_io := new_rec.card_id;
   return;
   util.trc_time_interval('action_cards_dml.upd2(tab col) ID:' || id_io, start_tstamp);
end upd2;
----------
function upd2
      (id_io  in out nocopy  NUMBER
      ,action_id_io  in out nocopy  NUMBER
      ,card_id_io  in out nocopy  NUMBER
      ) return varchar2
is
begin
    upd2
      (id_io
      ,action_id_io
      ,card_id_io
      );
   return '';
exception when others then return sqlerrm;
end upd2;

----------------------------------------
-- Application Delete procedure without updated parameters
procedure del
      (id_in  in  NUMBER default null
      ,action_id_in  in  NUMBER default null
      ,actions_nk1_in  in  VARCHAR2 default null
      ,actions_nk2_in  in  VARCHAR2 default null
      ,actions_nk3_in  in  VARCHAR2 default null
      ,actions_nk4_in  in  NUMBER default null
      ,card_id_in  in  NUMBER default null
      ,cards_nk1_in  in  VARCHAR2 default null
      ,cards_nk2_in  in  VARCHAR2 default null
      ,cards_nk3_in  in  VARCHAR2 default null
      )
is
   start_tstamp  timestamp := systimestamp;
   tmp_id  NUMBER;
begin
   tmp_id := id_in;
   if tmp_id is null then
      if    actions_nk1_in is not null
        and actions_nk2_in is not null
        and actions_nk3_in is not null
        and actions_nk4_in is not null
        and cards_nk1_in is not null
        and cards_nk2_in is not null
        and cards_nk3_in is not null
      then
         tmp_id := action_cards_tab.get_id
            (actions_nk1_in
            ,actions_nk2_in
            ,actions_nk3_in
            ,actions_nk4_in
            ,cards_nk1_in
            ,cards_nk2_in
            ,cards_nk3_in
            );
      end if;
   end if;
   if tmp_id is null then
      if    action_id_in is not null
        and card_id_in is not null
      then
         begin
            select id into tmp_id from action_cards
             where action_id = action_id_in
              and  card_id = card_id_in
               ;
         exception when NO_DATA_FOUND then tmp_id := null;
         end;
      end if;
   end if;
   if tmp_id is null then
      raise_application_error (-20023, 'ID is null and could not be found from Natural Keys');
   end if;
   action_cards_tab.del(tmp_id);
   return;
   util.trc_time_interval('action_cards_dml.del ID:' || id_in, start_tstamp);
end del;
----------
function del
      (id_in  in  NUMBER default null
      ,action_id_in  in  NUMBER default null
      ,actions_nk1_in  in  VARCHAR2 default null
      ,actions_nk2_in  in  VARCHAR2 default null
      ,actions_nk3_in  in  VARCHAR2 default null
      ,actions_nk4_in  in  NUMBER default null
      ,card_id_in  in  NUMBER default null
      ,cards_nk1_in  in  VARCHAR2 default null
      ,cards_nk2_in  in  VARCHAR2 default null
      ,cards_nk3_in  in  VARCHAR2 default null
      ) return varchar2
is
begin
   del
      (id_in
      ,action_id_in
      ,actions_nk1_in
      ,actions_nk2_in
      ,actions_nk3_in
      ,actions_nk4_in
      ,card_id_in
      ,cards_nk1_in
      ,cards_nk2_in
      ,cards_nk3_in
      );
   return '';
exception when others then return sqlerrm;
end del;
----------------------------------------
-- Application Delete procedure with updated parameters
procedure del2
      (id_io  in out nocopy  NUMBER
      ,action_id_in  in  NUMBER default null
      ,actions_nk1_in  in  VARCHAR2 default null
      ,actions_nk2_in  in  VARCHAR2 default null
      ,actions_nk3_in  in  VARCHAR2 default null
      ,actions_nk4_in  in  NUMBER default null
      ,card_id_in  in  NUMBER default null
      ,cards_nk1_in  in  VARCHAR2 default null
      ,cards_nk2_in  in  VARCHAR2 default null
      ,cards_nk3_in  in  VARCHAR2 default null
      )
is
   start_tstamp  timestamp := systimestamp;
begin
   if id_io is null then
      if    actions_nk1_in is not null
        and actions_nk2_in is not null
        and actions_nk3_in is not null
        and actions_nk4_in is not null
        and cards_nk1_in is not null
        and cards_nk2_in is not null
        and cards_nk3_in is not null
      then
         id_io := action_cards_tab.get_id
            (actions_nk1_in
            ,actions_nk2_in
            ,actions_nk3_in
            ,actions_nk4_in
            ,cards_nk1_in
            ,cards_nk2_in
            ,cards_nk3_in
            );
      end if;
   end if;
   if id_io is null then
      if    action_id_in is not null
        and card_id_in is not null
      then
         begin
            select id into id_io from action_cards
             where action_id = action_id_in
              and  card_id = card_id_in
               ;
         exception when NO_DATA_FOUND then id_io := null;
         end;
      end if;
   end if;
   if id_io is null then
      raise_application_error (-20023, 'ID is null and could not be found from Natural Keys');
   end if;
   action_cards_tab.del(id_io);
   return;
   util.trc_time_interval('action_cards_dml.del2 ID:' || id_io, start_tstamp);
end del2;
----------
function del2
      (id_io  in out nocopy  NUMBER
      ,action_id_in  in  NUMBER default null
      ,actions_nk1_in  in  VARCHAR2 default null
      ,actions_nk2_in  in  VARCHAR2 default null
      ,actions_nk3_in  in  VARCHAR2 default null
      ,actions_nk4_in  in  NUMBER default null
      ,card_id_in  in  NUMBER default null
      ,cards_nk1_in  in  VARCHAR2 default null
      ,cards_nk2_in  in  VARCHAR2 default null
      ,cards_nk3_in  in  VARCHAR2 default null
      ) return varchar2
is
begin
   del2
      (id_io
      ,action_id_in
      ,actions_nk1_in
      ,actions_nk2_in
      ,actions_nk3_in
      ,actions_nk4_in
      ,card_id_in
      ,cards_nk1_in
      ,cards_nk2_in
      ,cards_nk3_in
      );
   return '';
exception when others then return sqlerrm;
end del2;
----------------------------------------
procedure load_dim
      (dim_tab  in out nocopy  action_cards%ROWTYPE
      )
is
   -- Special Data Warehouse Dimension Function
   start_tstamp  timestamp := systimestamp;
   procedure private_upd is
      saved_inc  boolean := util.get_ignore_no_change;
   begin
      util.set_ignore_no_change(TRUE);
      upd (dim_tab);
      util.set_ignore_no_change(saved_inc);
   exception
      when others then
         util.set_ignore_no_change(saved_inc);
         raise;
   end private_upd;
begin
   -- Attempt to find matching record based on natural keys
   if dim_tab.id is null then
      begin
         select id
          into  dim_tab.id
          from  action_cards
          where action_id = dim_tab.action_id
           and  action_id = dim_tab.action_id
           and  card_id = dim_tab.card_id
         ;
      exception
         when NO_DATA_FOUND then dim_tab.id := null;
      end;
   end if;
   if dim_tab.id is not null then
      -- If found, perform update on non-NK columns that changed
      private_upd;
      return;
      util.trc_time_interval('action_cards_dml.load_dimE ID:' || dim_tab.id, start_tstamp);
   end if;
   -- If not found, insert new record
   begin
      ins(dim_tab);
   exception
      when DUP_VAL_ON_INDEX then
         -- Since this can run multi-threaded, another thread
         --   may have already populated this value.
         private_upd;
   end;
   return;
   util.trc_time_interval('action_cards_dml.load_dim ID:' || dim_tab.id, start_tstamp);
end load_dim;
----------
function load_dim
      (dim_tab  in out nocopy  action_cards%ROWTYPE
      ) return varchar2
is
begin
   load_dim(dim_tab);
   return '';
exception when others then return sqlerrm;
end load_dim;
----------------------------------------
end action_cards_dml;
/
select 'ACTION_CARDS_DML' as "Package Body:"
 from  user_errors
 where name  = 'ACTION_CARDS_DML'
  and  type  = 'PACKAGE BODY'
  and  rownum = 1
/
select '('||line||'/'||position||') '||text as error
 from  user_errors
 where name = 'ACTION_CARDS_DML'
  and  type = 'PACKAGE BODY'
 order by sequence
/

create TRIGGER action_cards_act_ioi
   instead of insert on action_cards_act
   for each row
declare

   -- Trigger Action_Cards_Act_Ioi

   -- Application: Clue Notes For Oracle
   -- Generated by DTGen (http://dmstex.com/services/dtgen)
   -- December  16, 2013  11:32:31 AM

   --
   --
   -- © Duane.Dieterich@DMSTEX.com 2013
   --
   -- All Rights Reserved
   --
   -- No part of this software may be reproduced, copied, modified or adapted,
   -- without the prior written consent of the author, unless otherwise
   -- indicated for stand-alone materials.
   --
   -- You may quote extracts from this software with attribution to
   -- Duane.Dieterich@DMSTEX.com
   --
   -- For any other mode of sharing, please contact Duane.Dieterich@DMSTEX.com.
   --
   -- Commercial use and distribution of this software is not allowed without
   -- express and prior written consent of the author.
   --
   -- THE SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
   -- INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY
   -- AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL
   -- THE COPYRIGHT HOLDER OR DMSTEX BUSINESS SOLUTIONS LLC, ITS MEMBERS,
   -- MANAGERS, OR EMPLOYEES BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
   -- SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
   -- TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
   -- PROFITS; CORRUPTION OF DATA, OR BUSINESS INTERRUPTION) HOWEVER CAUSED
   -- AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
   -- OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF
   -- THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH
   -- DAMAGE.
   --
   --


   new_rec  action_cards_act%ROWTYPE;
   start_tstamp  timestamp := systimestamp;
begin
   new_rec.id := :new.id;
   new_rec.action_id := :new.action_id;
   new_rec.actions_nk1 := :new.actions_nk1;
   new_rec.actions_nk2 := :new.actions_nk2;
   new_rec.actions_nk3 := :new.actions_nk3;
   new_rec.actions_nk4 := :new.actions_nk4;
   new_rec.card_id := :new.card_id;
   new_rec.cards_nk1 := :new.cards_nk1;
   new_rec.cards_nk2 := :new.cards_nk2;
   new_rec.cards_nk3 := :new.cards_nk3;
   action_cards_dml.ins(new_rec, FALSE);
   util.trc_time_interval('action_cards_act_ioi trigger ID:' || :new.id, start_tstamp);
end action_cards_act_ioi;
/
select 'ACTION_CARDS_ACT_IOI' as "Trigger:"
 from  user_errors
 where name  = 'ACTION_CARDS_ACT_IOI'
  and  type  = 'TRIGGER'
  and  rownum = 1
/
select '('||line||'/'||position||') '||text as error
 from  user_errors
 where name = 'ACTION_CARDS_ACT_IOI'
  and  type = 'TRIGGER'
 order by sequence
/

create TRIGGER action_cards_act_iou
   instead of update on action_cards_act
   for each row
declare

   -- Trigger Action_Cards_Act_Iou

   -- Application: Clue Notes For Oracle
   -- Generated by DTGen (http://dmstex.com/services/dtgen)
   -- December  16, 2013  11:32:31 AM

   --
   --
   -- © Duane.Dieterich@DMSTEX.com 2013
   --
   -- All Rights Reserved
   --
   -- No part of this software may be reproduced, copied, modified or adapted,
   -- without the prior written consent of the author, unless otherwise
   -- indicated for stand-alone materials.
   --
   -- You may quote extracts from this software with attribution to
   -- Duane.Dieterich@DMSTEX.com
   --
   -- For any other mode of sharing, please contact Duane.Dieterich@DMSTEX.com.
   --
   -- Commercial use and distribution of this software is not allowed without
   -- express and prior written consent of the author.
   --
   -- THE SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
   -- INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY
   -- AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL
   -- THE COPYRIGHT HOLDER OR DMSTEX BUSINESS SOLUTIONS LLC, ITS MEMBERS,
   -- MANAGERS, OR EMPLOYEES BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
   -- SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
   -- TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
   -- PROFITS; CORRUPTION OF DATA, OR BUSINESS INTERRUPTION) HOWEVER CAUSED
   -- AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
   -- OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF
   -- THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH
   -- DAMAGE.
   --
   --


   old_rec  action_cards_act%ROWTYPE;
   new_rec  action_cards_act%ROWTYPE;
   start_tstamp  timestamp := systimestamp;
begin
   -- NOTE: Column Specified Update DML works without this lock
   --select btab.id into new_rec.id from action_cards btab
   -- where btab.id = :old.id for update;
   old_rec.id := :old.id;
   new_rec.id := :new.id;
   old_rec.action_id := :old.action_id;
   new_rec.action_id := :new.action_id;
   old_rec.actions_nk1 := :old.actions_nk1;
   new_rec.actions_nk1 := :new.actions_nk1;
   old_rec.actions_nk2 := :old.actions_nk2;
   new_rec.actions_nk2 := :new.actions_nk2;
   old_rec.actions_nk3 := :old.actions_nk3;
   new_rec.actions_nk3 := :new.actions_nk3;
   old_rec.actions_nk4 := :old.actions_nk4;
   new_rec.actions_nk4 := :new.actions_nk4;
   old_rec.card_id := :old.card_id;
   new_rec.card_id := :new.card_id;
   old_rec.cards_nk1 := :old.cards_nk1;
   new_rec.cards_nk1 := :new.cards_nk1;
   old_rec.cards_nk2 := :old.cards_nk2;
   new_rec.cards_nk2 := :new.cards_nk2;
   old_rec.cards_nk3 := :old.cards_nk3;
   new_rec.cards_nk3 := :new.cards_nk3;
   action_cards_dml.upd(old_rec, new_rec);
   util.trc_time_interval('action_cards_act_iou trigger ID:' || :old.id, start_tstamp);
end action_cards_act_iou;
/
select 'ACTION_CARDS_ACT_IOU' as "Trigger:"
 from  user_errors
 where name  = 'ACTION_CARDS_ACT_IOU'
  and  type  = 'TRIGGER'
  and  rownum = 1
/
select '('||line||'/'||position||') '||text as error
 from  user_errors
 where name = 'ACTION_CARDS_ACT_IOU'
  and  type = 'TRIGGER'
 order by sequence
/

create TRIGGER action_cards_act_iod
   instead of delete on action_cards_act
   for each row
declare

   -- Trigger Action_Cards_Act_Iod

   -- Application: Clue Notes For Oracle
   -- Generated by DTGen (http://dmstex.com/services/dtgen)
   -- December  16, 2013  11:32:31 AM

   --
   --
   -- © Duane.Dieterich@DMSTEX.com 2013
   --
   -- All Rights Reserved
   --
   -- No part of this software may be reproduced, copied, modified or adapted,
   -- without the prior written consent of the author, unless otherwise
   -- indicated for stand-alone materials.
   --
   -- You may quote extracts from this software with attribution to
   -- Duane.Dieterich@DMSTEX.com
   --
   -- For any other mode of sharing, please contact Duane.Dieterich@DMSTEX.com.
   --
   -- Commercial use and distribution of this software is not allowed without
   -- express and prior written consent of the author.
   --
   -- THE SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
   -- INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY
   -- AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL
   -- THE COPYRIGHT HOLDER OR DMSTEX BUSINESS SOLUTIONS LLC, ITS MEMBERS,
   -- MANAGERS, OR EMPLOYEES BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
   -- SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
   -- TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
   -- PROFITS; CORRUPTION OF DATA, OR BUSINESS INTERRUPTION) HOWEVER CAUSED
   -- AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
   -- OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF
   -- THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH
   -- DAMAGE.
   --
   --


   start_tstamp  timestamp := systimestamp;
begin
   action_cards_tab.del(:old.id);
   util.trc_time_interval('action_cards_act_iod trigger ID:' || :old.id, start_tstamp);
end action_cards_act_iod;
/
select 'ACTION_CARDS_ACT_IOD' as "Trigger:"
 from  user_errors
 where name  = 'ACTION_CARDS_ACT_IOD'
  and  type  = 'TRIGGER'
  and  rownum = 1
/
select '('||line||'/'||position||') '||text as error
 from  user_errors
 where name = 'ACTION_CARDS_ACT_IOD'
  and  type = 'TRIGGER'
 order by sequence
/


create view pcard_actions_act
      (id
      ,card_id
      ,cards_nk1
      ,cards_nk2
      ,cards_nk3
      ,disposition
      ,player_id
      ,players_nk1
      ,players_nk2
      ,players_nk3
      ,action_id
      ,actions_nk1
      ,actions_nk2
      ,actions_nk3
      ,actions_nk4
      )
   as select
       PCA.id
      ,PCA.card_id
      ,CRD.games_nk1
      ,CRD.games_nk2
      ,CRD.name
      ,PCA.disposition
      ,PCA.player_id
      ,PLY.games_nk1
      ,PLY.games_nk2
      ,PLY.name
      ,PCA.action_id
      ,ACT.players_nk1
      ,ACT.players_nk2
      ,ACT.players_nk3
      ,ACT.seq
 from             pcard_actions PCA
       inner join cards_act CRD on CRD.id = PCA.card_id
       inner join players_act PLY on PLY.id = PCA.player_id
       inner join actions_a ACT on ACT.id = PCA.action_id
/
select 'PCARD_ACTIONS_ACT' as "View:"
 from  user_errors
 where name  = 'PCARD_ACTIONS_ACT'
  and  type  = 'VIEW'
  and  rownum = 1
/
select '('||line||'/'||position||') '||text as error
 from  user_errors
 where name = 'PCARD_ACTIONS_ACT'
  and  type = 'VIEW'
 order by sequence
/

comment on table pcard_actions_act is 'Player''s Cards for each User''s Game'
/

comment on column pcard_actions_act.id is 'Surrogate Primary Key for these pcard_actions'
/
comment on column pcard_actions_act.card_id is 'Card for this Player'
/
comment on column pcard_actions_act.cards_nk1 is 'CARDS Natural Key 1: GAMES NK1: USERS NK1: Clue Notes User Name'
/
comment on column pcard_actions_act.cards_nk2 is 'CARDS Natural Key 2: GAMES NK2: User''s Game Name'
/
comment on column pcard_actions_act.cards_nk3 is 'CARDS Natural Key 3: Card Name'
/
comment on column pcard_actions_act.disposition is 'Disposition of this Player''s Card'
/
comment on column pcard_actions_act.player_id is 'Player for this Card'
/
comment on column pcard_actions_act.players_nk1 is 'PLAYERS Natural Key 1: GAMES NK1: USERS NK1: Clue Notes User Name'
/
comment on column pcard_actions_act.players_nk2 is 'PLAYERS Natural Key 2: GAMES NK2: User''s Game Name'
/
comment on column pcard_actions_act.players_nk3 is 'PLAYERS Natural Key 3: Player''s Name'
/
comment on column pcard_actions_act.action_id is 'The current Action when this Player''s Card was dispositioned'
/
comment on column pcard_actions_act.actions_nk1 is 'ACTIONS Natural Key 1: PLAYERS NK1: GAMES NK1: USERS NK1: Clue Notes User Name'
/
comment on column pcard_actions_act.actions_nk2 is 'ACTIONS Natural Key 2: PLAYERS NK2: GAMES NK2: User''s Game Name'
/
comment on column pcard_actions_act.actions_nk3 is 'ACTIONS Natural Key 3: PLAYERS NK3: Player''s Name'
/
comment on column pcard_actions_act.actions_nk4 is 'ACTIONS Natural Key 4: Sequence Number for this Action'
/

alter view pcard_actions_act add constraint pcard_actions_act_pk
   primary key (id) disable
/

alter view pcard_actions_act add constraint pcard_actions_act_fk1
   foreign key (card_id) references cards_act (id) disable
/
alter view pcard_actions_act add constraint pcard_actions_act_fk3
   foreign key (player_id) references players_act (id) disable
/
alter view pcard_actions_act add constraint pcard_actions_act_fk4
   foreign key (action_id) references actions_act (id) disable
/

CREATE type pcard_actions_vobj
is
   -- Pcard_Actions Active View (Virtual) Record Type
object
   (id  NUMBER(38)
   ,card_id  NUMBER(38)
   ,cards_nk1  VARCHAR2(320)
   ,cards_nk2  VARCHAR2(320)
   ,cards_nk3  VARCHAR2(15)
   ,disposition  VARCHAR2(4)
   ,player_id  NUMBER(38)
   ,players_nk1  VARCHAR2(320)
   ,players_nk2  VARCHAR2(320)
   ,players_nk3  VARCHAR2(15)
   ,action_id  NUMBER(38)
   ,actions_nk1  VARCHAR2(320)
   ,actions_nk2  VARCHAR2(320)
   ,actions_nk3  VARCHAR2(15)
   ,actions_nk4  NUMBER(3)
   )
/
select 'PCARD_ACTIONS_VOBJ' as "Type:"
 from  user_errors
 where name  = 'PCARD_ACTIONS_VOBJ'
  and  type  = 'TYPE'
  and  rownum = 1
/
select '('||line||'/'||position||') '||text as error
 from  user_errors
 where name = 'PCARD_ACTIONS_VOBJ'
  and  type = 'TYPE'
 order by sequence
/

CREATE type pcard_actions_vtab
is
   -- Pcard_Actions Active View (Virtual) Table Type
table of pcard_actions_vobj
/
select 'PCARD_ACTIONS_VTAB' as "Type:"
 from  user_errors
 where name  = 'PCARD_ACTIONS_VTAB'
  and  type  = 'TYPE'
  and  rownum = 1
/
select '('||line||'/'||position||') '||text as error
 from  user_errors
 where name = 'PCARD_ACTIONS_VTAB'
  and  type = 'TYPE'
 order by sequence
/

create package pcard_actions_dml
is

   -- Package Pcard_Actions_Dml
   -- (Data Manipulation Language, Foreign Key and Path Lookup)

   -- Application: Clue Notes For Oracle
   -- Generated by DTGen (http://dmstex.com/services/dtgen)
   -- December  16, 2013  11:32:31 AM

   --
   --
   -- © Duane.Dieterich@DMSTEX.com 2013
   --
   -- All Rights Reserved
   --
   -- No part of this software may be reproduced, copied, modified or adapted,
   -- without the prior written consent of the author, unless otherwise
   -- indicated for stand-alone materials.
   --
   -- You may quote extracts from this software with attribution to
   -- Duane.Dieterich@DMSTEX.com
   --
   -- For any other mode of sharing, please contact Duane.Dieterich@DMSTEX.com.
   --
   -- Commercial use and distribution of this software is not allowed without
   -- express and prior written consent of the author.
   --
   -- THE SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
   -- INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY
   -- AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL
   -- THE COPYRIGHT HOLDER OR DMSTEX BUSINESS SOLUTIONS LLC, ITS MEMBERS,
   -- MANAGERS, OR EMPLOYEES BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
   -- SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
   -- TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
   -- PROFITS; CORRUPTION OF DATA, OR BUSINESS INTERRUPTION) HOWEVER CAUSED
   -- AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
   -- OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF
   -- THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH
   -- DAMAGE.
   --
   --


   -- Return the next Surrogate Key ID for pcard_actions
   function get_next_id
      return NUMBER;
   -- Return the current Surrogate Key ID for pcard_actions
   --   NOTE: This will return an ERROR if get_next_id has not been called
   function get_curr_id
      return NUMBER;

   -- Return the next Surrogate Key ID for the Natural Keys of pcard_actions
   --   NOTE: The fields used in this function are the Natural Keys for pcard_actions
   --         Alternatively, the Natural Key IDs for pcard_actions are:
   --            -) card_id
   --            -) disposition
   --            -) player_id
   --            -) action_id
   function get_id
      (cards_nk1  in  VARCHAR2
      ,cards_nk2  in  VARCHAR2
      ,cards_nk3  in  VARCHAR2
      ,disposition  in  VARCHAR2
      ,players_nk1  in  VARCHAR2
      ,players_nk2  in  VARCHAR2
      ,players_nk3  in  VARCHAR2
      ,actions_nk1  in  VARCHAR2
      ,actions_nk2  in  VARCHAR2
      ,actions_nk3  in  VARCHAR2
      ,actions_nk4  in  NUMBER
      ) return NUMBER;
   -- For all the Natural Key Column IDs, Return an ID
   function get_id2
      (card_id_in  in  NUMBER
      ,disposition_in  in  VARCHAR2
      ,player_id_in  in  NUMBER
      ,action_id_in  in  NUMBER
      ) return NUMBER;
   -- Return a concatenated string of Natural Keys for a pcard_actions id
   function get_nk
      (id_in  in  NUMBER
      ) return VARCHAR2;

   -- Set a "view" record to null
   procedure clear
      (n_rec  in out nocopy  pcard_actions_ACT%ROWTYPE
      );
   -- This function traps and returns any error message from the clear procedure
   function clear
      (n_rec  in out nocopy  pcard_actions_ACT%ROWTYPE
      ) return varchar2;
   -- Set a "table" record to null
   procedure clear
      (n_tab  in out nocopy  pcard_actions%ROWTYPE
      );
   -- This function traps and returns any error message from the clear procedure
   function clear
      (n_tab  in out nocopy  pcard_actions%ROWTYPE
      ) return varchar2;

   -- Set a "view" record from a pcard_actions ID
   procedure get_rec_by_id
      (n_rec  in out nocopy  pcard_actions_ACT%ROWTYPE
      );
   -- This function traps and returns any error message from the get_rec_by_id procedure
   function get_rec_by_id
      (n_rec  in out nocopy  pcard_actions_ACT%ROWTYPE
      ) return varchar2;
   -- Set a "table" record from a pcard_actions ID
   procedure get_rec_by_id
      (n_tab  in out nocopy  pcard_actions%ROWTYPE
      );
   -- This function traps and returns any error message from the get_rec_by_id procedure
   function get_rec_by_id
      (n_tab  in out nocopy  pcard_actions%ROWTYPE
      ) return varchar2;

   -- NOTE: All INS procedures will run faster with a null ID
   --       because it avoids a history search for duplicate IDs
   --
   -- Insert a pcard_actions ACTIVE View Record
   -- NOTE: If UPD_VALS_IN is set to FALSE, the function will run faster,
   --       but the returned record may contain invalid data
   procedure ins
      (new_rec  in out nocopy  pcard_actions_act%ROWTYPE
      ,upd_vals_in  in  boolean default TRUE
      );
   -- This function traps and returns any error message from the ins procedure
   function ins
      (new_rec  in out nocopy  pcard_actions_act%ROWTYPE
      ,upd_vals_in  in  boolean default TRUE
      ) return varchar2;
   -- Insert a pcard_actions Table Record
   --  (Fastest insert procedure and returned data is always valid)
   procedure ins
      (new_tab  in out nocopy  pcard_actions%ROWTYPE
      );
   -- This function traps and returns any error message from the ins procedure
   function ins
      (new_tab  in out nocopy  pcard_actions%ROWTYPE
      ) return varchar2;
   -- Insert columns for pcard_actions ACTIVE View
   --   without returning updated data in each column
   procedure ins
      (id_in  in  NUMBER default null
      ,card_id_in  in  NUMBER default null
      ,cards_nk1_in  in  VARCHAR2 default null
      ,cards_nk2_in  in  VARCHAR2 default null
      ,cards_nk3_in  in  VARCHAR2 default null
      ,disposition_in  in  VARCHAR2 default null
      ,player_id_in  in  NUMBER default null
      ,players_nk1_in  in  VARCHAR2 default null
      ,players_nk2_in  in  VARCHAR2 default null
      ,players_nk3_in  in  VARCHAR2 default null
      ,action_id_in  in  NUMBER default null
      ,actions_nk1_in  in  VARCHAR2 default null
      ,actions_nk2_in  in  VARCHAR2 default null
      ,actions_nk3_in  in  VARCHAR2 default null
      ,actions_nk4_in  in  NUMBER default null
      );
   -- This function traps and returns any error message from the ins procedure
   function ins
      (id_in  in  NUMBER default null
      ,card_id_in  in  NUMBER default null
      ,cards_nk1_in  in  VARCHAR2 default null
      ,cards_nk2_in  in  VARCHAR2 default null
      ,cards_nk3_in  in  VARCHAR2 default null
      ,disposition_in  in  VARCHAR2 default null
      ,player_id_in  in  NUMBER default null
      ,players_nk1_in  in  VARCHAR2 default null
      ,players_nk2_in  in  VARCHAR2 default null
      ,players_nk3_in  in  VARCHAR2 default null
      ,action_id_in  in  NUMBER default null
      ,actions_nk1_in  in  VARCHAR2 default null
      ,actions_nk2_in  in  VARCHAR2 default null
      ,actions_nk3_in  in  VARCHAR2 default null
      ,actions_nk4_in  in  NUMBER default null
      ) return varchar2;
   -- Insert columns for pcard_actions ACTIVE View
   --   with updated data returned in each column
   procedure ins2
      (id_io  in out nocopy  NUMBER
      ,card_id_io  in out nocopy  NUMBER
      ,cards_nk1_io  in out nocopy  VARCHAR2
      ,cards_nk2_io  in out nocopy  VARCHAR2
      ,cards_nk3_io  in out nocopy  VARCHAR2
      ,disposition_io  in out nocopy  VARCHAR2
      ,player_id_io  in out nocopy  NUMBER
      ,players_nk1_io  in out nocopy  VARCHAR2
      ,players_nk2_io  in out nocopy  VARCHAR2
      ,players_nk3_io  in out nocopy  VARCHAR2
      ,action_id_io  in out nocopy  NUMBER
      ,actions_nk1_io  in out nocopy  VARCHAR2
      ,actions_nk2_io  in out nocopy  VARCHAR2
      ,actions_nk3_io  in out nocopy  VARCHAR2
      ,actions_nk4_io  in out nocopy  NUMBER
      );
   -- This function traps and returns any error message from the ins2 procedure
   function ins2
      (id_io  in out nocopy  NUMBER
      ,card_id_io  in out nocopy  NUMBER
      ,cards_nk1_io  in out nocopy  VARCHAR2
      ,cards_nk2_io  in out nocopy  VARCHAR2
      ,cards_nk3_io  in out nocopy  VARCHAR2
      ,disposition_io  in out nocopy  VARCHAR2
      ,player_id_io  in out nocopy  NUMBER
      ,players_nk1_io  in out nocopy  VARCHAR2
      ,players_nk2_io  in out nocopy  VARCHAR2
      ,players_nk3_io  in out nocopy  VARCHAR2
      ,action_id_io  in out nocopy  NUMBER
      ,actions_nk1_io  in out nocopy  VARCHAR2
      ,actions_nk2_io  in out nocopy  VARCHAR2
      ,actions_nk3_io  in out nocopy  VARCHAR2
      ,actions_nk4_io  in out nocopy  NUMBER
      ) return varchar2;
   -- Insert columns for pcard_actions Table
   --   with updated data returned in each column
   procedure ins2
      (id_io  in out nocopy  NUMBER
      ,card_id_io  in out nocopy  NUMBER
      ,disposition_io  in out nocopy  VARCHAR2
      ,player_id_io  in out nocopy  NUMBER
      ,action_id_io  in out nocopy  NUMBER
      );
   -- This function traps and returns any error message from the ins2 procedure
   function ins2
      (id_io  in out nocopy  NUMBER
      ,card_id_io  in out nocopy  NUMBER
      ,disposition_io  in out nocopy  VARCHAR2
      ,player_id_io  in out nocopy  NUMBER
      ,action_id_io  in out nocopy  NUMBER
      ) return varchar2;

   -- Special Use Update for Specific Column Updates.
   --   Only differences between old and new data will be updated.
   --   Set upd_val_in TRUE to get updated data in new_rec
   procedure upd
      (old_rec  in  pcard_actions_act%ROWTYPE
      ,new_rec  in out nocopy  pcard_actions_act%ROWTYPE
      ,upd_vals_in  in  boolean default FALSE
      );
   -- This function traps and returns any error message from the upd procedure
   function upd
      (old_rec  in  pcard_actions_act%ROWTYPE
      ,new_rec  in out nocopy  pcard_actions_act%ROWTYPE
      ,upd_vals_in  in  boolean default FALSE
      ) return varchar2;
   -- Special Use Update for Specific Column Updates.
   --   Only differences between old and new data will be updated.
   --   Set upd_val_in TRUE to get updated data in new_rec
   procedure upd
      (old_tab  in  pcard_actions%ROWTYPE
      ,new_tab  in out nocopy  pcard_actions%ROWTYPE
      );
   -- This function traps and returns any error message from the upd procedure
   function upd
      (old_tab  in  pcard_actions%ROWTYPE
      ,new_tab  in out nocopy  pcard_actions%ROWTYPE
      ) return varchar2;
   -- Update a pcard_actions ACTIVE View Record
   -- NOTE: If UPD_VALS_IN is set to FALSE, the returned record
   --       may contain invalid data
   -- NOTE: Only FK NKs that are part of this NK will be used to find
   --       this ID from its NKs (FK IDs will be ignored)
   procedure upd
      (new_rec  in out nocopy  pcard_actions_act%ROWTYPE
      ,upd_vals_in  in  boolean default TRUE
      );
   -- This function traps and returns any error message from the upd procedure
   function upd
      (new_rec  in out nocopy  pcard_actions_act%ROWTYPE
      ,upd_vals_in  in  boolean default TRUE
      ) return varchar2;
   -- Update a pcard_actions Table Record
   --  (Fastest update procedure and returned data is always valid)
   -- NOTE: pcard_actionsID must be supplied (NK lookup will not be performed)
   procedure upd
      (new_tab  in out nocopy  pcard_actions%ROWTYPE
      );
   -- This function traps and returns any error message from the upd procedure
   function upd
      (new_tab  in out nocopy  pcard_actions%ROWTYPE
      ) return varchar2;
   -- Update columns for pcard_actions ACTIVE View
   --   without returning updated data in each column
   procedure upd
      (id_in  in  NUMBER default null
      ,card_id_in  in  NUMBER default null
      ,cards_nk1_in  in  VARCHAR2 default null
      ,cards_nk2_in  in  VARCHAR2 default null
      ,cards_nk3_in  in  VARCHAR2 default null
      ,disposition_in  in  VARCHAR2 default null
      ,player_id_in  in  NUMBER default null
      ,players_nk1_in  in  VARCHAR2 default null
      ,players_nk2_in  in  VARCHAR2 default null
      ,players_nk3_in  in  VARCHAR2 default null
      ,action_id_in  in  NUMBER default null
      ,actions_nk1_in  in  VARCHAR2 default null
      ,actions_nk2_in  in  VARCHAR2 default null
      ,actions_nk3_in  in  VARCHAR2 default null
      ,actions_nk4_in  in  NUMBER default null
      );
   -- This function traps and returns any error message from the upd procedure
   function upd
      (id_in  in  NUMBER default null
      ,card_id_in  in  NUMBER default null
      ,cards_nk1_in  in  VARCHAR2 default null
      ,cards_nk2_in  in  VARCHAR2 default null
      ,cards_nk3_in  in  VARCHAR2 default null
      ,disposition_in  in  VARCHAR2 default null
      ,player_id_in  in  NUMBER default null
      ,players_nk1_in  in  VARCHAR2 default null
      ,players_nk2_in  in  VARCHAR2 default null
      ,players_nk3_in  in  VARCHAR2 default null
      ,action_id_in  in  NUMBER default null
      ,actions_nk1_in  in  VARCHAR2 default null
      ,actions_nk2_in  in  VARCHAR2 default null
      ,actions_nk3_in  in  VARCHAR2 default null
      ,actions_nk4_in  in  NUMBER default null
      ) return varchar2;
   -- Update columns for pcard_actions ACTIVE View
   --   with updated data returned in each column
   procedure upd2
      (id_io  in out nocopy  NUMBER
      ,card_id_io  in out nocopy  NUMBER
      ,cards_nk1_io  in out nocopy  VARCHAR2
      ,cards_nk2_io  in out nocopy  VARCHAR2
      ,cards_nk3_io  in out nocopy  VARCHAR2
      ,disposition_io  in out nocopy  VARCHAR2
      ,player_id_io  in out nocopy  NUMBER
      ,players_nk1_io  in out nocopy  VARCHAR2
      ,players_nk2_io  in out nocopy  VARCHAR2
      ,players_nk3_io  in out nocopy  VARCHAR2
      ,action_id_io  in out nocopy  NUMBER
      ,actions_nk1_io  in out nocopy  VARCHAR2
      ,actions_nk2_io  in out nocopy  VARCHAR2
      ,actions_nk3_io  in out nocopy  VARCHAR2
      ,actions_nk4_io  in out nocopy  NUMBER
      );
   -- This function traps and returns any error message from the upd2 procedure
   function upd2
      (id_io  in out nocopy  NUMBER
      ,card_id_io  in out nocopy  NUMBER
      ,cards_nk1_io  in out nocopy  VARCHAR2
      ,cards_nk2_io  in out nocopy  VARCHAR2
      ,cards_nk3_io  in out nocopy  VARCHAR2
      ,disposition_io  in out nocopy  VARCHAR2
      ,player_id_io  in out nocopy  NUMBER
      ,players_nk1_io  in out nocopy  VARCHAR2
      ,players_nk2_io  in out nocopy  VARCHAR2
      ,players_nk3_io  in out nocopy  VARCHAR2
      ,action_id_io  in out nocopy  NUMBER
      ,actions_nk1_io  in out nocopy  VARCHAR2
      ,actions_nk2_io  in out nocopy  VARCHAR2
      ,actions_nk3_io  in out nocopy  VARCHAR2
      ,actions_nk4_io  in out nocopy  NUMBER
      ) return varchar2;
   -- Update columns for pcard_actions Table
   --   with updated data returned in each column
   procedure upd2
      (id_io  in out nocopy  NUMBER
      ,card_id_io  in out nocopy  NUMBER
      ,disposition_io  in out nocopy  VARCHAR2
      ,player_id_io  in out nocopy  NUMBER
      ,action_id_io  in out nocopy  NUMBER
      );
   -- This function traps and returns any error message from the upd2 procedure
   function upd2
      (id_io  in out nocopy  NUMBER
      ,card_id_io  in out nocopy  NUMBER
      ,disposition_io  in out nocopy  VARCHAR2
      ,player_id_io  in out nocopy  NUMBER
      ,action_id_io  in out nocopy  NUMBER
      ) return varchar2;

   -- Application Delete procedure without updated parameters
   procedure del
      (id_in  in  NUMBER default null
      ,card_id_in  in  NUMBER default null
      ,cards_nk1_in  in  VARCHAR2 default null
      ,cards_nk2_in  in  VARCHAR2 default null
      ,cards_nk3_in  in  VARCHAR2 default null
      ,disposition_in  in  VARCHAR2 default null
      ,player_id_in  in  NUMBER default null
      ,players_nk1_in  in  VARCHAR2 default null
      ,players_nk2_in  in  VARCHAR2 default null
      ,players_nk3_in  in  VARCHAR2 default null
      ,action_id_in  in  NUMBER default null
      ,actions_nk1_in  in  VARCHAR2 default null
      ,actions_nk2_in  in  VARCHAR2 default null
      ,actions_nk3_in  in  VARCHAR2 default null
      ,actions_nk4_in  in  NUMBER default null
      );
   -- This function traps and returns any error message from the del procedure
   function del
      (id_in  in  NUMBER default null
      ,card_id_in  in  NUMBER default null
      ,cards_nk1_in  in  VARCHAR2 default null
      ,cards_nk2_in  in  VARCHAR2 default null
      ,cards_nk3_in  in  VARCHAR2 default null
      ,disposition_in  in  VARCHAR2 default null
      ,player_id_in  in  NUMBER default null
      ,players_nk1_in  in  VARCHAR2 default null
      ,players_nk2_in  in  VARCHAR2 default null
      ,players_nk3_in  in  VARCHAR2 default null
      ,action_id_in  in  NUMBER default null
      ,actions_nk1_in  in  VARCHAR2 default null
      ,actions_nk2_in  in  VARCHAR2 default null
      ,actions_nk3_in  in  VARCHAR2 default null
      ,actions_nk4_in  in  NUMBER default null
      ) return varchar2;
   -- Application Delete procedure with updated parameters
   procedure del2
      (id_io  in out nocopy  NUMBER
      ,card_id_in  in NUMBER default null
      ,cards_nk1_in  in VARCHAR2 default null
      ,cards_nk2_in  in VARCHAR2 default null
      ,cards_nk3_in  in VARCHAR2 default null
      ,disposition_in  in VARCHAR2 default null
      ,player_id_in  in NUMBER default null
      ,players_nk1_in  in VARCHAR2 default null
      ,players_nk2_in  in VARCHAR2 default null
      ,players_nk3_in  in VARCHAR2 default null
      ,action_id_in  in NUMBER default null
      ,actions_nk1_in  in VARCHAR2 default null
      ,actions_nk2_in  in VARCHAR2 default null
      ,actions_nk3_in  in VARCHAR2 default null
      ,actions_nk4_in  in NUMBER default null
      );
   -- This function traps and returns any error message from the del2 procedure
   function del2
      (id_io  in out nocopy  NUMBER
      ,card_id_in  in NUMBER default null
      ,cards_nk1_in  in VARCHAR2 default null
      ,cards_nk2_in  in VARCHAR2 default null
      ,cards_nk3_in  in VARCHAR2 default null
      ,disposition_in  in VARCHAR2 default null
      ,player_id_in  in NUMBER default null
      ,players_nk1_in  in VARCHAR2 default null
      ,players_nk2_in  in VARCHAR2 default null
      ,players_nk3_in  in VARCHAR2 default null
      ,action_id_in  in NUMBER default null
      ,actions_nk1_in  in VARCHAR2 default null
      ,actions_nk2_in  in VARCHAR2 default null
      ,actions_nk3_in  in VARCHAR2 default null
      ,actions_nk4_in  in NUMBER default null
      ) return varchar2;

   -- Special Data Warehouse Dimension Function
   --   Attempts to find matching record based on natural keys
   --   If found, performs updates on non-NK columns that changed
   --   If not found, inserts new record
   --   Returns ID of record
   procedure load_dim
      (dim_tab  in out nocopy  pcard_actions%ROWTYPE
      );
   -- This function traps and returns any error message from the load_dim procedure
   function load_dim
      (dim_tab  in out nocopy  pcard_actions%ROWTYPE
      ) return varchar2;

end pcard_actions_dml;
/
select 'PCARD_ACTIONS_DML' as "Package:"
 from  user_errors
 where name  = 'PCARD_ACTIONS_DML'
  and  type  = 'PACKAGE'
  and  rownum = 1
/
select '('||line||'/'||position||') '||text as error
 from  user_errors
 where name = 'PCARD_ACTIONS_DML'
  and  type = 'PACKAGE'
 order by sequence
/

create package body pcard_actions_dml
is

 -- Package Body Pcard_Actions_Dml
 -- (Data Manipulation Language, Foreign Key and Path Lookup)

   -- Application: Clue Notes For Oracle
   -- Generated by DTGen (http://dmstex.com/services/dtgen)
   -- December  16, 2013  11:32:31 AM

   --
   --
   -- © Duane.Dieterich@DMSTEX.com 2013
   --
   -- All Rights Reserved
   --
   -- No part of this software may be reproduced, copied, modified or adapted,
   -- without the prior written consent of the author, unless otherwise
   -- indicated for stand-alone materials.
   --
   -- You may quote extracts from this software with attribution to
   -- Duane.Dieterich@DMSTEX.com
   --
   -- For any other mode of sharing, please contact Duane.Dieterich@DMSTEX.com.
   --
   -- Commercial use and distribution of this software is not allowed without
   -- express and prior written consent of the author.
   --
   -- THE SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
   -- INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY
   -- AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL
   -- THE COPYRIGHT HOLDER OR DMSTEX BUSINESS SOLUTIONS LLC, ITS MEMBERS,
   -- MANAGERS, OR EMPLOYEES BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
   -- SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
   -- TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
   -- PROFITS; CORRUPTION OF DATA, OR BUSINESS INTERRUPTION) HOWEVER CAUSED
   -- AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
   -- OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF
   -- THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH
   -- DAMAGE.
   --
   --


----------------------------------------
function get_next_id
      return NUMBER
is
   retid  NUMBER;
begin
   select pcard_actions_seq.nextval
    into  retid from dual;
   return retid;
end get_next_id;
----------------------------------------
function get_curr_id
      return NUMBER
is
   retid  NUMBER;
begin
   select pcard_actions_seq.currval
    into  retid from dual;
   return retid;
end get_curr_id;
----------------------------------------
function get_id
      (cards_nk1  in  VARCHAR2
      ,cards_nk2  in  VARCHAR2
      ,cards_nk3  in  VARCHAR2
      ,disposition  in  VARCHAR2
      ,players_nk1  in  VARCHAR2
      ,players_nk2  in  VARCHAR2
      ,players_nk3  in  VARCHAR2
      ,actions_nk1  in  VARCHAR2
      ,actions_nk2  in  VARCHAR2
      ,actions_nk3  in  VARCHAR2
      ,actions_nk4  in  NUMBER
      ) return number
   -- For all the Natural Key Columns, Return an ID
is
begin
   return pcard_actions_tab.get_id
      (cards_nk1
      ,cards_nk2
      ,cards_nk3
      ,disposition
      ,players_nk1
      ,players_nk2
      ,players_nk3
      ,actions_nk1
      ,actions_nk2
      ,actions_nk3
      ,actions_nk4
      );
end get_id;
----------------------------------------
-- For all the Natural Key Column IDs, Return an ID
function get_id2
      (card_id_in  in  NUMBER
      ,disposition_in  in  VARCHAR2
      ,player_id_in  in  NUMBER
      ,action_id_in  in  NUMBER
      ) return NUMBER
is
   retid  NUMBER(38);
begin
   select id
    into  retid
    from  pcard_actions  PCA
    where card_id_in = PCA.card_id
     and  disposition_in = PCA.disposition
     and  player_id_in = PCA.player_id
     and  action_id_in = PCA.action_id
    ;
   return retid;
exception when no_data_found then return null;
end get_id2;
----------------------------------------
function get_nk
      (id_in  in  NUMBER)
   return VARCHAR2
   -- For an ID, return a delimited list of Natural Key Values
is
begin
   return pcard_actions_tab.get_nk(id_in);
end get_nk;
----------------------------------------
procedure clear
      (n_rec  in out nocopy  pcard_actions_act%ROWTYPE
      )
is
begin
   n_rec.id := null;
   n_rec.card_id := null;
   n_rec.cards_nk1 := null;
   n_rec.cards_nk2 := null;
   n_rec.cards_nk3 := null;
   n_rec.disposition := null;
   n_rec.player_id := null;
   n_rec.players_nk1 := null;
   n_rec.players_nk2 := null;
   n_rec.players_nk3 := null;
   n_rec.action_id := null;
   n_rec.actions_nk1 := null;
   n_rec.actions_nk2 := null;
   n_rec.actions_nk3 := null;
   n_rec.actions_nk4 := null;
end clear;
----------
function clear
      (n_rec  in out nocopy  pcard_actions_act%ROWTYPE
      ) return varchar2
is
begin
   clear(n_rec);
   return '';
exception when others then return sqlerrm;
end clear;
----------------------------------------
procedure clear
      (n_tab  in out nocopy  pcard_actions%ROWTYPE
      )
is
begin
   n_tab.id := null;
   n_tab.card_id := null;
   n_tab.disposition := null;
   n_tab.player_id := null;
   n_tab.action_id := null;
end clear;
----------
function clear
      (n_tab  in out nocopy  pcard_actions%ROWTYPE
      ) return varchar2
is
begin
   clear(n_tab);
   return '';
exception when others then return sqlerrm;
end clear;
----------------------------------------
procedure get_rec_by_id
      (n_rec  in out nocopy  pcard_actions_act%ROWTYPE
      )
is
   start_tstamp  timestamp := systimestamp;
begin
   if n_rec.id is null then
      clear(n_rec);
   else
      select * into n_rec from pcard_actions_act
       where id = n_rec.id;
   end if;
   return;
   util.trc_time_interval('pcard_actions_dml.get_rec_by_id(act rec) ID:' || n_rec.id, start_tstamp);
end get_rec_by_id;
----------
function get_rec_by_id
      (n_rec  in out nocopy  pcard_actions_act%ROWTYPE
      ) return varchar2
is
begin
   get_rec_by_id(n_rec);
   return '';
exception when others then return sqlerrm;
end get_rec_by_id;
----------------------------------------
procedure get_rec_by_id
      (n_tab  in out nocopy  pcard_actions%ROWTYPE
      )
is
   start_tstamp  timestamp := systimestamp;
begin
   if n_tab.id is null then
      clear(n_tab);
   else
      select * into n_tab from pcard_actions
       where id = n_tab.id;
   end if;
   return;
   util.trc_time_interval('pcard_actions_dml.get_rec_by_id(tab rec) ID:' || n_tab.id, start_tstamp);
end get_rec_by_id;
----------
function get_rec_by_id
      (n_tab  in out nocopy  pcard_actions%ROWTYPE
      ) return varchar2
is
begin
   get_rec_by_id(n_tab);
   return '';
exception when others then return sqlerrm;
end get_rec_by_id;
----------------------------------------
-- Insert a pcard_actions ACTIVE View Record
procedure ins
      (new_rec  in out nocopy  pcard_actions_act%ROWTYPE
      ,upd_vals_in  in  boolean default TRUE
      )
is
   new_tab  pcard_actions%ROWTYPE;
   start_tstamp  timestamp := systimestamp;
begin
   -- Set new_rec.card_id, if needed
   if new_rec.card_id is null then
      if    new_rec.cards_nk1 is not null
        and new_rec.cards_nk2 is not null
        and new_rec.cards_nk3 is not null
      then
         new_rec.card_id := cards_tab.get_id
            (new_rec.cards_nk1
            ,new_rec.cards_nk2
            ,new_rec.cards_nk3
            );
         if new_rec.card_id is null then
            raise_application_error(-20020, 'Null ID was returned from cards_tab.get_id');
         end if;
      end if;
   end if;
   -- Set new_rec.player_id, if needed
   if new_rec.player_id is null then
      if    new_rec.players_nk1 is not null
        and new_rec.players_nk2 is not null
        and new_rec.players_nk3 is not null
      then
         new_rec.player_id := players_tab.get_id
            (new_rec.players_nk1
            ,new_rec.players_nk2
            ,new_rec.players_nk3
            );
         if new_rec.player_id is null then
            raise_application_error(-20020, 'Null ID was returned from players_tab.get_id');
         end if;
      end if;
   end if;
   -- Set new_rec.action_id, if needed
   if new_rec.action_id is null then
      if    new_rec.actions_nk1 is not null
        and new_rec.actions_nk2 is not null
        and new_rec.actions_nk3 is not null
        and new_rec.actions_nk4 is not null
      then
         new_rec.action_id := actions_tab.get_id
            (new_rec.actions_nk1
            ,new_rec.actions_nk2
            ,new_rec.actions_nk3
            ,new_rec.actions_nk4
            );
         if new_rec.action_id is null then
            raise_application_error(-20020, 'Null ID was returned from actions_tab.get_id');
         end if;
      end if;
   end if;
   new_tab.id := new_rec.id;
   new_tab.card_id := new_rec.card_id;
   new_tab.disposition := new_rec.disposition;
   new_tab.player_id := new_rec.player_id;
   new_tab.action_id := new_rec.action_id;
   pcard_actions_tab.ins(new_tab);
   if upd_vals_in then
      -- pcard_actions_tab.ins returns a new ID, if needed
      select * into new_rec from pcard_actions_act
       where id = new_tab.id;
   end if;
   return;
   util.trc_time_interval('pcard_actions_dml.ins(act rec) ID:' || new_rec.id, start_tstamp);
end ins;
----------
function ins
      (new_rec  in out nocopy  pcard_actions_act%ROWTYPE
      ,upd_vals_in  in  boolean default TRUE
      ) return varchar2
is
begin
   ins(new_rec, upd_vals_in);
   return '';
exception when others then return sqlerrm;
end ins;
----------------------------------------
-- Insert a pcard_actions Table Record
procedure ins
      (new_tab   in out nocopy  pcard_actions%ROWTYPE
      )
is
   start_tstamp  timestamp := systimestamp;
begin
   pcard_actions_tab.ins(new_tab);
   return;
   util.trc_time_interval('pcard_actions_dml.ins(tab rec) ID:' || new_tab.id, start_tstamp);
end ins;
----------
function ins
      (new_tab   in out nocopy  pcard_actions%ROWTYPE
      ) return varchar2
is
begin
   ins(new_tab);
   return '';
exception when others then return sqlerrm;
end ins;
----------------------------------------
-- Insert columns for pcard_actions ACTIVE View
--   without returning updated data in each column
procedure ins
      (id_in  in  NUMBER default null
      ,card_id_in  in  NUMBER default null
      ,cards_nk1_in  in  VARCHAR2 default null
      ,cards_nk2_in  in  VARCHAR2 default null
      ,cards_nk3_in  in  VARCHAR2 default null
      ,disposition_in  in  VARCHAR2 default null
      ,player_id_in  in  NUMBER default null
      ,players_nk1_in  in  VARCHAR2 default null
      ,players_nk2_in  in  VARCHAR2 default null
      ,players_nk3_in  in  VARCHAR2 default null
      ,action_id_in  in  NUMBER default null
      ,actions_nk1_in  in  VARCHAR2 default null
      ,actions_nk2_in  in  VARCHAR2 default null
      ,actions_nk3_in  in  VARCHAR2 default null
      ,actions_nk4_in  in  NUMBER default null
      )
is
   new_rec  pcard_actions_act%ROWTYPE;
   start_tstamp  timestamp := systimestamp;
begin
   new_rec.id := id_in;
   new_rec.card_id := card_id_in;
   new_rec.cards_nk1 := cards_nk1_in;
   new_rec.cards_nk2 := cards_nk2_in;
   new_rec.cards_nk3 := cards_nk3_in;
   new_rec.disposition := disposition_in;
   new_rec.player_id := player_id_in;
   new_rec.players_nk1 := players_nk1_in;
   new_rec.players_nk2 := players_nk2_in;
   new_rec.players_nk3 := players_nk3_in;
   new_rec.action_id := action_id_in;
   new_rec.actions_nk1 := actions_nk1_in;
   new_rec.actions_nk2 := actions_nk2_in;
   new_rec.actions_nk3 := actions_nk3_in;
   new_rec.actions_nk4 := actions_nk4_in;
   ins(new_rec, FALSE);
   return;
   util.trc_time_interval('pcard_actions_dml.ins(tab col) ID:' || id_in, start_tstamp);
end ins;
----------
function ins
      (id_in  in  NUMBER default null
      ,card_id_in  in  NUMBER default null
      ,cards_nk1_in  in  VARCHAR2 default null
      ,cards_nk2_in  in  VARCHAR2 default null
      ,cards_nk3_in  in  VARCHAR2 default null
      ,disposition_in  in  VARCHAR2 default null
      ,player_id_in  in  NUMBER default null
      ,players_nk1_in  in  VARCHAR2 default null
      ,players_nk2_in  in  VARCHAR2 default null
      ,players_nk3_in  in  VARCHAR2 default null
      ,action_id_in  in  NUMBER default null
      ,actions_nk1_in  in  VARCHAR2 default null
      ,actions_nk2_in  in  VARCHAR2 default null
      ,actions_nk3_in  in  VARCHAR2 default null
      ,actions_nk4_in  in  NUMBER default null
      ) return varchar2
is
begin
   ins
      (id_in
      ,card_id_in
      ,cards_nk1_in
      ,cards_nk2_in
      ,cards_nk3_in
      ,disposition_in
      ,player_id_in
      ,players_nk1_in
      ,players_nk2_in
      ,players_nk3_in
      ,action_id_in
      ,actions_nk1_in
      ,actions_nk2_in
      ,actions_nk3_in
      ,actions_nk4_in
      );
   return '';
exception when others then return sqlerrm;
end ins;
----------------------------------------
-- Insert columns for pcard_actions ACTIVE View
--   with updated data returned in each column
procedure ins2
      (id_io  in out nocopy  NUMBER
      ,card_id_io  in out nocopy  NUMBER
      ,cards_nk1_io  in out nocopy  VARCHAR2
      ,cards_nk2_io  in out nocopy  VARCHAR2
      ,cards_nk3_io  in out nocopy  VARCHAR2
      ,disposition_io  in out nocopy  VARCHAR2
      ,player_id_io  in out nocopy  NUMBER
      ,players_nk1_io  in out nocopy  VARCHAR2
      ,players_nk2_io  in out nocopy  VARCHAR2
      ,players_nk3_io  in out nocopy  VARCHAR2
      ,action_id_io  in out nocopy  NUMBER
      ,actions_nk1_io  in out nocopy  VARCHAR2
      ,actions_nk2_io  in out nocopy  VARCHAR2
      ,actions_nk3_io  in out nocopy  VARCHAR2
      ,actions_nk4_io  in out nocopy  NUMBER
      )
is
   new_rec  pcard_actions_act%ROWTYPE;
   start_tstamp  timestamp := systimestamp;
begin
   new_rec.id := id_io;
   new_rec.card_id := card_id_io;
   new_rec.cards_nk1 := cards_nk1_io;
   new_rec.cards_nk2 := cards_nk2_io;
   new_rec.cards_nk3 := cards_nk3_io;
   new_rec.disposition := disposition_io;
   new_rec.player_id := player_id_io;
   new_rec.players_nk1 := players_nk1_io;
   new_rec.players_nk2 := players_nk2_io;
   new_rec.players_nk3 := players_nk3_io;
   new_rec.action_id := action_id_io;
   new_rec.actions_nk1 := actions_nk1_io;
   new_rec.actions_nk2 := actions_nk2_io;
   new_rec.actions_nk3 := actions_nk3_io;
   new_rec.actions_nk4 := actions_nk4_io;
   --
   ins(new_rec);
   --
   id_io := new_rec.id;
   card_id_io := new_rec.card_id;
   cards_nk1_io := new_rec.cards_nk1;
   cards_nk2_io := new_rec.cards_nk2;
   cards_nk3_io := new_rec.cards_nk3;
   disposition_io := new_rec.disposition;
   player_id_io := new_rec.player_id;
   players_nk1_io := new_rec.players_nk1;
   players_nk2_io := new_rec.players_nk2;
   players_nk3_io := new_rec.players_nk3;
   action_id_io := new_rec.action_id;
   actions_nk1_io := new_rec.actions_nk1;
   actions_nk2_io := new_rec.actions_nk2;
   actions_nk3_io := new_rec.actions_nk3;
   actions_nk4_io := new_rec.actions_nk4;
   return;
   util.trc_time_interval('pcard_actions_dml.ins2(tab col) ID:' || id_io, start_tstamp);
end ins2;
----------
function ins2
      (id_io  in out nocopy  NUMBER
      ,card_id_io  in out nocopy  NUMBER
      ,cards_nk1_io  in out nocopy  VARCHAR2
      ,cards_nk2_io  in out nocopy  VARCHAR2
      ,cards_nk3_io  in out nocopy  VARCHAR2
      ,disposition_io  in out nocopy  VARCHAR2
      ,player_id_io  in out nocopy  NUMBER
      ,players_nk1_io  in out nocopy  VARCHAR2
      ,players_nk2_io  in out nocopy  VARCHAR2
      ,players_nk3_io  in out nocopy  VARCHAR2
      ,action_id_io  in out nocopy  NUMBER
      ,actions_nk1_io  in out nocopy  VARCHAR2
      ,actions_nk2_io  in out nocopy  VARCHAR2
      ,actions_nk3_io  in out nocopy  VARCHAR2
      ,actions_nk4_io  in out nocopy  NUMBER
      ) return varchar2
is
begin
   ins2
      (id_io
      ,card_id_io
      ,cards_nk1_io
      ,cards_nk2_io
      ,cards_nk3_io
      ,disposition_io
      ,player_id_io
      ,players_nk1_io
      ,players_nk2_io
      ,players_nk3_io
      ,action_id_io
      ,actions_nk1_io
      ,actions_nk2_io
      ,actions_nk3_io
      ,actions_nk4_io
      );
   return '';
exception when others then return sqlerrm;
end ins2;
----------------------------------------
-- Insert columns for pcard_actions Table
--   with updated data returned in each column
procedure ins2
      (id_io  in out nocopy  NUMBER
      ,card_id_io  in out nocopy  NUMBER
      ,disposition_io  in out nocopy  VARCHAR2
      ,player_id_io  in out nocopy  NUMBER
      ,action_id_io  in out nocopy  NUMBER
      )
is
   new_rec  pcard_actions%ROWTYPE;
   start_tstamp  timestamp := systimestamp;
begin
   new_rec.id := id_io;
   new_rec.card_id := card_id_io;
   new_rec.disposition := disposition_io;
   new_rec.player_id := player_id_io;
   new_rec.action_id := action_id_io;
   --
   pcard_actions_tab.ins(new_rec);
   --
   id_io := new_rec.id;
   card_id_io := new_rec.card_id;
   disposition_io := new_rec.disposition;
   player_id_io := new_rec.player_id;
   action_id_io := new_rec.action_id;
   return;
   util.trc_time_interval('pcard_actions_dml.ins2(tab col) ID:' || id_io, start_tstamp);
end ins2;
----------
function ins2
      (id_io  in out nocopy  NUMBER
      ,card_id_io  in out nocopy  NUMBER
      ,disposition_io  in out nocopy  VARCHAR2
      ,player_id_io  in out nocopy  NUMBER
      ,action_id_io  in out nocopy  NUMBER
      ) return varchar2
is
begin
   ins2
      (id_io
      ,card_id_io
      ,disposition_io
      ,player_id_io
      ,action_id_io
      );
   return '';
exception when others then return sqlerrm;
end ins2;
----------------------------------------
-- Special Use Update for Specific Column Updates.
--   Only differences between old and new data will be updated.
--   Set upd_val_in TRUE to get updated data in new_rec
procedure upd
      (old_rec  in  pcard_actions_act%ROWTYPE
      ,new_rec  in out nocopy  pcard_actions_act%ROWTYPE
      ,upd_vals_in  in  boolean default FALSE
      )
is
   old_tab  pcard_actions%ROWTYPE;
   new_tab  pcard_actions%ROWTYPE;
   start_tstamp  timestamp := systimestamp;
begin
   if old_rec.id is null then
      raise_application_error (-20023, 'ID is null');
   end if;
   -- Set new_rec.card_id, if needed
   if new_rec.card_id is null then
      if    new_rec.cards_nk1 is not null
        and new_rec.cards_nk2 is not null
        and new_rec.cards_nk3 is not null
      then
         new_rec.card_id := cards_tab.get_id
            (new_rec.cards_nk1
            ,new_rec.cards_nk2
            ,new_rec.cards_nk3
            );
         if new_rec.card_id is null then
            raise_application_error(-20020, 'Null ID was returned from cards_tab.get_id');
         end if;
      end if;
   end if;
   -- Set new_rec.player_id, if needed
   if new_rec.player_id is null then
      if    new_rec.players_nk1 is not null
        and new_rec.players_nk2 is not null
        and new_rec.players_nk3 is not null
      then
         new_rec.player_id := players_tab.get_id
            (new_rec.players_nk1
            ,new_rec.players_nk2
            ,new_rec.players_nk3
            );
         if new_rec.player_id is null then
            raise_application_error(-20020, 'Null ID was returned from players_tab.get_id');
         end if;
      end if;
   end if;
   -- Set new_rec.action_id, if needed
   if new_rec.action_id is null then
      if    new_rec.actions_nk1 is not null
        and new_rec.actions_nk2 is not null
        and new_rec.actions_nk3 is not null
        and new_rec.actions_nk4 is not null
      then
         new_rec.action_id := actions_tab.get_id
            (new_rec.actions_nk1
            ,new_rec.actions_nk2
            ,new_rec.actions_nk3
            ,new_rec.actions_nk4
            );
         if new_rec.action_id is null then
            raise_application_error(-20020, 'Null ID was returned from actions_tab.get_id');
         end if;
      end if;
   end if;
   -- Set new_rec.card_id, if needed
   if new_rec.card_id = old_rec.card_id then
      if    not (new_rec.cards_nk1 = old_rec.cards_nk1)
        or  not (new_rec.cards_nk2 = old_rec.cards_nk2)
        or  not (new_rec.cards_nk3 = old_rec.cards_nk3)
      then
         new_rec.card_id := cards_tab.get_id
            (new_rec.cards_nk1
            ,new_rec.cards_nk2
            ,new_rec.cards_nk3
            );
         if new_rec.card_id is null then
            raise_application_error(-20020, 'Null ID was returned from cards_tab.get_id');
         end if;
      end if;
   end if;
   -- Set new_rec.player_id, if needed
   if new_rec.player_id = old_rec.player_id then
      if    not (new_rec.players_nk1 = old_rec.players_nk1)
        or  not (new_rec.players_nk2 = old_rec.players_nk2)
        or  not (new_rec.players_nk3 = old_rec.players_nk3)
      then
         new_rec.player_id := players_tab.get_id
            (new_rec.players_nk1
            ,new_rec.players_nk2
            ,new_rec.players_nk3
            );
         if new_rec.player_id is null then
            raise_application_error(-20020, 'Null ID was returned from players_tab.get_id');
         end if;
      end if;
   end if;
   -- Set new_rec.action_id, if needed
   if new_rec.action_id = old_rec.action_id then
      if    not (new_rec.actions_nk1 = old_rec.actions_nk1)
        or  not (new_rec.actions_nk2 = old_rec.actions_nk2)
        or  not (new_rec.actions_nk3 = old_rec.actions_nk3)
        or  not (new_rec.actions_nk4 = old_rec.actions_nk4)
      then
         new_rec.action_id := actions_tab.get_id
            (new_rec.actions_nk1
            ,new_rec.actions_nk2
            ,new_rec.actions_nk3
            ,new_rec.actions_nk4
            );
         if new_rec.action_id is null then
            raise_application_error(-20020, 'Null ID was returned from actions_tab.get_id');
         end if;
      end if;
   end if;
   -- Load the Table Record from the View Record
   old_tab.id := old_rec.id;
   new_tab.id := new_rec.id;
   old_tab.card_id := old_rec.card_id;
   new_tab.card_id := new_rec.card_id;
   old_tab.disposition := old_rec.disposition;
   new_tab.disposition := new_rec.disposition;
   old_tab.player_id := old_rec.player_id;
   new_tab.player_id := new_rec.player_id;
   old_tab.action_id := old_rec.action_id;
   new_tab.action_id := new_rec.action_id;
   -- Run the update
   pcard_actions_tab.upd(old_tab, new_tab);
   if upd_vals_in then
      -- Load the View Record from the Returned (new) Table Record
      -- pcard_actions_tab.upd should have set new ID = old ID
      select * into new_rec from pcard_actions_act
       where id = old_tab.id;
   end if;
   return;
   util.trc_time_interval('pcard_actions_dml.upd(trigger) ID:' || old_tab.id, start_tstamp);
end upd;
----------
function upd
      (old_rec  in  pcard_actions_act%ROWTYPE
      ,new_rec  in out nocopy  pcard_actions_act%ROWTYPE
      ,upd_vals_in  in  boolean default FALSE
      ) return varchar2
is
begin
   upd(old_rec, new_rec, upd_vals_in);
   return '';
exception when others then return sqlerrm;
end upd;
----------------------------------------
-- Special Use Update for Specific Column Updates.
--   Only differences between old and new data will be updated.
--   Set upd_val_in TRUE to get updated data in new_rec
procedure upd
      (old_tab  in  pcard_actions%ROWTYPE
      ,new_tab  in out nocopy  pcard_actions%ROWTYPE
      )
is
   start_tstamp  timestamp := systimestamp;
begin
   if old_tab.id is null then
      raise_application_error (-20023, 'ID is null');
   end if;
   -- Run the update
   pcard_actions_tab.upd(old_tab, new_tab);
   return;
   util.trc_time_interval('pcard_actions_dml.upd(trigger) ID:' || old_tab.id, start_tstamp);
end upd;
----------
function upd
      (old_tab  in  pcard_actions%ROWTYPE
      ,new_tab  in out nocopy  pcard_actions%ROWTYPE
      ) return varchar2
is
begin
   upd(old_tab, new_tab);
   return '';
exception when others then return sqlerrm;
end upd;
----------------------------------------
-- Update a pcard_actions ACTIVE View Record
procedure upd
      (new_rec  in out nocopy  pcard_actions_act%ROWTYPE
      ,upd_vals_in  in  boolean default TRUE
      )
is
   old_rec  pcard_actions_act%ROWTYPE;
   start_tstamp  timestamp := systimestamp;
begin
   if new_rec.id is null then
      if    new_rec.cards_nk1 is not null
        and new_rec.cards_nk2 is not null
        and new_rec.cards_nk3 is not null
        and new_rec.disposition is not null
        and new_rec.players_nk1 is not null
        and new_rec.players_nk2 is not null
        and new_rec.players_nk3 is not null
        and new_rec.actions_nk1 is not null
        and new_rec.actions_nk2 is not null
        and new_rec.actions_nk3 is not null
        and new_rec.actions_nk4 is not null
      then
         new_rec.id := pcard_actions_tab.get_id
            (new_rec.cards_nk1
            ,new_rec.cards_nk2
            ,new_rec.cards_nk3
            ,new_rec.disposition
            ,new_rec.players_nk1
            ,new_rec.players_nk2
            ,new_rec.players_nk3
            ,new_rec.actions_nk1
            ,new_rec.actions_nk2
            ,new_rec.actions_nk3
            ,new_rec.actions_nk4
            );
      end if;
   end if;
   if new_rec.id is null then
      if    new_rec.card_id is not null
        and new_rec.disposition is not null
        and new_rec.player_id is not null
        and new_rec.action_id is not null
      then
         begin
            select id into new_rec.id from pcard_actions
             where card_id = new_rec.card_id
              and  disposition = new_rec.disposition
              and  player_id = new_rec.player_id
              and  action_id = new_rec.action_id
               ;
         exception when NO_DATA_FOUND then new_rec.id := null;
         end;
      end if;
   end if;
   if new_rec.id is null then
      raise_application_error (-20023, 'ID is null and could not be found from Natural Keys');
   end if;
   select * into old_rec from pcard_actions_act
    where id = new_rec.id;
   upd(old_rec, new_rec, upd_vals_in);
   return;
   util.trc_time_interval('pcard_actions_dml.upd(act rec) ID:' || new_rec.id, start_tstamp);
end upd;
----------
function upd
      (new_rec  in out nocopy  pcard_actions_act%ROWTYPE
      ,upd_vals_in  in  boolean default TRUE
      ) return varchar2
is
begin
   upd(new_rec, upd_vals_in);
   return '';
exception when others then return sqlerrm;
end upd;
----------------------------------------
-- Update a pcard_actions Table Record
procedure upd
      (new_tab   in out nocopy  pcard_actions%ROWTYPE
      )
is
   start_tstamp  timestamp := systimestamp;
begin
   if new_tab.id is null then
      if    new_tab.card_id is not null
        and new_tab.disposition is not null
        and new_tab.player_id is not null
        and new_tab.action_id is not null
      then
         begin
            select id into new_tab.id from pcard_actions
             where card_id = new_tab.card_id
              and  disposition = new_tab.disposition
              and  player_id = new_tab.player_id
              and  action_id = new_tab.action_id
               ;
         exception when NO_DATA_FOUND then new_tab.id := null;
         end;
      end if;
   end if;
   if new_tab.id is null then
      raise_application_error (-20023, 'ID is null and could not be found from Natural Keys');
   end if;
   pcard_actions_tab.upd(new_tab);
   return;
   util.trc_time_interval('pcard_actions_dml.upd(tab rec) ID:' || new_tab.id, start_tstamp);
end upd;
----------
function upd
      (new_tab   in out nocopy  pcard_actions%ROWTYPE
      ) return varchar2
is
begin
   upd(new_tab);
   return '';
exception when others then return sqlerrm;
end upd;
----------------------------------------
-- Update columns for pcard_actions ACTIVE View
--   without returning updated data in each column
procedure upd
      (id_in  in  NUMBER default null
      ,card_id_in  in  NUMBER default null
      ,cards_nk1_in  in  VARCHAR2 default null
      ,cards_nk2_in  in  VARCHAR2 default null
      ,cards_nk3_in  in  VARCHAR2 default null
      ,disposition_in  in  VARCHAR2 default null
      ,player_id_in  in  NUMBER default null
      ,players_nk1_in  in  VARCHAR2 default null
      ,players_nk2_in  in  VARCHAR2 default null
      ,players_nk3_in  in  VARCHAR2 default null
      ,action_id_in  in  NUMBER default null
      ,actions_nk1_in  in  VARCHAR2 default null
      ,actions_nk2_in  in  VARCHAR2 default null
      ,actions_nk3_in  in  VARCHAR2 default null
      ,actions_nk4_in  in  NUMBER default null
      )
is
   new_rec  pcard_actions_act%ROWTYPE;
   start_tstamp  timestamp := systimestamp;
begin
   new_rec.id := id_in;
   new_rec.card_id := card_id_in;
   new_rec.cards_nk1 := cards_nk1_in;
   new_rec.cards_nk2 := cards_nk2_in;
   new_rec.cards_nk3 := cards_nk3_in;
   new_rec.disposition := disposition_in;
   new_rec.player_id := player_id_in;
   new_rec.players_nk1 := players_nk1_in;
   new_rec.players_nk2 := players_nk2_in;
   new_rec.players_nk3 := players_nk3_in;
   new_rec.action_id := action_id_in;
   new_rec.actions_nk1 := actions_nk1_in;
   new_rec.actions_nk2 := actions_nk2_in;
   new_rec.actions_nk3 := actions_nk3_in;
   new_rec.actions_nk4 := actions_nk4_in;
   -- Make corrections when ID is supplied, but NK is missing
   if    new_rec.ID is not null
     and new_rec.cards_nk1 is null
     and new_rec.cards_nk2 is null
     and new_rec.cards_nk3 is null
     and new_rec.disposition is null
     and new_rec.players_nk1 is null
     and new_rec.players_nk2 is null
     and new_rec.players_nk3 is null
     and new_rec.actions_nk1 is null
     and new_rec.actions_nk2 is null
     and new_rec.actions_nk3 is null
     and new_rec.actions_nk4 is null
   then
      select PCA.cards_nk1
            ,PCA.cards_nk2
            ,PCA.cards_nk3
            ,PCA.disposition
            ,PCA.players_nk1
            ,PCA.players_nk2
            ,PCA.players_nk3
            ,PCA.actions_nk1
            ,PCA.actions_nk2
            ,PCA.actions_nk3
            ,PCA.actions_nk4
       into  new_rec.cards_nk1
            ,new_rec.cards_nk2
            ,new_rec.cards_nk3
            ,new_rec.disposition
            ,new_rec.players_nk1
            ,new_rec.players_nk2
            ,new_rec.players_nk3
            ,new_rec.actions_nk1
            ,new_rec.actions_nk2
            ,new_rec.actions_nk3
            ,new_rec.actions_nk4
       from  pcard_actions_act  PCA
       where PCA.id = new_rec.ID;
   end if;
   -- Make corrections when card_id is supplied, but the Natural Key is missing
   if    new_rec.card_id is not null
     and new_rec.cards_nk1 is null
     and new_rec.cards_nk2 is null
     and new_rec.cards_nk3 is null
   then
      select CRD.games_nk1
            ,CRD.games_nk2
            ,CRD.name
       into  new_rec.cards_nk1
            ,new_rec.cards_nk2
            ,new_rec.cards_nk3
       from  cards_act  CRD
       where CRD.id = new_rec.card_id;
   end if;
   -- Make corrections when player_id is supplied, but the Natural Key is missing
   if    new_rec.player_id is not null
     and new_rec.players_nk1 is null
     and new_rec.players_nk2 is null
     and new_rec.players_nk3 is null
   then
      select PLY.games_nk1
            ,PLY.games_nk2
            ,PLY.name
       into  new_rec.players_nk1
            ,new_rec.players_nk2
            ,new_rec.players_nk3
       from  players_act  PLY
       where PLY.id = new_rec.player_id;
   end if;
   -- Make corrections when action_id is supplied, but the Natural Key is missing
   if    new_rec.action_id is not null
     and new_rec.actions_nk1 is null
     and new_rec.actions_nk2 is null
     and new_rec.actions_nk3 is null
     and new_rec.actions_nk4 is null
   then
      select ACT.players_nk1
            ,ACT.players_nk2
            ,ACT.players_nk3
            ,ACT.seq
       into  new_rec.actions_nk1
            ,new_rec.actions_nk2
            ,new_rec.actions_nk3
            ,new_rec.actions_nk4
       from  actions_act  ACT
       where ACT.id = new_rec.action_id;
   end if;
   upd(new_rec, FALSE);
   return;
   util.trc_time_interval('pcard_actions_dml.upd(act col) ID:' || id_in, start_tstamp);
end upd;
----------
function upd
      (id_in  in  NUMBER default null
      ,card_id_in  in  NUMBER default null
      ,cards_nk1_in  in  VARCHAR2 default null
      ,cards_nk2_in  in  VARCHAR2 default null
      ,cards_nk3_in  in  VARCHAR2 default null
      ,disposition_in  in  VARCHAR2 default null
      ,player_id_in  in  NUMBER default null
      ,players_nk1_in  in  VARCHAR2 default null
      ,players_nk2_in  in  VARCHAR2 default null
      ,players_nk3_in  in  VARCHAR2 default null
      ,action_id_in  in  NUMBER default null
      ,actions_nk1_in  in  VARCHAR2 default null
      ,actions_nk2_in  in  VARCHAR2 default null
      ,actions_nk3_in  in  VARCHAR2 default null
      ,actions_nk4_in  in  NUMBER default null
      ) return varchar2
is
begin
   upd
      (id_in
      ,card_id_in
      ,cards_nk1_in
      ,cards_nk2_in
      ,cards_nk3_in
      ,disposition_in
      ,player_id_in
      ,players_nk1_in
      ,players_nk2_in
      ,players_nk3_in
      ,action_id_in
      ,actions_nk1_in
      ,actions_nk2_in
      ,actions_nk3_in
      ,actions_nk4_in
      );
   return '';
exception when others then return sqlerrm;
end upd;
----------------------------------------
-- Update columns for pcard_actions ACTIVE View
--   with updated data returned in each column
procedure upd2
      (id_io  in out nocopy  NUMBER
      ,card_id_io  in out nocopy  NUMBER
      ,cards_nk1_io  in out nocopy  VARCHAR2
      ,cards_nk2_io  in out nocopy  VARCHAR2
      ,cards_nk3_io  in out nocopy  VARCHAR2
      ,disposition_io  in out nocopy  VARCHAR2
      ,player_id_io  in out nocopy  NUMBER
      ,players_nk1_io  in out nocopy  VARCHAR2
      ,players_nk2_io  in out nocopy  VARCHAR2
      ,players_nk3_io  in out nocopy  VARCHAR2
      ,action_id_io  in out nocopy  NUMBER
      ,actions_nk1_io  in out nocopy  VARCHAR2
      ,actions_nk2_io  in out nocopy  VARCHAR2
      ,actions_nk3_io  in out nocopy  VARCHAR2
      ,actions_nk4_io  in out nocopy  NUMBER
      )
is
   new_rec  pcard_actions_act%ROWTYPE;
   start_tstamp  timestamp := systimestamp;
begin
   new_rec.id := id_io;
   new_rec.card_id := card_id_io;
   new_rec.cards_nk1 := cards_nk1_io;
   new_rec.cards_nk2 := cards_nk2_io;
   new_rec.cards_nk3 := cards_nk3_io;
   new_rec.disposition := disposition_io;
   new_rec.player_id := player_id_io;
   new_rec.players_nk1 := players_nk1_io;
   new_rec.players_nk2 := players_nk2_io;
   new_rec.players_nk3 := players_nk3_io;
   new_rec.action_id := action_id_io;
   new_rec.actions_nk1 := actions_nk1_io;
   new_rec.actions_nk2 := actions_nk2_io;
   new_rec.actions_nk3 := actions_nk3_io;
   new_rec.actions_nk4 := actions_nk4_io;
   --
   --  upd(new_rec) will set new_rec.id as needed
   upd(new_rec);
   --
   id_io := new_rec.id;
   card_id_io := new_rec.card_id;
   cards_nk1_io := new_rec.cards_nk1;
   cards_nk2_io := new_rec.cards_nk2;
   cards_nk3_io := new_rec.cards_nk3;
   disposition_io := new_rec.disposition;
   player_id_io := new_rec.player_id;
   players_nk1_io := new_rec.players_nk1;
   players_nk2_io := new_rec.players_nk2;
   players_nk3_io := new_rec.players_nk3;
   action_id_io := new_rec.action_id;
   actions_nk1_io := new_rec.actions_nk1;
   actions_nk2_io := new_rec.actions_nk2;
   actions_nk3_io := new_rec.actions_nk3;
   actions_nk4_io := new_rec.actions_nk4;
   return;
   util.trc_time_interval('pcard_actions_dml.upd2(act col) ID:' || id_io, start_tstamp);
end upd2;
----------
function upd2
      (id_io  in out nocopy  NUMBER
      ,card_id_io  in out nocopy  NUMBER
      ,cards_nk1_io  in out nocopy  VARCHAR2
      ,cards_nk2_io  in out nocopy  VARCHAR2
      ,cards_nk3_io  in out nocopy  VARCHAR2
      ,disposition_io  in out nocopy  VARCHAR2
      ,player_id_io  in out nocopy  NUMBER
      ,players_nk1_io  in out nocopy  VARCHAR2
      ,players_nk2_io  in out nocopy  VARCHAR2
      ,players_nk3_io  in out nocopy  VARCHAR2
      ,action_id_io  in out nocopy  NUMBER
      ,actions_nk1_io  in out nocopy  VARCHAR2
      ,actions_nk2_io  in out nocopy  VARCHAR2
      ,actions_nk3_io  in out nocopy  VARCHAR2
      ,actions_nk4_io  in out nocopy  NUMBER
      ) return varchar2
is
begin
   upd2
      (id_io
      ,card_id_io
      ,cards_nk1_io
      ,cards_nk2_io
      ,cards_nk3_io
      ,disposition_io
      ,player_id_io
      ,players_nk1_io
      ,players_nk2_io
      ,players_nk3_io
      ,action_id_io
      ,actions_nk1_io
      ,actions_nk2_io
      ,actions_nk3_io
      ,actions_nk4_io
      );
   return '';
exception when others then return sqlerrm;
end upd2;
----------------------------------------
-- Update columns for pcard_actions Table
--   with updated data returned in each column
procedure upd2
      (id_io  in out nocopy  NUMBER
      ,card_id_io  in out nocopy  NUMBER
      ,disposition_io  in out nocopy  VARCHAR2
      ,player_id_io  in out nocopy  NUMBER
      ,action_id_io  in out nocopy  NUMBER
      )
is
   new_rec  pcard_actions%ROWTYPE;
   start_tstamp  timestamp := systimestamp;
begin
   if id_io is null then
      if    card_id_io is not null
        and disposition_io is not null
        and player_id_io is not null
        and action_id_io is not null
      then
         begin
            select id into id_io from pcard_actions
             where card_id = card_id_io
              and  disposition = disposition_io
              and  player_id = player_id_io
              and  action_id = action_id_io
               ;
         exception when NO_DATA_FOUND then id_io := null;
         end;
      end if;
   end if;
   if id_io is null then
      raise_application_error (-20023, 'ID is null and could not be found from Natural Keys');
   end if;
   new_rec.id := id_io;
   new_rec.card_id := card_id_io;
   new_rec.disposition := disposition_io;
   new_rec.player_id := player_id_io;
   new_rec.action_id := action_id_io;
   --
   pcard_actions_tab.upd(new_rec);
   --
   id_io := new_rec.id;
   card_id_io := new_rec.card_id;
   disposition_io := new_rec.disposition;
   player_id_io := new_rec.player_id;
   action_id_io := new_rec.action_id;
   return;
   util.trc_time_interval('pcard_actions_dml.upd2(tab col) ID:' || id_io, start_tstamp);
end upd2;
----------
function upd2
      (id_io  in out nocopy  NUMBER
      ,card_id_io  in out nocopy  NUMBER
      ,disposition_io  in out nocopy  VARCHAR2
      ,player_id_io  in out nocopy  NUMBER
      ,action_id_io  in out nocopy  NUMBER
      ) return varchar2
is
begin
    upd2
      (id_io
      ,card_id_io
      ,disposition_io
      ,player_id_io
      ,action_id_io
      );
   return '';
exception when others then return sqlerrm;
end upd2;

----------------------------------------
-- Application Delete procedure without updated parameters
procedure del
      (id_in  in  NUMBER default null
      ,card_id_in  in  NUMBER default null
      ,cards_nk1_in  in  VARCHAR2 default null
      ,cards_nk2_in  in  VARCHAR2 default null
      ,cards_nk3_in  in  VARCHAR2 default null
      ,disposition_in  in  VARCHAR2 default null
      ,player_id_in  in  NUMBER default null
      ,players_nk1_in  in  VARCHAR2 default null
      ,players_nk2_in  in  VARCHAR2 default null
      ,players_nk3_in  in  VARCHAR2 default null
      ,action_id_in  in  NUMBER default null
      ,actions_nk1_in  in  VARCHAR2 default null
      ,actions_nk2_in  in  VARCHAR2 default null
      ,actions_nk3_in  in  VARCHAR2 default null
      ,actions_nk4_in  in  NUMBER default null
      )
is
   start_tstamp  timestamp := systimestamp;
   tmp_id  NUMBER;
begin
   tmp_id := id_in;
   if tmp_id is null then
      if    cards_nk1_in is not null
        and cards_nk2_in is not null
        and cards_nk3_in is not null
        and disposition_in is not null
        and players_nk1_in is not null
        and players_nk2_in is not null
        and players_nk3_in is not null
        and actions_nk1_in is not null
        and actions_nk2_in is not null
        and actions_nk3_in is not null
        and actions_nk4_in is not null
      then
         tmp_id := pcard_actions_tab.get_id
            (cards_nk1_in
            ,cards_nk2_in
            ,cards_nk3_in
            ,disposition_in
            ,players_nk1_in
            ,players_nk2_in
            ,players_nk3_in
            ,actions_nk1_in
            ,actions_nk2_in
            ,actions_nk3_in
            ,actions_nk4_in
            );
      end if;
   end if;
   if tmp_id is null then
      if    card_id_in is not null
        and disposition_in is not null
        and player_id_in is not null
        and action_id_in is not null
      then
         begin
            select id into tmp_id from pcard_actions
             where card_id = card_id_in
              and  disposition = disposition_in
              and  player_id = player_id_in
              and  action_id = action_id_in
               ;
         exception when NO_DATA_FOUND then tmp_id := null;
         end;
      end if;
   end if;
   if tmp_id is null then
      raise_application_error (-20023, 'ID is null and could not be found from Natural Keys');
   end if;
   pcard_actions_tab.del(tmp_id);
   return;
   util.trc_time_interval('pcard_actions_dml.del ID:' || id_in, start_tstamp);
end del;
----------
function del
      (id_in  in  NUMBER default null
      ,card_id_in  in  NUMBER default null
      ,cards_nk1_in  in  VARCHAR2 default null
      ,cards_nk2_in  in  VARCHAR2 default null
      ,cards_nk3_in  in  VARCHAR2 default null
      ,disposition_in  in  VARCHAR2 default null
      ,player_id_in  in  NUMBER default null
      ,players_nk1_in  in  VARCHAR2 default null
      ,players_nk2_in  in  VARCHAR2 default null
      ,players_nk3_in  in  VARCHAR2 default null
      ,action_id_in  in  NUMBER default null
      ,actions_nk1_in  in  VARCHAR2 default null
      ,actions_nk2_in  in  VARCHAR2 default null
      ,actions_nk3_in  in  VARCHAR2 default null
      ,actions_nk4_in  in  NUMBER default null
      ) return varchar2
is
begin
   del
      (id_in
      ,card_id_in
      ,cards_nk1_in
      ,cards_nk2_in
      ,cards_nk3_in
      ,disposition_in
      ,player_id_in
      ,players_nk1_in
      ,players_nk2_in
      ,players_nk3_in
      ,action_id_in
      ,actions_nk1_in
      ,actions_nk2_in
      ,actions_nk3_in
      ,actions_nk4_in
      );
   return '';
exception when others then return sqlerrm;
end del;
----------------------------------------
-- Application Delete procedure with updated parameters
procedure del2
      (id_io  in out nocopy  NUMBER
      ,card_id_in  in  NUMBER default null
      ,cards_nk1_in  in  VARCHAR2 default null
      ,cards_nk2_in  in  VARCHAR2 default null
      ,cards_nk3_in  in  VARCHAR2 default null
      ,disposition_in  in  VARCHAR2 default null
      ,player_id_in  in  NUMBER default null
      ,players_nk1_in  in  VARCHAR2 default null
      ,players_nk2_in  in  VARCHAR2 default null
      ,players_nk3_in  in  VARCHAR2 default null
      ,action_id_in  in  NUMBER default null
      ,actions_nk1_in  in  VARCHAR2 default null
      ,actions_nk2_in  in  VARCHAR2 default null
      ,actions_nk3_in  in  VARCHAR2 default null
      ,actions_nk4_in  in  NUMBER default null
      )
is
   start_tstamp  timestamp := systimestamp;
begin
   if id_io is null then
      if    cards_nk1_in is not null
        and cards_nk2_in is not null
        and cards_nk3_in is not null
        and disposition_in is not null
        and players_nk1_in is not null
        and players_nk2_in is not null
        and players_nk3_in is not null
        and actions_nk1_in is not null
        and actions_nk2_in is not null
        and actions_nk3_in is not null
        and actions_nk4_in is not null
      then
         id_io := pcard_actions_tab.get_id
            (cards_nk1_in
            ,cards_nk2_in
            ,cards_nk3_in
            ,disposition_in
            ,players_nk1_in
            ,players_nk2_in
            ,players_nk3_in
            ,actions_nk1_in
            ,actions_nk2_in
            ,actions_nk3_in
            ,actions_nk4_in
            );
      end if;
   end if;
   if id_io is null then
      if    card_id_in is not null
        and disposition_in is not null
        and player_id_in is not null
        and action_id_in is not null
      then
         begin
            select id into id_io from pcard_actions
             where card_id = card_id_in
              and  disposition = disposition_in
              and  player_id = player_id_in
              and  action_id = action_id_in
               ;
         exception when NO_DATA_FOUND then id_io := null;
         end;
      end if;
   end if;
   if id_io is null then
      raise_application_error (-20023, 'ID is null and could not be found from Natural Keys');
   end if;
   pcard_actions_tab.del(id_io);
   return;
   util.trc_time_interval('pcard_actions_dml.del2 ID:' || id_io, start_tstamp);
end del2;
----------
function del2
      (id_io  in out nocopy  NUMBER
      ,card_id_in  in  NUMBER default null
      ,cards_nk1_in  in  VARCHAR2 default null
      ,cards_nk2_in  in  VARCHAR2 default null
      ,cards_nk3_in  in  VARCHAR2 default null
      ,disposition_in  in  VARCHAR2 default null
      ,player_id_in  in  NUMBER default null
      ,players_nk1_in  in  VARCHAR2 default null
      ,players_nk2_in  in  VARCHAR2 default null
      ,players_nk3_in  in  VARCHAR2 default null
      ,action_id_in  in  NUMBER default null
      ,actions_nk1_in  in  VARCHAR2 default null
      ,actions_nk2_in  in  VARCHAR2 default null
      ,actions_nk3_in  in  VARCHAR2 default null
      ,actions_nk4_in  in  NUMBER default null
      ) return varchar2
is
begin
   del2
      (id_io
      ,card_id_in
      ,cards_nk1_in
      ,cards_nk2_in
      ,cards_nk3_in
      ,disposition_in
      ,player_id_in
      ,players_nk1_in
      ,players_nk2_in
      ,players_nk3_in
      ,action_id_in
      ,actions_nk1_in
      ,actions_nk2_in
      ,actions_nk3_in
      ,actions_nk4_in
      );
   return '';
exception when others then return sqlerrm;
end del2;
----------------------------------------
procedure load_dim
      (dim_tab  in out nocopy  pcard_actions%ROWTYPE
      )
is
   -- Special Data Warehouse Dimension Function
   start_tstamp  timestamp := systimestamp;
   procedure private_upd is
      saved_inc  boolean := util.get_ignore_no_change;
   begin
      util.set_ignore_no_change(TRUE);
      upd (dim_tab);
      util.set_ignore_no_change(saved_inc);
   exception
      when others then
         util.set_ignore_no_change(saved_inc);
         raise;
   end private_upd;
begin
   -- Attempt to find matching record based on natural keys
   if dim_tab.id is null then
      begin
         select id
          into  dim_tab.id
          from  pcard_actions
          where card_id = dim_tab.card_id
           and  card_id = dim_tab.card_id
           and  disposition = dim_tab.disposition
           and  player_id = dim_tab.player_id
           and  action_id = dim_tab.action_id
         ;
      exception
         when NO_DATA_FOUND then dim_tab.id := null;
      end;
   end if;
   if dim_tab.id is not null then
      -- If found, perform update on non-NK columns that changed
      private_upd;
      return;
      util.trc_time_interval('pcard_actions_dml.load_dimE ID:' || dim_tab.id, start_tstamp);
   end if;
   -- If not found, insert new record
   begin
      ins(dim_tab);
   exception
      when DUP_VAL_ON_INDEX then
         -- Since this can run multi-threaded, another thread
         --   may have already populated this value.
         private_upd;
   end;
   return;
   util.trc_time_interval('pcard_actions_dml.load_dim ID:' || dim_tab.id, start_tstamp);
end load_dim;
----------
function load_dim
      (dim_tab  in out nocopy  pcard_actions%ROWTYPE
      ) return varchar2
is
begin
   load_dim(dim_tab);
   return '';
exception when others then return sqlerrm;
end load_dim;
----------------------------------------
end pcard_actions_dml;
/
select 'PCARD_ACTIONS_DML' as "Package Body:"
 from  user_errors
 where name  = 'PCARD_ACTIONS_DML'
  and  type  = 'PACKAGE BODY'
  and  rownum = 1
/
select '('||line||'/'||position||') '||text as error
 from  user_errors
 where name = 'PCARD_ACTIONS_DML'
  and  type = 'PACKAGE BODY'
 order by sequence
/

create TRIGGER pcard_actions_act_ioi
   instead of insert on pcard_actions_act
   for each row
declare

   -- Trigger Pcard_Actions_Act_Ioi

   -- Application: Clue Notes For Oracle
   -- Generated by DTGen (http://dmstex.com/services/dtgen)
   -- December  16, 2013  11:32:31 AM

   --
   --
   -- © Duane.Dieterich@DMSTEX.com 2013
   --
   -- All Rights Reserved
   --
   -- No part of this software may be reproduced, copied, modified or adapted,
   -- without the prior written consent of the author, unless otherwise
   -- indicated for stand-alone materials.
   --
   -- You may quote extracts from this software with attribution to
   -- Duane.Dieterich@DMSTEX.com
   --
   -- For any other mode of sharing, please contact Duane.Dieterich@DMSTEX.com.
   --
   -- Commercial use and distribution of this software is not allowed without
   -- express and prior written consent of the author.
   --
   -- THE SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
   -- INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY
   -- AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL
   -- THE COPYRIGHT HOLDER OR DMSTEX BUSINESS SOLUTIONS LLC, ITS MEMBERS,
   -- MANAGERS, OR EMPLOYEES BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
   -- SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
   -- TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
   -- PROFITS; CORRUPTION OF DATA, OR BUSINESS INTERRUPTION) HOWEVER CAUSED
   -- AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
   -- OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF
   -- THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH
   -- DAMAGE.
   --
   --


   new_rec  pcard_actions_act%ROWTYPE;
   start_tstamp  timestamp := systimestamp;
begin
   new_rec.id := :new.id;
   new_rec.card_id := :new.card_id;
   new_rec.cards_nk1 := :new.cards_nk1;
   new_rec.cards_nk2 := :new.cards_nk2;
   new_rec.cards_nk3 := :new.cards_nk3;
   new_rec.disposition := :new.disposition;
   new_rec.player_id := :new.player_id;
   new_rec.players_nk1 := :new.players_nk1;
   new_rec.players_nk2 := :new.players_nk2;
   new_rec.players_nk3 := :new.players_nk3;
   new_rec.action_id := :new.action_id;
   new_rec.actions_nk1 := :new.actions_nk1;
   new_rec.actions_nk2 := :new.actions_nk2;
   new_rec.actions_nk3 := :new.actions_nk3;
   new_rec.actions_nk4 := :new.actions_nk4;
   pcard_actions_dml.ins(new_rec, FALSE);
   util.trc_time_interval('pcard_actions_act_ioi trigger ID:' || :new.id, start_tstamp);
end pcard_actions_act_ioi;
/
select 'PCARD_ACTIONS_ACT_IOI' as "Trigger:"
 from  user_errors
 where name  = 'PCARD_ACTIONS_ACT_IOI'
  and  type  = 'TRIGGER'
  and  rownum = 1
/
select '('||line||'/'||position||') '||text as error
 from  user_errors
 where name = 'PCARD_ACTIONS_ACT_IOI'
  and  type = 'TRIGGER'
 order by sequence
/

create TRIGGER pcard_actions_act_iou
   instead of update on pcard_actions_act
   for each row
declare

   -- Trigger Pcard_Actions_Act_Iou

   -- Application: Clue Notes For Oracle
   -- Generated by DTGen (http://dmstex.com/services/dtgen)
   -- December  16, 2013  11:32:31 AM

   --
   --
   -- © Duane.Dieterich@DMSTEX.com 2013
   --
   -- All Rights Reserved
   --
   -- No part of this software may be reproduced, copied, modified or adapted,
   -- without the prior written consent of the author, unless otherwise
   -- indicated for stand-alone materials.
   --
   -- You may quote extracts from this software with attribution to
   -- Duane.Dieterich@DMSTEX.com
   --
   -- For any other mode of sharing, please contact Duane.Dieterich@DMSTEX.com.
   --
   -- Commercial use and distribution of this software is not allowed without
   -- express and prior written consent of the author.
   --
   -- THE SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
   -- INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY
   -- AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL
   -- THE COPYRIGHT HOLDER OR DMSTEX BUSINESS SOLUTIONS LLC, ITS MEMBERS,
   -- MANAGERS, OR EMPLOYEES BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
   -- SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
   -- TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
   -- PROFITS; CORRUPTION OF DATA, OR BUSINESS INTERRUPTION) HOWEVER CAUSED
   -- AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
   -- OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF
   -- THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH
   -- DAMAGE.
   --
   --


   old_rec  pcard_actions_act%ROWTYPE;
   new_rec  pcard_actions_act%ROWTYPE;
   start_tstamp  timestamp := systimestamp;
begin
   -- NOTE: Column Specified Update DML works without this lock
   --select btab.id into new_rec.id from pcard_actions btab
   -- where btab.id = :old.id for update;
   old_rec.id := :old.id;
   new_rec.id := :new.id;
   old_rec.card_id := :old.card_id;
   new_rec.card_id := :new.card_id;
   old_rec.cards_nk1 := :old.cards_nk1;
   new_rec.cards_nk1 := :new.cards_nk1;
   old_rec.cards_nk2 := :old.cards_nk2;
   new_rec.cards_nk2 := :new.cards_nk2;
   old_rec.cards_nk3 := :old.cards_nk3;
   new_rec.cards_nk3 := :new.cards_nk3;
   old_rec.disposition := :old.disposition;
   new_rec.disposition := :new.disposition;
   old_rec.player_id := :old.player_id;
   new_rec.player_id := :new.player_id;
   old_rec.players_nk1 := :old.players_nk1;
   new_rec.players_nk1 := :new.players_nk1;
   old_rec.players_nk2 := :old.players_nk2;
   new_rec.players_nk2 := :new.players_nk2;
   old_rec.players_nk3 := :old.players_nk3;
   new_rec.players_nk3 := :new.players_nk3;
   old_rec.action_id := :old.action_id;
   new_rec.action_id := :new.action_id;
   old_rec.actions_nk1 := :old.actions_nk1;
   new_rec.actions_nk1 := :new.actions_nk1;
   old_rec.actions_nk2 := :old.actions_nk2;
   new_rec.actions_nk2 := :new.actions_nk2;
   old_rec.actions_nk3 := :old.actions_nk3;
   new_rec.actions_nk3 := :new.actions_nk3;
   old_rec.actions_nk4 := :old.actions_nk4;
   new_rec.actions_nk4 := :new.actions_nk4;
   pcard_actions_dml.upd(old_rec, new_rec);
   util.trc_time_interval('pcard_actions_act_iou trigger ID:' || :old.id, start_tstamp);
end pcard_actions_act_iou;
/
select 'PCARD_ACTIONS_ACT_IOU' as "Trigger:"
 from  user_errors
 where name  = 'PCARD_ACTIONS_ACT_IOU'
  and  type  = 'TRIGGER'
  and  rownum = 1
/
select '('||line||'/'||position||') '||text as error
 from  user_errors
 where name = 'PCARD_ACTIONS_ACT_IOU'
  and  type = 'TRIGGER'
 order by sequence
/

create TRIGGER pcard_actions_act_iod
   instead of delete on pcard_actions_act
   for each row
declare

   -- Trigger Pcard_Actions_Act_Iod

   -- Application: Clue Notes For Oracle
   -- Generated by DTGen (http://dmstex.com/services/dtgen)
   -- December  16, 2013  11:32:31 AM

   --
   --
   -- © Duane.Dieterich@DMSTEX.com 2013
   --
   -- All Rights Reserved
   --
   -- No part of this software may be reproduced, copied, modified or adapted,
   -- without the prior written consent of the author, unless otherwise
   -- indicated for stand-alone materials.
   --
   -- You may quote extracts from this software with attribution to
   -- Duane.Dieterich@DMSTEX.com
   --
   -- For any other mode of sharing, please contact Duane.Dieterich@DMSTEX.com.
   --
   -- Commercial use and distribution of this software is not allowed without
   -- express and prior written consent of the author.
   --
   -- THE SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
   -- INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY
   -- AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL
   -- THE COPYRIGHT HOLDER OR DMSTEX BUSINESS SOLUTIONS LLC, ITS MEMBERS,
   -- MANAGERS, OR EMPLOYEES BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
   -- SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
   -- TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
   -- PROFITS; CORRUPTION OF DATA, OR BUSINESS INTERRUPTION) HOWEVER CAUSED
   -- AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
   -- OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF
   -- THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH
   -- DAMAGE.
   --
   --


   start_tstamp  timestamp := systimestamp;
begin
   pcard_actions_tab.del(:old.id);
   util.trc_time_interval('pcard_actions_act_iod trigger ID:' || :old.id, start_tstamp);
end pcard_actions_act_iod;
/
select 'PCARD_ACTIONS_ACT_IOD' as "Trigger:"
 from  user_errors
 where name  = 'PCARD_ACTIONS_ACT_IOD'
  and  type  = 'TRIGGER'
  and  rownum = 1
/
select '('||line||'/'||position||') '||text as error
 from  user_errors
 where name = 'PCARD_ACTIONS_ACT_IOD'
  and  type = 'TRIGGER'
 order by sequence
/

